---
title: 3. function vs block scope
tags: [function, block scope]
sidebar_position: 3
---

<br />

## 2장에서 살펴본 것처럼

scope는 각각 컨테이너 또는 버킷 역할을 하는 일련의 **Bubble**로 구성되며, 여기서 **식별자(변수, 함수)**가 선언됩니다.

이 bubble은 서로 깔끔하게 중첩되며 이 중첩은 작성자 시점에 정의됩니다.

그러나 정확히 새로운 버블을 만드는 것은 무엇입니까? 함수뿐인가요? JavaScript의 다른 구조가 bubble을 만들 수 있습니까?

---

## Scope From Functions

JavaScript에는 함수 기반 스코프가 있습니다.

자체적인 스코프를 생성하는 다른 구조가 존재합니다.

함수 스코프를 먼저 살펴보겠습니다.

```jsx
function foo(a) {
  var b = 2;
  // some code
  function bar() {
    // ...
  }
  // more code
  var c = 3;
}
```

위 스니펫에서 foo()의 스코프에는 식별자 a,b,c 및 bar가 포함됩니다.

scope에서 선언이 나타나는 위치는 중요하지 않습니다. 변수 또는

함수는 관계없이 포함하는 범위 거품에 속합니다.

다음 장에서 이것이 정확히 어떻게 작동하는지 알아볼 것입니다.

bar(..)에는 자체 scope가 있습니다. foo라는 하나의 식별자만 연결된 전역 범위도 마찬가지입니다.
b, c 및 bar는 모두 foo(..)의 범위 버블에 속하므로 foo(..) 외부에서 액세스할 수 없습니다.

즉, 전역 범위에서 식별자를 사용할 수 없기 때문에 다음 코드에서는 모두 ReferenceError 오류가 발생합니다.

```jsx
bar(); // fails
console.log(a, b, c); // all 3 fail
```

그러나 이러한 모든 식별자(a, b, c, foo 및 bar)는 foo(..) 내부에서 액세스할 수 있으며 bar(..) 내부에서도 사용할 수 있습니다(bar(..) 내부에 섀도잉 식별자 선언이 없다고 가정)

함수 범위는 모든 변수가 함수에 속하고 함수 전체에서 사용 및 재사용될 수 있다는 아이디어를 장려합니다(실제로는 중첩 범위에서도 액세스 가능). 이 디자인 접근 방식은 매우 유용할 수 있으며 필요에 따라 다양한 유형의 값을 취하기 위해 JavaScript 변수의 "동적" 특성을 최대한 활용할 수 있습니다.

반면에 주의를 기울이지 않으면 범위 전체에 존재하는 변수로 인해 예상치 못한 함정이 발생할 수 있습니다.

---

## Hiding in Plain Scope

함수에 대한 전통적인 사고 방식은 함수를 선언한 다음 그 안에 코드를 추가하는 것입니다.
그러나 역 사고는 똑같이 강력하고 유용합니다. **작성한 코드의 임의의 섹션을 가져 와서 그 주위에 함수 선언을 래핑하면 실제로 코드를 "숨깁니다".**
실제 결과는 문제의 코드 주위에 범위 scope을 만드는 것입니다. 즉, 해당 코드의 모든 선언(변수 또는 함수)은 이제 이전이 아닌 새 래핑 함수의 범위에 연결됩니다.

**즉, 변수와 함수를 함수 범위에 넣어 "숨길" 수 있습니다.**

이러한 범위 기반 은닉에 동기를 부여하는 다양한 이유가 있습니다.

그들은 최소 권한(Least Authority) 또는 최소 노출(Least Exposure)이라고도 하는 소프트웨어 설계 원칙 Privilege[2]에서 발생하는 경향이 있습니다. 이 원칙은 모듈/객체용 API와 같은 소프트웨어 설계에서 최소한으로 필요한 것만 노출하고 나머지는 "숨겨야" 한다고 명시합니다.
이 원칙은 변수와 함수를 포함할 범위의 선택으로 확장됩니다. 모든 변수와 함수가 전역 범위에 있으면 물론 모든 중첩 범위에 액세스할 수 있습니다. 그러나 이것은 코드를 적절하게 사용하면 해당 변수/함수에 대한 액세스를 방해하므로 비공개로 유지해야 하는 많은 변수 또는 함수를 (가능성) 노출한다는 점에서 "최소..." 원칙을 위반합니다.

```jsx
function doSomething(a) {
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}

function doSomethingElse(a) {
  return a - 1;
}

var b;
doSomething(2); // 15
```

이 스니펫에서 b 변수와 doSomethingElse(..) 함수는 doSomething(..)이 작업을 수행하는 방법에 대한 "비공개" 세부 정보일 수 있습니다.
b 및 doSomethingElse(..)에 대한 범위 "접근"은 불필요할 뿐만 아니라 의도적이든 아니든 예상치 못한 방식으로 사용될 수 있고 doSomething(..)의 전제 조건 가정을 위반할 수 있다는 점에서 "위험"할 수도 있습니다. ). 보다 "적절한" 디자인은 다음과 같이 doSomething(..) 범위 내에서 이러한 개인 세부 정보를 숨깁니다.

```jsx
function doSomething(a) {
  function doSomethingElse(a) {
    return a - 1;
  }
  var b;
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}
doSomething(2); // 15
```

이제 b 및 doSomethingElse(..)는 외부에서 액세스될 수 없으며 대신 doSomething(..)에 의해서만 제어됩니다. 기능 및 최종 결과

영향을 받지는 않았지만 디자인은 일반적으로 더 나은 소프트웨어로 간주되는 개인 정보를 비공개로 유지합니다.

---

## Collision Avoidance

범위 내에서 변수와 함수를 숨기는것의 또 다른 이점은 이름은 같지만 용도가 다른 두 개의 서로 다른 식별자 간의 의도하지 않은 충돌을 방지하는 것입니다.

충돌로 인해 예상치 못한 값 덮어쓰기가 발생하는 경우가 많습니다.

```jsx
function foo() {
  function bar(a) {
    i = 3; // changing the `i` in the enclosing scope's
    // for-loop
    console.log(a + i);
  }
  for (var i = 0; i < 10; i++) {
    bar(i * 2); // oops, inifinite loop ahead!
  }
}
foo();
```

bar(..) 내부의 i = 3 할당은 i를 덮어씁니다.

강제로 i가 전역에 생겨버리는것과 같으니.

3<10으로 유지되기 때문에 무한 루프가 발생합니다.

변수 i = 3; 문제를 해결하고 이전에 언급한 i에 대해 "shadowed 변수" 선언을 생성합니다.

var j = 3;과 같이 완전히 다른 식별자 이름을 선택할수도 있지만 소프트웨어 디자인은 자연적으로 동일한 식별자 이름을 요구할 수 있으므로 스코프를 활용하여 내부 선언을 "숨기기"하는 것이 이 경우 최선의 선택입니다.

---

## Glabal namespaces

(가능성이 있는) 변수 충돌의 특히 강력한 예는 전역 범위에서 발생합니다.

프로그램에 로드된 여러 라이브러리는 내부/개인 기능과 변수를 적절하게 숨기지 않으면 서로 매우 쉽게 충돌할 수 있습니다.

이러한 라이브러리는 일반적으로 전역 범위에서 충분히 고유한 이름을 가진 단일 변수 선언(종종 개체)을 만듭니다. 그런 다음 이 개체는 해당 라이브러리의 네임스페이스로 사용되며, 여기서 기능의 모든 특정 노출은 최상위 lexical Scope 식별자 자체가 아니라 해당 개체(네임스페이스)의 property로 만들어집니다.

```jsx
var MyReallyCoolLibrary = {
  awesome: "stuff",
  doSomething: function () {
    // ...
  },
  doAnotherThing: function () {
    // ...
  },
};
```

---

### Module management

충돌 방지를 위한 또 다른 옵션은 **다양한 종속성 관리자를 사용하는 보다 현대적인 모듈 접근 방식**입니다.

이러한 도구를 사용하면 어떤 라이브러리도 전역 범위에 식별자를 추가하지 않지만 대신

종속성 관리자의 다양한 메커니즘을 사용하여 식별자를 다른 특정 범위로 명시적으로 가져올 수 있습니다.

이러한 도구에는 어휘 범위 규칙에서 면제되는 "마법" 기능이 없습니다.

그들은 여기에 설명된 범위 지정 규칙을 사용하여 식별자가 공유 범위에 삽입되지 않도록 하고 대신 충돌에 취약하지 않은 비공개 범위에 보관하여 우발적인 범위 충돌을 방지합니다.

따라서 선택하는 경우 실제로 사용할 필요 없이 방어적으로 코딩하고 종속성 관리자와 동일한 결과를 얻을 수 있습니다. 모듈 패턴에 대한 자세한 내용은 5장을 참조하십시오.

---

## Functions as Scopes

우리는 코드 조각을 가져와서 그 주위에 함수를 감쌀 수 있고, 함수의 내 외부 범위에서 포함된 변수 또는 함수 선언을 효과적으로 "숨길" 수 있음을 보았습니다.

```jsx
var a = 2;
function foo() {
  var a = 3;
  console.log(a); // 3
}
foo();
console.log(a); // 2
```

이 기술은 효과가 있지만 반드시 이상적인 것은 아닙니다.

명명된 함수 foo()를 선언해야 한다는 것입니다. 즉, **식별자 이름 foo 자체가 둘러싸는 범위(이 경우 전역)를 "오염"시킵니다.**

또한 래핑된 코드가 실제로 실행되도록 이름(foo())으로 함수를 명시적으로 호출해야 합니다.

함수에 이름이 필요하지 않은 경우거나 함수가 자동으로 실행될 수 있다면 더 이상적일 것입니다.

다행히 JavaScript는 두 가지 문제에 대한 솔루션을 제공합니다.

```jsx
var a = 2;
(function foo() {
  var a = 3;
  console.log(a); // 3
})();
console.log(a); // 2
```

여기서 무슨 일이 일어나고 있는지 분석해 보겠습니다.

먼저, 래핑 함수 문이 (function... as just function....으로 시작한다는 점에 유의하십시오. 이것은 사소한 세부 사항처럼 보일 수 있지만 실제로는
중대한 변화입니다. 함수를 표준 선언으로 처리하는 대신 함수는 함수 표현식으로 처리됩니다.

#### note

**선언과 표현식을 구별하는 가장 쉬운 방법은 명령문에서 function 단어의 위치입니다(단순한 행이 아니라 고유한 명령문).**

**함수가 명령문에서 맨 처음에 있는 경우 함수 선언입니다. 그렇지 않으면 함수 표현식입니다.**

<br />
<br />

여기서 **함수 선언과 함수 표현식 사이에서 관찰할 수 있는 주요 차이점은 이름이 식별자로 바인딩되는 위치와 관련**이 있습니다.
이전 두 스니펫을 비교합니다. 첫 번째 스니펫에서 foo라는 이름은 둘러싸는 범위에 묶여 있으며 foo()를 사용하여 직접 호출합니다. 두 번째 스니펫에서 foo라는 이름은 둘러싸는 범위에 바인딩되지 않고 대신 자체 함수 내부에만 바인딩됩니다.
즉, (function foo(){ .. }) 표현식은 식별자 foo가 외부 범위가 아니라 ..가 가리키는 범위에서만 발견된다는 것을 의미합니다. 내부에 foo라는 이름을 숨기는 것은 둘러싸는 범위를 불필요하게 오염시키지 않는다는 것을 의미합니다.

---

## Anonymous VS Named

다음과 같은 콜백 매개변수로서의 함수 표현식에 가장 익숙할 것입니다.

```jsx
setTimeout(function () {
  console.log("I waited 1 second!");
}, 1000);
```

function()...에 이름 식별자가 없기 때문에 이를 **익명 함수 표현식**이라고 합니다. 함수 표현식은 익명일 수 있지만 함수 선언은 이름을 생략할 수 없습니다. 이는 잘못된 JS 문법입니다.
익명 함수 표현식은 빠르고 쉽게 입력할 수 있으며 많은 라이브러리와 도구에서 이러한 관용적 코드 스타일을 권장하는 경향이 있습니다. 그러나 고려해야 할 몇 가지 단점이 있습니다.

1. 익명 함수에는 스택 추적에 표시할 유용한 이름이 있어 디버깅을 더 어렵게 만들 수 있습니다.

2. 이름 없이 함수 자체를 저장해야 하는 경우 재귀 등을 위해
   더 이상 사용되지 않는 arguments.callee 참조가 불행히도 필요합니다. 자체 참조가 필요한 또 다른 예는 이벤트 처리기 함수가 실행된 후 바인딩을 해제하려는 경우입니다.

3. 더 읽기/이해하기 쉬운 코드를 제공하는 데 도움이 되는 익명 기능. 설명적인 이름은 문제의 코드를 자체 문서화하는 데 도움이 됩니다.

인라인 함수 표현식은 강력하고 유용합니다. 익명과 명명의 문제는 그 점을 훼손하지 않습니다. 함수 표현식에 이름을 제공하면 이러한 모든 단점을 매우 효과적으로 해결할 수 있지만 실질적인 단점은 없습니다. **가장 좋은 방법은 항상 함수 표현식의 이름을 지정하는 것입니다.**

```jsx
setTimeout(function timeoutHandler() {
  //  Look, I have a name

  console.log("I waited 1 second!");
}, 1000);
```

---

## Invoking Function Expressions Immediately

```jsx
var a = 2;
(function foo() {
  var a = 3;
  console.log(a); // 3
})();
console.log(a); // 2
```

이제 함수를 ( ) 쌍으로 래핑하여 표현식으로 사용할 수 있으므로 (function foo(){ .. })()와 같이 끝에 다른 ()를 추가하여 해당 함수를 실행할 수 있습니다. 첫 번째 묶음( ) 쌍은 함수를 표현식으로 만들고 두 번째 () 쌍은 함수를 실행합니다.

이 패턴은 매우 일반적이어서 몇 년 전에 커뮤니티에서 IIFE라는 용어에 동의했습니다. IIFE는 즉시 호출되는 함수 표현을 의미합니다.

물론 IIFE에는 이름이 필요하지 않습니다. IIFE의 가장 일반적인 형식은 익명 함수 표현식을 사용하는 것입니다. 확실히 덜 일반적이지만 IIFE를 명명하면 익명 함수 표현식보다 앞서 언급한 모든 이점이 있으므로 채택하는 것이 좋습니다.

#### 매우 일반적인 IIFE의 또 다른 변형은 실제로는 함수 호출이고 인수를 전달한다는 사실을 사용하는 것입니다.

```jsx
var a = 2;
(function IIFE(global) {
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
})(window);
console.log(a); // 2
```

window 개체 참조를 전달하지만 매개 변수의 이름을 gloabl로 지정하여 전역 참조 대 비전역 참조에 대한 명확한 문체 묘사를 갖습니다. 물론 원하는 enclosing 스코프에서 무엇이든 전달할 수 있으며 매개변수의 이름을 원하는 대로 지정할 수 있습니다. 이것은 대부분 스타일 선택입니다.
이 패턴의 또 다른 응용 프로그램은 정의되지 않은 기본 식별자 값을 잘못 덮어써 예상치 못한 결과를 초래할 수 있다는 (사소한 틈새) 문제를 해결합니다. 매개변수에 정의되지 않은 이름을 지정하지만 해당 인수에 대한 값을 전달하지 않으면 정의되지 않은 식별자가 실제로 코드 블록에서 정의되지 않은 값임을 보장할 수 있습니다.

### 잠깐

window, global 전역 객체의 차이.

window - 브라우저 환경에서의 전역 객체.
global - node.js 환경에서의 전역 객체.

```jsx
undefined = true; // setting a land-mine for other code! avoid!
(function IIFE(undefined) {
  var a;
  if (a === undefined) {
    console.log("Undefined is safe here!");
  }
})();
```

IIFE의 또 다른 변형은 호출 및 전달할 매개변수 다음에 실행할 함수가 두 번째로 주어지는 것의 순서를 뒤집습니다.

이 패턴은 UMD(Universal Module Definition) 프로젝트에서 사용됩니다. 어떤 사람들은 약간 더 장황하지만 이해하기가 조금 더 깨끗하다고 ​​생각합니다.

```jsx
var a = 2;
(function IIFE(def) {
  def(window);
})(function def(global) {
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
});
```

def 함수 표현식은 스니펫의 후반부에 정의된 다음, 스니펫의 전반부에 정의된 IIFE 함수에 매개변수(def라고도 함)로 전달됩니다. 마지막으로 매개변수 def(함수)가 호출되어 window를 전역 매개변수로 전달합니다.

---

### Blocks as Scopes

함수는 가장 일반적인 scope 단위이며 유통 중인 대부분의 JS에서 가장 널리 사용되는 설계 접근 방식이지만 다른 범위 단위도 가능하며 이러한 다른 범위 단위를 사용하면 코드를 유지합니다.
JavaScript 이외의 많은 언어는 블록 범위를 지원하므로 해당 언어의 개발자는 사고 방식에 익숙하지만 주로 JavaScript에서만 작업한 사람들은 개념이 약간 생소할 수 있습니다.
그러나 블록 범위 방식으로 한 줄의 코드를 작성한 적이 없더라도 JavaScript에서 다음과 같은 매우 일반적인 관용구에 여전히 익숙할 것입니다.
그런 다음 스니펫의 전반부에 정의된 IIFE 함수에 매개변수(def라고도 함)로 전달됩니다. 마지막으로 매개변수 def(함수)가 호출되어 window를 전역 매개변수로 전달합니다.

```jsx
for (var i = 0; i < 10; i++) {
  console.log(i);
}
```

우리는 for 루프 헤드 내에서 직접 변수 i를 선언합니다. 아마도 우리의 의도는 해당 for 루프의 컨텍스트 내에서만 i를 사용하는 것이며 본질적으로
변수가 실제로 자신을 둘러싸는 범위(함수 또는 전역)로 범위를 지정한다는 사실을 무시하십시오.
이것이 바로 블록 범위 지정에 관한 것입니다. **변수를 사용할 위치에 최대한 가깝게, 가능한 한 지역적으로 선언합니다.**

```jsx
var foo = true;

if (foo) {
  var bar = foo * 2;
  bar = something(bar);
  console.log(bar);
}
```

우리는 if 문의 컨텍스트에서만 bar 변수를 사용하고 있으므로 if 블록 내에서 선언하는 것이 일종의 의미가 있습니다. 이 스니펫은 문체상의 이유로 본질적으로 가짜 블록 범위 지정이며 해당 범위의 다른 위치에서 실수로 bar를 사용하지 않도록 자체 시행에 의존합니다.

블록 범위는 이전의 최소 권한 원칙을 함수의 정보 숨기기에서 코드 블록의 정보 숨기기로 확장하는 도구입니다.

for 루프 예제를 다시 보십시오.

```jsx
for (var i = 0; i < 10; i++) {
  console.log(i);
}
```

왜 i 변수만 사용하여 함수의 전체 범위를 오염시키나요?
for 루프에 사용되어야 합니까?
그러나 더 중요한 것은 개발자가 의도한 목적을 벗어난 변수를 실수로 (재)사용하지 않도록 스스로를 확인하는 것을 선호할 수 있습니다. 예를 들어 잘못된 위치에서 변수를 사용하려고 하면 알 수 없는 변수에 대한 오류가 발생합니다.

i 변수에 대한 블록 범위 지정(가능한 경우)은 for 루프에서만 i를 사용할 수 있게 하여 함수의 다른 곳에서 i에 액세스하면 오류를 일으킵니다.
이는 변수가 혼란스럽거나 유지 관리하기 어려운 방식으로 재사용되지 않도록 하는 데 도움이 됩니다.
그러나 슬픈 현실은 표면적으로 JavaScript에는 블록 범위를 위한 기능이 없다는 것입니다.

---

## with

우리는 2장에서 with에 대해 배웠습니다. 그것은 눈살을 찌푸리게 하는 구조이지만 객체에서 생성된 범위가 with 문의 수명 동안만 존재한다는 점에서 블록 범위의 한 예입니다. 포함하는 범위가 아닙니다.

---

## try/catch

ES3의 JavaScript가 try/catch의 catch 절에서 변수 선언을 catch 블록으로 블록 범위로 지정했다는 사실은 거의 알려지지 않았습니다.

```jsx
try {
  undefined(); // illegal operation to force an exception!
} catch (err) {
  console.log(err); // works!
}
console.log(err); // ReferenceError: `err` not found
```

보시다시피 err은 catch 절에만 존재하며
다른 곳에서 참조하려고 할 경우 오류가 발생합니다.

### note

이 동작이 지정되고 거의 모든 표준 JS 환경(예전의 IE 제외)에 적용되지만, 두 개 이상의 catch가 있는 경우 많은 린터가 여전히 불평하는 것 같습니다.

동일한 식별자 이름으로 각각의 오류 변수를 선언하는 동일한 범위의 절. 변수가 안전하게 블록 범위이기 때문에 이것은 실제로 재정의가 아니지만 linter는 여전히 불평합니다.
이러한 불필요한 경고를 피하기 위해 일부 개발자는 캐치 변수의 이름을 err1, err2 등으로 지정합니다. 다른 개발자는 중복 변수 이름에 대한 린트 검사를 단순히 끕니다.

---

## let

지금까지 JavaScript에는 블록 범위 기능을 노출하는 이상한 틈새 동작만 있음을 보았습니다. 그것이 우리가 가진 전부이고 오랜 세월 동안이었다면 블록 범위 지정은 JavaScript 개발자에게 그다지 유용하지 않을 것입니다.
다행히 ES6은 이를 변경하고 변수를 선언하는 또 다른 방법으로 var 옆에 있는 새로운 키워드 let을 도입했습니다.
let 키워드는 변수 선언이 포함된 블록(일반적으로 { .. } 쌍)의 범위에 변수 선언을 첨부합니다. 즉, let은 암시적으로 변수 선언에 대한 모든 블록의 범위를 하이재킹합니다.

```jsx
var foo = true;
if (foo) {
  let bar = foo * 2;
  bar = something(bar);
  console.log(bar);
}
console.log(bar); // ReferenceError
```

let을 사용하여 기존 블록에 변수를 연결하는 것은 다소 암시적입니다. 어떤 블록에 변수 범위가 있는지 주의를 기울이지 않고 코드를 개발하고 발전시키면서 블록을 이리저리 옮기거나 다른 블록으로 래핑하는 습관이 있다면 혼란스러울 수 있습니다.
블록 범위 지정을 위한 명시적 블록을 생성하면 이러한 문제 중 일부를 해결할 수 있으므로 변수가 연결되고 연결되지 않은 위치가 더 명확해집니다. 일반적으로 명시적
코드는 암시적이거나 미묘한 코드보다 선호됩니다. 이 명시적 블록 범위 지정 스타일은 달성하기 쉽고 블록 범위 지정이 다른 언어에서 작동하는 방식에 더 자연스럽게 맞습니다.

```jsx
var foo = true;
if (foo) {
  {
    // <-- explicit block
    let bar = foo * 2;
    bar = something(bar);
    console.log(bar);
  }
}
console.log(bar); // ReferenceError
```

문장이 유효한 문법인 곳에 { .. } 쌍을 포함하기만 하면 let이 바인딩할 임의의 블록을 만들 수 있습니다. 이 경우 if 문 내부에 명시적 블록을 만들었습니다. 이 블록은 둘러싸는 if 문의 위치와 의미에 영향을 주지 않고 나중에 리팩토링할 때 전체 블록으로 더 쉽게 이동할 수 있습니다.

4장에서는 선언이 발생하는 전체 범위에 대해 존재하는 것으로 간주되는 선언에 대해 설명하는 호이스팅에 대해 설명합니다.
그러나 let으로 만든 선언은 해당 선언이 나타나는 블록의 전체 범위로 호이스트되지 않습니다. 이러한 선언은 선언 문까지 블록에 관찰 가능하게 "존재"하지 않습니다.

```jsx
{
  console.log(bar); // ReferenceError!
  let bar = 2;
}
```

---

## Garbage collection

블록 범위 지정이 유용한 또 다른 이유는 메모리 회수를 위한 클로저 및 가비지 수집과 관련이 있습니다. 여기서는 간략하게 설명하지만 클로저 메커니즘은 5장에서 자세히 설명합니다.

```jsx
function process(data) {
       // do something interesting
   }
   var someReallyBigData = { .. };

   process( someReallyBigData );

   var btn = document.getElementById( "my_button" );

   btn.addEventListener( "click", function click(evt){
       console.log("button clicked");
   }, /*capturingPhase=*/false );
```

클릭 함수 클릭 핸들러 콜백에는 someReallyBigData 변수가 전혀 필요하지 않습니다. 즉, 이론적으로 process(..)가 실행된 후 메모리를 많이 차지하는 데이터 구조가 가비지 수집될 수 있습니다. 그러나 클릭 기능이 전체 범위에 대해 클로저를 가지고 있기 때문에 JS 엔진이 여전히 구조를 유지해야 할 가능성이 매우 높습니다(구현에 따라 다름).
블록 범위 지정은 이 문제를 해결할 수 있으므로 엔진이 someReallyBigData를 유지할 필요가 없다는 것을 더 명확하게 알릴 수 있습니다.

```jsx
function process(data) {
       // do something interesting
}
   // anything declared inside this block can go away after!
   {
       let someReallyBigData = { .. };
       process( someReallyBigData );
   }
   var btn = document.getElementById( "my_button" );
      btn.addEventListener( "click", function click(evt){
       console.log("button clicked");
}, /*capturingPhase=*/false );
```

---

## let loops

let이 빛나는 특별한 경우는 이전에 논의한 for 루프의 경우입니다.

```jsx
for (let i = 0; i < 10; i++) {
  console.log(i);
}
console.log(i); // ReferenceError
```

for 루프 헤더의 let은 i를 for 루프 본문에 바인딩할 뿐만 아니라 실제로 루프의 각 반복에 다시 바인딩하여 이전 루프 반복의 끝에서 값을 다시 할당합니다.
다음은 발생하는 반복당 바인딩 동작을 설명하는 또 다른 방법입니다.

```jsx
{
  let j;
  for (j = 0; j < 10; j++) {
    let i = j; // re-bound for each iteration!
    console.log(i);
  }
}
```

이 반복당 바인딩이 흥미로운 이유는 클로저에 대해 논의할 때 5장에서 명확해질 것입니다.

let 선언은 둘러싸는 함수의 범위(또는 전역)가 아닌 임의의 블록에 연결되기 때문에 기존 코드가 함수 범위의 var 선언에 숨겨진 의존성을 갖고 var를 let으로 교체하는 경우 코드를 리팩토링할 때 추가 주의가 필요할 수 있습니다.

```jsx
var foo = true,
  baz = 10;
if (foo) {
  var bar = 3;
  if (baz > bar) {
    console.log(baz);
  }
  // ...
}
```

이 코드는 다음과 같이 상당히 쉽게 리팩토링됩니다.

```jsx
var foo = true,
  baz = 10;
if (foo) {
  var bar = 3;
  // ...
}
if (baz > bar) {
  console.log(baz);
}
```

그러나 블록 범위 변수를 사용할 때는 다음과 같은 변경 사항에 주의하십시오.

```jsx
var foo = true,
  baz = 10;
if (foo) {
  let bar = 3;
  if (baz > bar) {
    // <-- don't forget `bar` when moving!
    console.log(baz);
  }
}
```

---

## const

let 외에도 ES6은 블록 범위 변수를 생성하지만 값이 고정(상수)인 const를 도입했습니다. 나중에 해당 값을 변경하려고 하면 오류가 발생합니다.

```jsx
var foo = true;
if (foo) {
  var a = 2;
  const b = 3; // block-scoped to the containing `if`
  a = 3; // just fine!
  b = 4; // error!
}
console.log(a); // 3
console.log(b); // ReferenceError!
```

---

## Review

**함수는 JavaScript에서 가장 일반적인 범위 단위입니다.** 다른 함수 내에서 선언된 변수와 함수는 본질적으로 둘러싸는 범위에서 "숨겨져" 있습니다. 이는 좋은 소프트웨어의 의도적인 설계 원칙입니다.
그러나 **함수가 스코프의 유일한 단위는 아닙니다.** 블록 범위는 변수와 함수가 둘러싸는 함수에만 속하지 않고 코드의 임의 블록(일반적으로 { .. } 쌍)에 속할 수 있다는 아이디어를 나타냅니다.
ES3부터 try/catch 구조는 catch 절에 블록 범위를 갖습니다.
ES6에서는 임의의 코드 블록에서 변수 선언을 허용하기 위해 let 키워드(var 키워드의 사촌)가 도입되었습니다. if (..) { a = 2;
}는 본질적으로 if의 { .. } 블록의 범위를 가로채고 거기에 연결하는 변수 a를 선언합니다.
일부 사람들은 그렇게 믿는 것처럼 보이지만 블록 범위를 var 함수 범위를 완전히 대체해서는 안 됩니다. 두 기능이 공존하며
더 좋고 읽기 쉽고 유지 관리가 쉬운 코드를 생성하는 데 각각 적절한 경우 함수 scope 및 block scope를 모두 사용할 수 있고 사용해야 합니다.
