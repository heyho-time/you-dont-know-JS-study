---
title: Appendix
tags: [Dynamic Scope, Polyfilling block scope, Lexical this, Acknowledgements]
sidebar_position: 5
---

## 부록

---

### 1. Dynamic Scope

2장에서 우리는 lexical scope 모델과 대조되는 dynamic scope에 대해 이야기했습니다.

lexical scope 모델은 JavaScript(사실 대부분의 다른 언어)에서 작동하는 방식입니다.

그러나 더 중요한 것은 dynamic scope가 실제로 JavaScript의 다른 메커니즘(this)과 거의 사촌이라는 것입니다.

이 메커니즘은 You Don't Know JS 책 시리즈의 this & Object Prototypes에서 다룹니다.

2장에서 보았듯이 lexical scope는 엔진이 변수를 찾는 방법과 찾을 위치에 대한 규칙 집합입니다.

어휘 범위의 주요 특징은 작성자 시점, 즉 코드가 작성될 때 정의된다는 것입니다(eval() 또는 with로 속이지 않는다고 가정).

dynamic scope는 범위가 작성자 시점에 정적으로 결정되지 않고 런타임에 동적으로 결정될 수 있는 모델이 있음을 의미하는 것으로 보이며 타당한 이유가 있습니다.

코드를 통해 설명하겠습니다.

```jsx
function foo() {
  console.log(a); // 2
}

function bar() {
  var a = 3;
  foo();
}

var a = 2;
bar();
```

lexical sope는 a in foo()에 대한 RHS 참조가 전역 변수 a로 해석되어 값 2가 출력되도록 합니다.

대조적으로 dynamic scope는 방법과 위치에 관심이 없습니다.

함수와 범위는 선언되지만, 호출되는 위치입니다. 즉, scope chain은 코드의 범위 중첩이 아니라 **호출 스택을 기반**으로 합니다.
따라서 JavaScript에 dynamic scope가 있는 경우 foo()가 실행될 때 이론적으로 아래 코드는 3이 출력됩니다.

```jsx
function foo() {
  console.log(a); // 3  (not 2!)
}

function bar() {
  var a = 3;
  foo();
}

var a = 2;
bar();
```

중요한 차이는
lexical scope는 작성자 시점,
dynamic scope는 런타임 시점이란 것.

lexical scope는 함수가 선언된 위치를 처리하지만
dynamic scope는 함수가 호출된 위치를 처리합니다.

---

### 2. Polyfilling Block Scope

3장에서 우리는 block scope를 탐구했습니다. with와 catch 절은 둘 다 적어도 ES3가 도입된 이후로

JavaScript에 존재했던 작은 블록 범위의 예임을 보았습니다.

그러나 마침내 우리 코드에 완전하고 자유로운 블록 범위 지정 기능을 제공한 것은 ES6의 let 도입입니다.

기능적으로나 코드 스타일적으로나 블록 범위가 활성화할 수 있는 흥미로운 것들이 많이 있습니다.

하지만 ES6 이전 환경에서 블록 범위를 사용하려면 어떻게 해야 할까요? 다음 코드를 고려하십시오.

```jsx
{
  let a = 2;
  console.log(a); // 2
}

console.log(a); // ReferenceError
```

이것은 ES6 환경에서 잘 작동합니다.
이전에는 어땠을까요?

```jsx
try {
  throw 2;
} catch (a) {
  console.log(a); // 2
}
console.log(a); // ReferenceError
```

이상하네요..

강제로 오류를 던지는 것처럼 보이는 try/catch를 보았지만 그것이 던진 오류는 값 2일 뿐이고

그것을 수신하는 변수 선언 catch(a) 절에 있습니다.

맞습니다. catch 절에는 블록 범위 지정이 있으므로 ES6 이전 환경에서 블록 범위에 대한 폴리필로 사용할 수 있습니다.
"하지만", "아무도 그렇게 못생긴 코드를 작성하고 싶어하지 않습니다!" 사실입니다. 아무도 CoffeeScript 컴파일러의 코드 출력(일부)을 작성하지 않습니다.

요점은 도구가 ES6 코드를 변환하여 ES6 이전 환경에서 작동할 수 있다는 것입니다.

블록 범위 지정을 사용하여 코드를 작성하고 이러한 기능의 이점을 누릴 수 있으며 배포 시 실제로 작동하는 코드 생성을 빌드 단계 도구에서 처리하도록 할 수 있습니다.

이것은 실제로 ES6의 모든(대부분의)이 선호하는 마이그레이션 경로입니다. pre-ES6에서 ES6으로 전환하는 동안 코드 변환기를 사용하여 ES6 코드를 가져오고 ES5 호환 코드를 생성하는 것입니다.

### Traceur (총알)

Google은 Tracer[3]라는 프로젝트를 유지 관리합니다.

이 프로젝트는 일반 사용을 위해 ES6 기능을 ES6 이전(대부분 ES5이지만 전부는 아님)으로 변환하는 작업을 담당합니다.

TC39 위원회는 이 도구(및 기타 도구)를 사용하여 지정된 기능의 의미를 테스트합니다.

Tracer는 스니펫에서 무엇을 생성할지 봅시다.

```jsx
{
  try {
    throw undefined;
  } catch (a) {
    a = 2;
    console.log(a);
  }
}

console.log(a);
```

이러한 도구를 사용하면 ES6를 대상으로 하는지 여부에 관계없이 block scope를 활용할 수 있습니다.

try/catch는 es3부터 있었기 때문입니다.

---

### Implicit vs Explicit Blocks(암시적 블록 vs 명시적 블록)

3장에서 블록 범위 지정을 도입할 때 코드 유지 관리/리팩토링 가능성에 대한 몇 가지 잠재적인 함정을 식별했습니다.

블록 범위를 활용하는 것 외에 이 단점을 줄이는 다른 방법이 있습니까?

let 블록 또는 let 문이라고 하는 이 대체 형식의 let을 고려하십시오(이전의 let 선언과 대조됨).

```jsx
let (a = 2) {
       console.log( a ); // 2
   }

   console.log( a ); // ReferenceError
```

기존 블록을 암시적으로 가로채는 대신 let 문은 범위 바인딩에 대한 명시적 블록을 만듭니다.

명시적 블록이 더 눈에 띄고 코드 리팩토링에서 더 강력할 뿐만 아니라 문법적으로 모든 선언을 블록의 맨 위로 강제로 적용하여 다소 깨끗한 코드를 생성합니다.

이렇게 하면 모든 블록을 보다 쉽게 ​​보고 범위가 무엇인지 알 수 있습니다.

패턴으로 모든 var 선언을 함수의 맨 위로 수동으로 이동/호이스트할 때 많은 사람들이 함수 범위 지정에서 취하는 접근 방식을 반영합니다.

let 문은 의도에 따라 블록의 맨 위에 배치하고, 전체에 let 선언을 사용하지 않으면 블록 범위 선언을 식별하고 유지 관리하기가 다소 쉽습니다.

하지만 문제가 있습니다. let 문 형식은 ES6에 포함되어 있지 않습니다. 공식 Tracer 컴파일러도 해당 형식의 코드를 허용하지 않습니다.

두 가지 옵션이 있습니다. ES6 유효한 구문과 약간의 코드 규율을 사용하여 형식을 지정할 수 있습니다.

```jsx
/*let*/ {
  let a = 2;
  console.log(a);
}

console.log(a); // ReferenceError
```

그러나 도구는 우리의 문제를 해결하기 위한 것입니다.

따라서 다른 옵션은 명시적 let 문 블록을 작성하고 도구가 이를 유효한 작동 코드로 변환하도록 하는 것입니다.

그래서 이 문제를 해결하기 위해 let-er[4]라는 도구를 만들었습니다.

let-er는 빌드 단계 코드 변환기이지만, 유일한 작업은 let 문 형식을 찾고 변환하는 것입니다.

let 선언을 포함하여 나머지 코드는 그대로 둡니다. let-er를 첫 번째 ES6 트랜스파일러 단계로 안전하게 사용할 수 있으며

필요한 경우 Tracer와 같은 것을 통해 코드를 전달할 수 있습니다.

게다가, let-er에는 설정될 때(기본적으로 꺼져 있음) 생성된 코드 종류가 변경되는 구성 플래그 --es6이 있습니다.

try/catch ES3 대신 polyfill 해킹, let-er는 우리의 스니펫을 가져와 ES6과 완전히 호환되는 키를 생성합니다.

따라서 let-er를 바로 사용하기 시작하여 모든 pre-ES6 환경을 대상으로 할 수 있으며 ES6만 관심이 있을 때 플래그를 추가하고 즉시 ES6만 대상으로 할 수 있습니다.

그리고 가장 중요한 것은 (아직) ES 버전의 공식 부분이 아니더라도 더 바람직하고 명시적인 let 문 형식을 사용할 수 있다는 것입니다.

### Performance

마지막으로 try/catch의 성능에 대한 간단한 메모를 추가하거나 "범위를 생성하기 위해 IIFE를 사용하지 않는 이유는 무엇입니까?"라는 질문에 답하겠습니다.

**첫째,** try/catch의 성능은 더 느리지만 그렇게 되어야만 하거나 항상 그렇게 될 것이라는 합리적인 가정이 없습니다.

공식 TC39 승인 ES6 트랜스파일러가 try/catch를 사용하기 때문에 Tracer 팀은 Chrome에 try/catch의 성능을 개선하도록 요청했으며 분명히 그렇게 하려는 동기가 있습니다.

**둘째,** IIFE는 try/catch와의 공정한 비교가 아닙니다.

임의의 코드를 감싸는 함수가 해당 코드 내부에서 반환, 중단 및 계속의 의미를 변경하기 때문입니다.

IIFE는 일반적으로 적합하지 않습니다. 특정 경우에만 수동으로 사용할 수 있습니다.

문제는 실제로 다음과 같습니다. 블록 범위 지정을 원하는지 여부. 그렇게 하면 이러한 도구가 해당 옵션을 제공합니다.

그렇지 않은 경우 var를 계속 사용하고 코딩을 계속하십시오!

---

### 3. Lexical this

이 메커니즘을 자세히 다루지 않지만, 이를 lexical scope와 중요한 방식으로 연관시키는 ES6 주제가 하나 있습니다.

ES6은 **화살표 함수**라고 하는 특별한 구문 형식의 함수 선언을 추가합니다. 다음과 같이 보입니다.

```jsx
var foo = (a) => {
  console.log(a);
};

foo(2); // 2
```

소위 "뚱뚱한 화살"은 지루할 정도로 장황한(비꼬는) 기능 키워드의 약어로 자주 언급됩니다.

그러나 선언에 키 입력을 저장하는 것과 관련이 없는 화살표 함수에는 훨씬 더 중요한 일이 있습니다.

간단히 말해서 이 코드는 다음과 같은 문제가 있습니다.

```jsx
var obj = {
  id: "awesome",
  cool: function coolFn() {
    console.log(this.id);
  },
};

var id = "not awesome";

obj.cool(); // awesome

setTimeout(obj.cool, 100); // not awesome
```

문제는 cool() 함수에서 이 바인딩이 손실된다는 것입니다.

이 문제를 해결하는 다양한 방법이 있지만 자주 반복되는 솔루션 중 하나는 `var self = this` 입니다.

```jsx
var obj = {
  count: 0,
  cool: function coolFn() {
    var self = this;

    if (self.count < 1) {
      setTimeout(function timer() {
        self.count++;
        console.log("awesome?");
      }, 100);
    }
  },
};
obj.cool(); // awesome?
```

`var self = this "solution"`은 이 바인딩을 이해하고 적절하게 사용하는 전체 문제를 끝내고 대신 우리가 더 편할 수 있는 어휘 범위로 되돌아갑니다.

self는 어휘 범위와 클로저를 통해 해결될 수 있는 식별자가 되며, 그 과정에서 이 바인딩에 무슨 일이 일어났는지 신경 쓰지 않습니다.

사람들은 장황한 글을 쓰는 것을 좋아하지 않습니다. 특히 반복해서 하는 경우에는 더욱 그렇습니다.

따라서 ES6의 동기는 이러한 시나리오를 완화하고 실제로 이와 같은 일반적인 관용구 문제를 수정하는 것입니다.

화살표 함수인 ES6 솔루션은 어휘 this라는 동작을 도입합니다.

```jsx
var obj = {
  count: 0,
  cool: function coolFn() {
    if (this.count < 1) {
      setTimeout(() => {
        // arrow-function ftw?
        this.count++;
        console.log("awesome?");
      }, 100);
    }
  },
};

obj.cool(); // awesome?
```

간단한 설명은 화살표 함수가 이 바인딩과 관련하여 일반 함수처럼 전혀 동작하지 않는다는 것입니다.

그들은 모든 정상적인 규칙을 버립니다.

이 바인딩에 대해 대신 즉각적인 어휘 둘러싸기 범위의 this 값을 가져옵니다.

따라서 해당 스니펫에서 화살표 함수는 예측할 수 없는 방식으로 this 바인딩을 해제하지 않고 cool() 함수의 this 바인딩을 "상속"합니다(표시된 대로 호출하면 정확합니다!).

이렇게 하면 코드가 더 짧아지지만 내 관점은 화살표 함수가 실제로는 이 바인딩 규칙을 어휘 범위 규칙과 혼동하고 혼동하는 개발자의 일반적인 실수인 언어 구문으로 코드화하고 있다는 것입니다.

다시 말해서, 왜 이 스타일 코딩 패러다임을 사용하는 데 어려움과 장황함을 느끼며 어휘 참조와 혼합하여 무릎을 꿇어야만 합니까? 주어진 코드 조각에 대해 하나의 접근 방식 또는 다른 접근 방식을 수용하고 동일한 코드 조각에서 혼합하지 않는 것이 자연스러운 것처럼 보입니다.

### Note

화살표 함수의 또 다른 단점은 **이름이 지정되지 않고 익명**이라는 것입니다.

익명 함수가 명명된 함수보다 덜 바람직한 이유는 3장을 참조하십시오.

<br />
<br />

내 관점에서 이 "문제"에 대한 보다 적절한 접근 방식은 이 메커니즘을 올바르게 사용하고 수용하는 것입니다.

```jsx
var obj = {
  count: 0,
  cool: function coolFn() {
    if (this.count < 1) {
      setTimeout(
        function timer() {
          this.count++; // `this` is safe
          // because of `bind(..)`
          console.log("more awesome");
        }.bind(this),
        100
      ); // look, `bind()`!
    }
  },
};
obj.cool(); // more awesome
```

화살표 함수의 새로운 어휘 이 동작을 선호하든, 검증된 bind()를 선호하든,

화살표 함수는 단순히 함수를 덜 입력하는 것이 아니라는 점에 유의하는 것이 중요합니다.

그것들은 우리가 배우고 이해해야 하는 의도적인 행동 차이를 가지고 있으며,

우리가 선택한다면 활용해야 합니다.

이제 어휘 범위 지정(및 클로저!)을 완전히 이해했으므로 어휘를 이해하는 것은 아주 쉬울 것 입니다!
