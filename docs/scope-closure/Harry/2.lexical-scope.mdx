---
slug: /up-going/harry/lexical-scope
title: 2. Lexical Scope
tags: [lexical-scope, eval, with]
sidebar_position: 2
---

1장에서, scope는 엔진이 변수를 조회하고 현재 범위 또는 포함된 중첩 범위에서 찾는 방법을 제어하는 규칙 집합으로 정의했습니다.

범위 작동 방식에는 두 가지 주요 모델이 있습니다.

이들 중 첫 번째는 대부분의 프로그래밍 언어에서 사용되는 단연코 가장 일반적입니다. 이를 **어휘 범위(lexical scope)**라고 하며 자세히 살펴보겠습니다.

일부 언어(예: Bash 스크립팅, Perl의 일부 모드 등)에서 여전히 사용되는 다른 모델을 **동적 범위(dynamic scope)**라고 합니다.

동적 범위는 부록 A에서 다룹니다. 여기서는 JavaScript가 사용하는 범위 모델인 어휘 범위와의 대조를 제공하기 위해 여기에만 언급합니다.

## Lex-time

1장에서 논의한 것처럼 일반적인 컴파일러의 첫 번째 전통적인 단계는 **렉싱(일명 토큰화)**이라고 합니다.

렉싱 프로세스는 소스 코드 문자의 문자열을 검사하고 일부 상태 기반 구문 분석의 결과로 토큰에 의미론적 의미를 할당합니다.

어휘 범위가 무엇이며 이름이 어디에서 왔는지 이해하는 기초를 제공하는 것은 이 개념입니다.

다소 정의하자면 어휘 범위는 렉싱 시 정의되는 범위입니다.

다시 말해서, 어휘 범위는 범위의 변수와 블록이 작성된 위치를 기반으로 하므로 렉서가 코드를 처리할 때 (대부분) 고정됩니다.

### note

> 우리는 어휘 범위를 속이는 몇 가지 방법이 있음을 조금 후에 알게 될 것입니다. <br />그리하여 어휘 분석기(lexer)가 지나간 후에 그것을 수정하지만 이것들은 눈살을 찌푸리게 합니다. 어휘 범위를 사실상 어휘 전용으로 취급하여 본질적으로 전적으로 작성자 시간으로 처리하는 것이 모범 사례로 간주됩니다.

```jsx
function foo(a) {
  var b = a * 2;
  function bar(c) {
    console.log(a, b, c);
  }

  bar(b * 3);
}
foo(2); // 2, 4, 12
```

3가지 중첩 범위가 있습니다.

<img src="/img/harry/scope.png" alt="scope" style={{ width: "80%" }} />

- 버블 1은 **전역 스코프를 포함**하며 그 안에 **`foo` 라는 하나의 식별자만 있습니다.**

- 버블 2는 `a`, `bar` 및 `b` 의 **세 가지 식별자를 포함하는 `foo` 의 범위를 포함합니다.**

- 버블 3은 `bar` 의 스코프를 포함하여 **하나의 식별자만 포함합니다.**

스코프 버블은 스코프 블록이 쓰여진 위치, 다른 블럭 안에 중첩된 스코프 등으로 정의됩니다.

**bar에 대한 거품은 foo에 대한 거품 내에 완전히 포함되어 있습니다.**

## Look-ups

이러한 스코프 버블의 구조와 상대적 배치는 엔진이 식별자를 찾기 위해 찾아야 하는 모든 위치를 완전히 설명합니다.

이전 코드에서 엔진은 console.log(..) 문을 실행하고 세 개의 참조 변수 a, b, c를 찾습니다.

먼저 가장 안쪽의 스코프 버블인 bar(..) 함수의 스코프부터 시작합니다. 거기에서 찾을 수 없으므로 한 수준 위로 올라가서 다음으로 가장 가까운 범위 버블인 foo(..) 범위로 이동합니다. 그것은 거기에서 찾고 그래서 그것을 사용합니다. b도 마찬가지입니다.

**c는 bar(..) 내부를 찾습니다.**

bar(..) 내부와 foo(..) 내부 모두에 c가 있었다면 console.log(..) 문은 bar(..)에 있는 것을 찾아 사용했을 것입니다.

<br />

조회는 첫 번째 일치 항목을 찾으면 중지됩니다.

중첩된 범위의 여러 레이어에 동일한 식별자 이름을 지정할 수 있습니다. 이를 "shadowing"(내부 식별자는 외부 식별자를 "shadowing")이라고 합니다. 섀도잉에 관계없이 범위 조회는 항상 해당 시간에 실행되는 가장 안쪽 범위에서 시작하여 첫 번째 일치까지 바깥쪽/위쪽 방향으로 작동하고 중지됩니다.

> 전역 변수는 자동으로 전역 객체(브라우저 창 등)의 속성이기도 하므로 정적 이름으로 직접 전역 변수를 참조하는 것이 아니라 전역 객체의 프로퍼티 참조로 간접적으로 전역 변수를 참조할 수 있습니다. <br /><br /> `window.a` <br /><br /> 이 기술은 접근할 수 없는 전역 변수에 대한 액세스를 제공합니다.

함수가 어디에서 호출되는지 또는 호출 방법에 관계없이 해당 함수의 어휘 범위는 함수가 선언된 위치에 의해서만 정의됩니다.

어휘 범위 조회 프로세스는 a, b 및 c와 같은 1급 식별자에만 적용됩니다. 코드 조각에 foo.bar.baz에 대한 참조가 있는 경우 foo 식별자를 찾는 데 어휘 범위 조회가 적용되지만 해당 변수를 찾으면 객체 속성 액세스 규칙이 인계받아 bar 및 baz 프로퍼티를 해결합니다.

## Cheating Lexical

어휘 범위가 함수의 선언 위치에 의해서만 정의되고 이는 전적으로 작성자 시점의 결정이라면 런타임에 어휘 범위를 "수정"(일명 속임수)하는 방법이 있을 수 있을까요?

JavaScript에는 두 가지 메커니즘이 있습니다.

둘 다 더 넓은 커뮤니티에서 코드에서 사용하는 나쁜 습관으로 똑같이 눈살을 찌푸리게 합니다.

그러나 그들에 대한 일반적인 주장은 종종 가장 중요한 점을 놓치고 있습니다. 어휘 범위를 속이면 성능이 저하됩니다.

성능 문제를 설명하기 전에 이 두 메커니즘이 어떻게 작동하는지 살펴보겠습니다.

## eval

JavaScript의 **eval(..) 함수**는 문자열을 인수로 사용하고 문자열의 내용을 프로그램의 해당 지점에서 실제로 작성된 코드인 것처럼 처리합니다. 즉, 저작된 코드 내부에 프로그래밍 방식으로 코드를 생성하고 생성된 코드가 저작 시점에 있었던 것처럼 실행할 수 있습니다.

**eval(..)**이 실행된 후 코드의 후속 라인에서 엔진은 문제의 이전 코드가 동적으로 해석되어 어휘 범위 환경을 수정했음을 "알지" 또는 "관리"하지 않습니다. 엔진은 항상 그렇듯이 어휘 범위 조회를 수행합니다.

```jsx
function foo(str, a) {
  eval(str); // cheating!
  console.log(a, b);
}
var b = 2;
foo("var b = 3;", 1); // 1, 3
```

문자열 `"var b = 3;"`은 eval(..) 호출 시점에 항상 있었던 코드로 처리됩니다. 그 코드는 새로운 변수 b를 선언하기 때문에 foo(..)의 기존 어휘 범위를 수정합니다. 사실, 앞서 언급했듯이 이 코드는 실제로 외부(전역) 범위에서 선언된 b를 은폐하는 변수 b를 foo(..) 내부에 생성합니다.
console.log(..) 호출이 발생하면 foo(..) 범위에서 b와 b를 모두 찾고 외부 b는 찾지 않습니다. 따라서 일반적으로 "1, 2" 대신 "1, 3"을 인쇄합니다.

### note

이 예에서 우리가 전달하는 코드 문자열은 고정된 리터럴이었습니다.

그러나 프로그램 논리에 따라 문자를 함께 추가하여 프로그래밍 방식으로 쉽게 만들 수 있습니다. **eval(..)**은 일반적으로 동적으로 생성된 코드를 실행하는 데 사용됩니다. 문자열 리터럴에서 본질적으로 정적 코드를 동적으로 평가하는 것은 코드를 직접 작성하는 것만으로는 실질적인 이점을 제공하지 않기 때문입니다. <br />

\*\*기본적으로 eval(..)이 실행하는 코드 문자열이 하나 이상 포함되어 있으면

선언(변수 또는 함수)에서 이 작업은 eval(..)이 있는 기존 어휘 범위를 수정합니다.\*\* 기술적으로 eval(..)은
다양한 트릭을 통해 간접적으로 호출됩니다(여기에서 논의하지 않음). 이로 인해 전역 범위의 컨텍스트에서 대신 실행되어 수정됩니다. 그러나 두 경우 모두 eval(..)은 런타임에 작성자 시간 어휘 범위를 수정할 수 있습니다.

```jsx
function foo(str) {
  "use strict";
  eval(str);
  console.log(a); // ReferenceError: a is not defined
}
foo("var a = 2");
```

**엄격 모드** 프로그램에서 사용될 때 eval(..)은 자체 어휘 범위에서 작동합니다. 즉, eval() 내부에서 이루어진 선언은 실제로 둘러싸는 범위를 수정하지 않습니다.

eval(..)과 매우 유사한 효과에 해당하는 JavaScript의 다른 기능이 있습니다. **setTimeout(..) 및 setInterval(..)**은 각각의 첫 번째 인수에 대해 문자열을 사용할 수 있으며, 그 내용은 동적으로 생성된 함수의 코드로 평가됩니다. 이것은 오래된 레거시 동작이며 오랫동안 사용되지 않습니다.

새로운 Function(..) 함수 생성자는 유사하게 마지막 인수에서 코드 문자열을 사용하여 동적으로 생성된 함수로 변환합니다(첫 번째 인수가 있는 경우 새 함수의 명명된 매개변수임). 이 함수 생성자 구문은 eval(..)보다 약간 더 안전하지만 코드에서는 여전히 피해야 합니다.

성능 저하가 있고 기능 가치가 거의 없기 때문에 프로그램 내부에서 동적으로 코드를 생성하는 사용 사례는 매우 드뭅니다.

## with

속임수를 쓰는 JavaScript의 또다른 lexical scope는 with 키워드 입니다.

유효한 방법은 여러 가지가 있지만 여기서는 어휘 범위와 상호 작용하고 어휘 범위에 영향을 미치는 관점에서 설명하겠습니다.

with는 일반적으로 매번 개체 참조 자체를 반복하지 않고 개체에 대해 여러 속성 참조를 만들기 위한 약어로 설명됩니다.

```jsx
var obj = {
  a: 1,
  b: 2,
  c: 3,
};
// more "tedious" to repeat "obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;
// "easier" shorthand
with (obj) {
  a = 3;
  b = 4;
  c = 5;
}

그러나 여기에는 객체 속성 액세스를 위한 편리한 약칭보다 훨씬 더 많은 일이 있습니다.
```

```jsx
function foo(obj) {
  with (obj) {
    a = 2;
  }
}
var o1 = { a: 3 };
var o2 = { b: 3 };

foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); // undefined
console.log(a); // 2—Oops, leaked global!
```

o1을 전달할 때 a = 2 할당은 o1.a 속성을 찾고 후속 console.log(o1.a) 문에 반영된 대로 값 2를 할당합니다.

그러나 o2를 전달할 때 속성이 없기 때문에 그러한 속성이 생성되지 않으며 o2.는 정의되지 않은 상태로 유지됩니다.

여기서 주목할 점은, a = 2 할당에 의해 전역 변수가 생성되었다는 것입니다.

with 문은 0개 이상의 속성이 있는 객체를 취하고 해당 객체를 완전히 별개의 어휘 범위인 것처럼 취급하므로 객체의 속성은 해당 범위에서 어휘적으로 정의된 식별자로 처리됩니다.

### note

with 블록이 객체를 어휘 범위처럼 취급하더라도 with 블록 내부의 일반적인 var 선언은 with 블록이 아니라 포함하는 함수 범위로 범위가 지정됩니다.

---

<br />

eval(..) 함수는 하나 이상의 선언이 포함된 코드 문자열을 사용하는 경우 기존 어휘 범위를 수정할 수 있지만 with 문은 실제로 전달한 객체에서 완전히 새로운 어휘 범위를 생성합니다.

**eval(..) 및 with 모두 사용하는 것이 좋지 않을 뿐만 아니라 Strict Mode의 영향을 받습니다(제한됨).**

## Performance

**eval(..) 및 with 치트** 모두 런타임 시 새로운 어휘 범위를 수정하거나 생성하여 작성자 시간에 정의된 어휘 범위를 정의합니다.

문제가 있을까요? 더 정교한 기능과 코딩 유연성을 제공한다면 좋은 기능이 아닐까요? 아닙니다.

**JavaScript 엔진에는 컴파일 단계에서 수행하는 여러 성능 최적화가 있습니다.** 이들 중 일부는 렉싱할 때 코드를 본질적으로 정적으로 분석하고 모든 변수 및 함수 선언이 있는 위치를 미리 결정할 수 있어 실행 중 식별자를 확인하는 데 드는 노력을 줄일 수 있습니다.
그러나 엔진이 코드에서 **eval(..) 또는 with**를 찾으면 **본질적으로 식별자 위치에 대한 모든 인식이 유효하지 않을 수 있다고 가정해야 합니다.** 어휘 범위를 수정하거나 참조할 새 어휘 범위를 만들기 위해 전달할 개체의 내용을 수정합니다.
다시 말해, 비관적인 의미에서 eval(..) 또는 with가 있는 경우 **수행하는 최적화의 대부분은 무의미**하므로 단순히 수행하지 않습니다.

## Review

**어휘 범위는 범위가 함수가 선언된 위치에 대한 작성자 시간 결정에 의해 정의됨을 의미합니다.** 컴파일의 렉싱 단계는 기본적으로 모든 식별자가 선언된 위치와 방법을 알 수 있으므로 실행 중에 검색되는 방법을 예측할 수 있습니다.
JavaScript의 두 가지 메커니즘은 어휘 범위를 "속일 수" 있습니다: **eval(..) 및 with.** 전자는 하나 이상의 선언이 있는 "코드" 문자열을 평가하여 런타임에 기존 어휘 범위를 수정할 수 있습니다. 후자는 본질적으로 **객체 참조를 범위로 처리하고 해당 객체의 속성을 범위가 지정된 식별자로 처리하여 완전히 새로운 어휘 범위(런타임에)를 만듭니다.**
이러한 메커니즘의 **단점은 엔진이 이러한 최적화가 유효하지 않을 것이라고 비관적으로 가정해야 하기 때문에 범위 조회와 관련하여 컴파일 시간 최적화를 수행하는 엔진의 능력을 무력화**한다는 것입니다. 두 기능 중 하나를 사용하면 코드가 느리게 실행됩니다. 사용하지 마십시오.
