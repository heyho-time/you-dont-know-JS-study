---
title: Chapter 3. Function Versus Block Scope
tags: [function, block, scope]
sidebar_position: 3
---

<br/>

## 들어가며 🏃

---

2장에서 살펴본 바와 같이 **스코프는 각각의 컨테이너(혹은 버킷) 역할을 하는 일련의 버블로 구성**되며, 여기서 **식별자(변수나 함수)가 선언**됩니다. 그리고 해당 버블들은 **서로 중첩**되며 **코드 작성 시점에 정의**됩니다.

- 그렇다면 버블을 만드는 것은 단지 **함수뿐인가?** 다른 구조가 스코프 버블을 만들 수 있을까?

<br/>

## Scope From Functions ❕

---

> **TL;DR 🔖**
>
> - 선언된 함수는 **자체적인 스코프 버블을 생성**하며, **스코프에선 선언의 순서는 중요하지 않습니다.**

<br />

이러한 질문에 대한 가장 일반적인 대답은 **자바스크립트에 함수 기반 스코프가 있다는 것**입니다.

- 즉, **선언한 함수는 자체적으로 버블을 생성**하지만 다른 구조는 자체 스코프 버블을 생성하지 않습니다.
  - 잠시 후 살펴보겠지만 이것은 사실이 아닙니다.
- 하지만, 먼저 **함수 스코프와 그 의미**를 살펴보겠습니다.

```js
function foo(a) {
  var b = 2;
  // some code
  function bar() {
    // ...
  }
  // more code
  var c = 3;
}
```

이 스니펫에서 `foo()` 의 스코프 버블에는 식별자 `a`, `b`, `c` 및 `bar` 가 포함됩니다.

- 스코프에서 **선언의 위치는 중요하지 않습니다.**
- 변수 또는 함수는 **관계없이 포함하는 스코프 버블**에 속합니다.

> 다음 장에서 이것이 정확히 어떻게 작동하는지 알아볼 것입니다.

- `bar()` 에는 **자체 스코프 버블**이 있습니다.
  - `foo` 라는 하나의 식별자만 연결된 **전역 스코프**도 마찬가지입니다.
- `b`, `c` 및 `bar` 는 모두 `foo()` 의 스코프 버블에 속하므로 `foo()` 외부에서 접근할 수 없습니다.
  - 즉, **전역 스코프에서 식별자를 사용할 수 없기 때문에**, 다음 코드에서는 모두 **`ReferenceError` 오류를 발생**시킵니다.

```js
bar(); // fails
console.log(a, b, c); // all 3 fail
```

그러나 이러한 **모든 식별자(`a`, `b`, `c`, `foo` 및 `bar`)는 `foo()` 내부에서 접근할 수 있으며,** 실제로 **`bar()` 내부에서도 사용할 수 있습니다(`bar()` 내부에 섀도잉 선언이 없다고 가정).**

- 함수 스코프는 **모든 변수가 함수에 속하고 함수 전체에서 사용 및 재사용될 수 있다는 아이디어를 장려**합니다.
  - 실제로는 **중첩 스코프에서도 접근이 가능**합니다.
- 이 디자인 접근 방식은 매우 유용할 수 있으며, 필요에 따라 **다양한 타입의 값을 취하기 위해 자바스크립트 변수의 동적 특성을 최대한 활용할 수 있습니다.**
- 반면에 주의를 기울이지 않으면, **스코프 전체에 존재하는 변수**로 인해 예상치 못한 오류가 발생할 수 있습니다.

<br/>

## Hiding in Plain Scope ❕

---

> **TL;DR 🔖**
>
> - 함수 선언 내 **특정 코드 섹션을 래핑**하면 코드를 **숨길 수 있습니다.**
> - 코드를 숨기게 되면 **최소 권한의 원칙**에 따라 **필요한 사항만 노출**할 수 있고, **비공개 세부 정보를 내부에 숨길 수 있으며, 용도가 다른 두 가지 동명의 식별자 간의 충돌을 방지**할 수 있습니다.
> - 프로그램에 로드된 여러 라이브러리는 **내부 함수와 변수**를 제대로 숨기지 않으면 서로 충돌하기 쉬우며, 이를 위해 **모듈 관리** 방식을 사용하기도 합니다.

<br />

함수에 대한 전통적인 사고 방식은 **함수를 선언한 다음 그 안에 코드를 추가하는 것**입니다.

- 그러나 이에 대한 역발상은 똑같이 강력하고 유용합니다.
- 작성한 코드의 **임의의 섹션을 가져와 그 주위에 함수 선언을 래핑하면 실제로 코드를 숨깁니다.**
- 이에 대한 실제 결과는 **해당 코드 주위에 스코프 버블을 만드는 것**입니다.
  - 즉, **해당 코드의 모든 선언(변수 또는 함수)**은 이제 **이전이 아닌 새 래핑 함수의 스코프에 연결**됩니다.
    - 변수와 함수를 **함수 스코프에 넣어 숨길 수 있습니다.**

변수와 함수를 숨기는 것이 유용한 기술인 이유는 무엇일까요?

- 그들은 **최소 권한(Least Authority)** 또는 **최소 노출(Least Exposure)**이라고도 하는 **최소 권한(Least Privilege)의 소프트웨어 설계 원칙에서 발생하는 경향**이 있습니다.

> [**최소 권한의 원칙(The principle of least privilege)**](https://www.ibm.com/docs/en/aix/7.2?topic=software-least-privilege)은 소프트웨어 모듈이 **의도한 작업을 수행하는데 필요한 최소한의 기능을 제공해야 한다는 것**입니다.
>
> 해당 도서에서는 모듈/객체용 API와 같은 소프트웨어 설계에서 **최소한으로 필요한 것만 노출하고 나머지는 숨겨야한다고 명시하는 것**이라고 합니다.

이 원칙은 변수와 함수를 포함할 스코프의 선택으로 확장됩니다.

- 모든 변수와 함수가 **전역 스코프에 있으면 모든 중첩 범위에서 접근할 수 있습니다.**
  - 그러나 이것은 코드를 적절하게 사용하면 해당 변수/함수에 대한 접근을 방해하므로 **비공개로 유지해야 하는 많은 변수 또는 함수를 노출한다는 점에서 최소 권한 원칙에 위배**됩니다.

```js
function doSomething(a) {
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}

function doSomethingElse(a) {
  return a - 1;
}

var b;

doSomething(2); // 15
```

해당 스니펫에서 `b` 변수와 `doSomethingElse()` 함수는 `doSomething()` 이 작업을 수행하는 방법에 대한 **비공개 세부 정보**일 수 있습니다.

- 둘러싸는 스코프에 `b` 및 `doSomethingElse()` 에 대한 접근 권한을 부여하는 것은 불필요할 뿐만 아니라 의도적이든 아니든 예상치 못한 방식으로 사용될 수 있고, `doSomething` 의 전제 조건 가정을 위반할 수 있다는 점에서 위험할 수 있습니다.
- 보다 적절한 디자인은 다음과 같이 **doSomething()` 스코프 내에서 이러한 개인 세부 정보를 숨깁니다.**

```js
function doSomething(a) {
  function doSomethingElse(a) {
    return a - 1;
  }
  var b;

  b = a + doSomethingElse(a * 2);

  console.log(b * 3);
}

doSomething(2); // 15
```

이제 `b` 와 `doSomethingElse()` 는 외부 영향력에 의해 접근할 수 없으며, 대신에 **`doSomething()` 에 의해서만 제어**됩니다.

- 함수 및 최종 결과에 영향을 받지 않았지만, 디자인은 일반적으로 더 나은 소프트웨어로 간주되는 **개인 정보를 비공개로 유지합니다.**

<br/>

### Collision Avoidance ❓

---

스코프 내에서 변수와 함수를 숨기는 것의 또 다른 장점은 **용도가 다른 두 개의 같은 식별자 간의 의도하지 않은 충돌을 방지하는 것**입니다.

- 충돌로 인해 **예상치 못한 값 덮어쓰기가 발생하는 경우**가 많기 때문입니다.

```js
function foo() {
  function bar(a) {
    i = 3; // changing the `i` in the enclosing scope's
    // for-loop
    console.log(a + i);
  }

  for (var i = 0; i < 10; i++) {
    bar(i * 2); // oops, inifinite loop ahead!
  }
}

foo();
```

`bar()` 내부의 `i = 3` 할당은 예기치 않게 **`for` 루프에서 `foo()` 에 선언된 `i` 를 덮어씁니다.**

- 이 경우가 `i` 가 고정 값 `3` 으로 설정되고 영원히 `< 10` 으로 유지되기 때문에 **무한 루프가 발생합니다.**

`bar()` 내부의 할당은 **선택된 식별자 이름에 관계없이 사용할 지역 변수를 선언해야 합니다.**

- 변수 `i = 3;` 문제를 해결하고 **`i` 에 대해 앞에서 언급한 섀도잉 변수 선언을 생성**합니다.

추가 옵션은 `var j = 3;` 과 같이 **완전히 다른 식별자 이름을 선택하는 것**입니다.

- 그러나 소프트웨어 디자인은 자연스럽게 동일한 식별자 이름을 요구할 수 있으므로, **스코프를 활용하여 내부 선언을 숨기는 것이 이 경우엔 최선의 옵션**입니다.

<br/>

#### Global namespaces

---

변수 충돌의 대부분의 경우는 **전역 스코프**에서 발생합니다.

- 프로그램에 로드된 여러 라이브러리는 **내부 함수와 변수**를 제대로 숨기지 않으면 서로 충돌하기 쉽습니다.

이러한 라이브러리는 일반적으로 전역 스코프에서 충분히 **고유한 이름을 가진 단일 변수 선언(종종 객체)을 만듭니다.**

- 그런 다음 해당 객체는 **라이브러리의 네임스페이스**로 사용되며, 여기서 함수의 모든 특정 노출은 최상위 정적 스코프 식별자 자체가 아니라, **해당 객체(네임스페이스)의 속성으로 만들어집니다.**

```js
var MyReallyCoolLibrary = {
  awesome: "stuff",
  doSomething: function () {
    // ...
  },
  doAnotherThing: function () {
    // ...
  },
};
```

<br/>

#### Module management

---

충돌 방지를 위한 또 다른 옵션은 **다양한 의존성 관리자를 사용하는 보다 현대적인 모듈 접근 방식**입니다.

- 이러한 도구를 사용하면 어떤 라이브러리도 전역 범위에 식별자를 추가하지 않지만, 대신에 의존성 관리자의 다양한 매커니즘을 사용하여 **식별자를 명시적으로 다른 스코프로 가져와야 합니다.**
- 이러한 도구에는 정적 스코프 규칙에서 면제되는 **마법 기능이 없습니다.** 그들은 여기에 설명된 스코프 지정 규칙을 사용하여 **식별자가 공유 스코프에 편입되지 않도록 하고,** 대신에 충돌에 취약하지 않은 **비공개 범위에 보관**하여 우발적인 스코프 충돌을 방지합니다.

따라서 이를 선택하면 실제로 이를 사용할 필요 없이 **수동적으로 코딩하고 의존성 관리자와 동일한 결과를 얻을 수 있습니다.**

모듈 패턴의 자세한 내용은 5장을 참조하세요.

<br/>

## Functions as Scopes ❕

---

> **TL;DR 🔖**
>
> - 함수 스코프 내에 선언을 숨기는 것이 반드시 이상적인 것은 아니며, 이는 **둘러싸는 스코프를 오염**시킬 수 있습니다.
> - 이를 IIFE 방식으로 **함수를 즉시 실행**시켜 방지할 수 있습니다. IIFE의 가장 일반적인 형태는 **익명 함수 표현식**이지만 이점을 위해 **명명 함수 표현식**을 채택함이 좋습니다.

<br />

우리는 앞에서 **코드 조각을 함수로 감쌀 수 있고, 함수 내부 스코프 내에 변수 또는 함수 선언을 숨길 수 있다는 것**을 알았습니다.

```js
var a = 2;
function foo() {
  // <-- insert this
  var a = 3;
  console.log(a); // 3
} // <-- and this

foo(); // <-- and this

console.log(a); // 2
```

이 기술은 효과적이지만 **반드시 이상적인 것은 아닙니다.** 소개할 몇 가지 문제가 있습니다.

- 명명된 함수 `foo()` 를 선언해야 합니다.
  - 즉, 식별자 명 `foo` 자체가 **둘러싸는 스코프(해당 경우 전역)를 오염시킵니다.**
- 래핑된 코드가 실제로 실행되도록 **이름(`foo()`)으로 함수를 호출해야 합니다.**

**함수에 이름이 필요없는 경우(또는 이름이 둘러싸는 스코프를 오염시키지 않는 경우)이거나 함수가 자동으로 실행**될 수 있다면 더 이상적일 것입니다.

다행이 자바스크립트는 위 두 가지 문제에 대한 해결 방안을 제공합니다.

```js
var a = 2;

(function foo() {
  // <-- insert this
  var a = 3;
  console.log(a); // 3
})(); // <-- and this

console.log(a); // 2
```

해당 소스 코드를 분석해보도록 하겠습니다.

- 먼저, 래핑 `function` 문은 **`(function... as just function` 으로 시작한다는 점**에 유의해야합니다.
  - 이것은 사소한 세부 사항처럼 보일 수 있지만 **실제로는 큰 변경 사항입니다.**
  - 함수를 표준 선언으로 취급하는 대신, `function` 은 `function-expression` 으로 처리됩니다.

<div style={{display: "flex", alignItems: "center", flexDirection: "column", border: "1px solid gray", borderRadius: "8px", padding: "20px", marginBottom: '1.5rem'}}>
  <h3>NOTE</h3>
  <span>선언과 표현식을 구별하는 가장 쉬운 방법은 <strong>명령문에서 <code>function</code> 키워드라는 단어의 위치(단순한 행이 아니라 고유한 명령문)</strong>입니다. <code>function</code> 키워드가 명령문에서 <strong>맨 처음에 있는 경우 함수 선언</strong>입니다. 그렇지 않으면 <strong>함수 표현식</strong>입니다.</span>
</div>

여기 함수 선언과 함수 표현식 사이에서 관찰할 수 있는 주된 차이점은 **이름이 식별자로 바인딩되는 위치**와 관련이 있습니다.

앞의 두 가지 예시를 비교해보도록 합시다.

- 첫 번째 예시는 `foo` 라는 이름은 **둘러싸는 스코프에 바인딩** 되며 **`foo()` 를 사용하여 직접 호출**합니다.
- 두 번째 예시는 `foo` 라는 이름은 **둘러싸는 스코프에 바인딩 되지 않으며**, 대신 **자체 함수 내부에서만 바인딩**됩니다.

즉 `(function foo(){...})` 표현식은 **식별자 `foo` 가 외부 스코프가 아닌 `..` 가 가리키는 범위에서만 발견된다는 것**을 의미합니다. 내부에 `foo` 라는 이름을 숨기는 것은 **포함하는 스코프를 불필요하게 오염시키지 않는다는 것**을 의미합니다.

<br/>

### Anonymous Versus Named ❓

---

다음과 같은 콜백 매개변수로서의 함수 표현식에 가장 익숙할 것입니다.

```js
setTimeout(function () {
  console.log("I waited 1 second!");
}, 1000);
```

`function()...` 에 이름 식별자가 없기 때문에 이를 **익명 함수 표현식**이라고 합니다.

- 함수 표현식은 익명일 수 있지만, 함수 선언식은 이름을 생략할 수 없습니다.
  - 이는 잘못된 자바스크립트 문법입니다.

익명 함수 표현식은 **빠르고 쉽게 입력할 수 있므며,** 많은 라이브러리와 도구에서 이러한 관용적 코드 스타일을 권장하는 경향이 있습니다. 그러나 고려해야 할 **몇 가지 단점**이 있습니다.

- 익명 함수에는 **스택 추적에 표시할 유용한 이름**이 없으므로, 디버깅을 더 어렵게 만들 수 있습니다.
- 이름 없이 함수가 참조해야 하는 경우, 재귀 함수의 경우에 불행히도 사용하지 않는 `arguments.callee` 참조가 필요합니다.
  - 자체 참조가 필요한 또 다른 예는 이벤트 핸들링 함수가 실행된 후, 바인딩을 해제하려는 경우입니다.
- 설명하는 이름은 문제의 코드를 자체 문서화하는데 도움이 되기도 합니다.

인라인 함수 표현식은 강력하고 유용합니다. 익명과 명명의 문제는 그 점을 훼손하지 않습니다.

- 함수 표현식에 이름을 제공하면 이러한 단점을 매우 효과적으로 해결할 수 있지만, 실질적인 단점은 없습니다.

가장 좋은 방법은 **항상 함수 표현식의 이름을 지정하는 것**입니다.

```js
setTimeout(function timeoutHandler() {
  // <-- Look, I have a
  // name!
  console.log("I waited 1 second!");
}, 1000);
```

<br/>

### Invoking Function Expressions Immediately ❓

---

```js
var a = 2;

(function foo() {
  var a = 3;
  console.log(a); // 3
})();

console.log(a); // 2
```

이제 함수를 소괄호(`()`)로 래핑하여 표현식으로 사용할 수 있으므로 `(function foo(){...})()` 와 같이 **끝에 다른 소괄호를 추가**하여 해당 함수를 **즉시 실행할 수 있습니다.**

- 첫 번째 소괄호는 **함수를 표현식으로** 만들고, 두 번째 소괄호는 **함수를 실행**합니다.
- 이 패턴은 매우 일반적이어서 몇 년 전에 커뮤니티에서 IIFE라는 용어에 동의했습니다.
  - IIFE는 즉시 호출되는 함수 표현식을 의미합니다.

물론 IIFE에는 이름이 필요하지 않습니다.

- IIFE의 가장 일반적인 형태는 **익명 함수 표현식**을 사용하는 것입니다.

> 확실히 덜 일반적이지만 IIFE를 명명하면 익명 함수 표현식보다 앞서 언급한 모든 이점이 있으므로 채택하는 것이 좋습니다.

```js
var a = 2;

(function IIFE() {
  var a = 3;
  console.log(a); // 3
})();

console.log(a); // 2
```

`(function(){ .. }())` 와 같은 기존 IIFE 형식에 약간의 변형이 있습니다. 차이점을 자세히 살펴봅시다.

- 첫 번째 형식에서 함수 표현식은 소괄호로 묶이고 호출하는 소괄호 쌍은 바로 뒤에 있습니다.
- 두 번째 형식에서는 호출하는 소괄호가 **외부 소괄호 래핑의 내부로 이동**합니다.
- 이 두 가지 형식은 기능 면에서는 동일하기에 순전히 선호에 따라 갈립니다.

매우 일반적인 IIFE의 또 다른 변형은 **실제로 단지 함수 호출이라는 사실을 활용하여 인수를 전달하는 것**입니다.

```js
var a = 2;

(function IIFE(global) {
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
})(window);

console.log(a); // 2
```

> **`global` 객체에 대해 알아보기 🔍**
>
> 우리는 전역 객체를 참조하기 위해 대개 `window` 를 참조하곤 하는데요, 이외에도 `global` 이라는 객체가 있는 것을 아시나요? 정확히 말하자면 두 가지의 차이점은 다음과 같습니다.
>
> - 브라우저 환경에서의 전역 객체는 `window`
> - Node.js 환경에서의 전역 객체는 `global`
>
> Runjs에서 실행했을 때에는 `global` 객체와 `window` 객체는 같다고 나오지만, 브라우저 콘솔에서는 `global` 객체를 찾을 수가 없네요.

`window` 객체 참조를 전달하지만 **매개 변수의 이름을 `global` 로 지정**하여 전역 참조 대 비전역 참조에 대한 명확한 문체 묘사를 갖습니다.

- 물론 둘러싼 스코프에서 원하는 무엇이든 전달할 수 있으며, 매개변수의 이름을 원하는 대로 저장할 수 있습니다.
  - 이것은 대부분 원하는 방식에 따라 다릅니다.

이 패턴의 또 다른 응용은 정의되지 않은 **기본 식별자의 값을 잘못 덮어써** 예상치 못한 결과를 초래할 수 있다는 문제를 해결합니다.

- 매개변수에 `undefined` 식별자를 지정하지만, 해당 인수에 대한 **값을 전달하지 않으면 `undefined` 로 정의된 식별자가 실제로 코드 블록에서 정의되지 않은 값 임을 보장할 수 있습니다.**

```js
undefined = true; // setting a land-mine for other code! avoid!

(function IIFE(undefined) {
  var a;
  if (a === undefined) {
    console.log("Undefined is safe here!");
  }
})();
```

IIFE의 또 다른 응용은 **호출 및 전달할 매개변수 다음에 실행할 함수가 두 번째로 주어지는 것의 순서를 뒤집습니다.**

- 이 패턴은 **UMD(Universial Module Definition) 프로젝트**에서 사용됩니다.
- 어떤 사람들은 약간 더 장황하지만 이해하기가 조금 더 깨끗하다고 합니다.

```js
var a = 2;

(function IIFE(def) {
  def(window);
})(function def(global) {
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
});
```

**`def` 함수 표현식**은 소스 코드의 **후반부에 정의**된 다음, 코드의 **전반부에 정의된 IIFE 함수에 매개변수(`def` 라고도 함)로 전달**됩니다. 마지막으로 매개변수 **`def` 가 호출**되어 **`window` 를 `global` 매개변수로 전달합니다.**

<br/>

## Block as Scopes ❕

---

> **TL;DR 🔖**
>
> - 함수가 일반적인 스코프 단위이지만 유일하지는 않고, 대신 **블록 스코프**를 활용하여 코드 유지 관리가 훨씬 더 좋고 깨끗해질 수 있습니다.
> - 블록 스코프의 예시로 **`with` 와 `try/catch` 구문, `let`, `const` 등**이 있습니다.

<br />

**함수는 가장 일반적인 스코프 단위**이며 자바스크립트에서 가장 널리 사용되는 설계 접근 방식이지만 **다른 스코프 단위도 가능**하며 이러한 다른 스코프 단위를 사용하면 **코드 유지 관리가 훨씬 더 좋고 깨끗해질 수 있습니다.**

- 자바스크립트 이외의 많은 언어는 **블록 스코프**를 지원하므로 해당 언어의 개발자는 이러한 사고 방식에 익숙하지만, 주로 자바스크립트에서 작업한 사람들은 이 개념이 약간 생소할 수도 있습니다.
- 그러나 블록 스코프 방식으로 한 줄의 코드를 작성한 적이 없더라도, 자바스크립트에서 다음과 같은 **매우 일반적인 관용 표현**에 여전히 익숙할 것입니다.

```js
for (var i = 0; i < 10; i++) {
  console.log(i);
}
```

`for` 루프 **헤드 내에 직접 변수 `i` 를 선언**합니다.

- 아마도 우리의 의도는 해당 **`for` 루프의 컨텍스트 내에서만 `i` 를 사용하는 것**인데, 이는 본질적으로 **변수가 실제로 자신을 둘러싸는 스코프(함수 또는 전역)로 스코프를 지정한다는 사실을 무시하기 때문**입니다.
- 이것이 바로 **블록 스코프 지정에 관한 것**입니다.
  - **변수를 사용할 위치에 최대한 가깝게, 가능한 한 지역적으로 선언**합니다.

```js
var foo = true;

if (foo) {
  var bar = foo * 2;
  bar = something(bar);
  console.log(bar);
}
```

우리는 `if` 문의 컨텍스트에만 `bar` 를 사용하고 있으므로, `if` 블록 내에서 선언하는 것이 일종의 의미가 있습니다.

- 그러나 변수를 선언하는 위치는 `var` 를 사용할 때 관련이 없습니다.
  - **변수는 항상 둘러싸는 스코프에 속하기 때문**입니다.
- 이 스니펫은 스타일상의 이유로 본질적으로 **가짜 블록 스코프 지정**이며, 해당 스코프의 다른 위치에서 **실수로 `bar` 를 사용하지 않도록 자체적인 규약에 의존**합니다.

블록 스코프는 이전의 **최소 권한 원칙**을 **함수의 정보 숨기기**에서 **코드 블록의 정보 숨기기로 확장하는 도구**입니다.

```js
for (var i = 0; i < 10; i++) {
  console.log(i);
}
```

`for` 루프에서만 사용되거나 최소한으로 사용되어야 하는 `i` 변수로 함수의 전체 범위를 오염시키는 이유는 무엇일까요?

- 그러나 더 중요한 것은 개발자가 의도한 목적을 벗어난 변수를 **실수로 재사용하지 않도록 스스로를 확인하는 것을 선호**할 수 있습니다.
  - 예를 들어, 잘못된 위치에서 변수를 사용하려고 할 때, 알 수 없는 변수에 대한 오류가 발생합니다.

`i` 변수에 대한 블록 스코프 지정은 `for` 루프에서만 `i` 를 사용할 수 있게 하여, **함수의 다른 곳에서 `i` 에 접근하면 오류가 발생합니다.**

- 이는 변수가 혼란을 주거나 유지 관리하기 어려운 방식으로 재사용되지 않도록 하는데 도움이 됩니다.
  - 그러나 슬픈 현실은 표면적으로 **자바스크립트에는 블록 스코프를 위한 기능이 없다는 것**입니다.

그렇기에 우린 이에 대해 좀 더 알아볼 필요가 있습니다.

<br/>

### with ❓

---

우리는 2장에서 `with` 에 대해 배웠습니다.

- 그것은 눈쌀을 찌푸리게 만드는 구조이지만, **객체에서 생성된 스코프가 `with` 문의 수명 동안만 존재한다는 점**에서 블록 스코프의 한 예시입니다.
  - 포함하는 스코프가 아닙니다.

<br/>

### try/catch ❓

---

ES3의 자바스크립트가 **`try/catch` 의 `catch` 절에서 변수 선언을 `catch` 블록으로 블록 스코프 지정했다는 사실**은 거의 알려지지 않았습니다.

```js
try {
  undefined(); // illegal operation to force an exception!
} catch (err) {
  console.log(err); // works!
}

console.log(err); // ReferenceError: `err` not found
```

보시다시피 `err` 는 `catch` 절에만 존재하며 다른 곳에서 참조하려고 하면 오류가 발생합니다.

<div style={{display: "flex", alignItems: "center", flexDirection: "column", border: "1px solid gray", borderRadius: "8px", padding: "20px", marginBottom: '1.5rem'}}>
  <h3>NOTE</h3>
  <span>
    이 동작이 지정되고 거의 모든 표준 자바스크립트 환경(이전 IE 제외)에 적용되지만, 동일한 스코프에 동일한 식별자 이름으로 <code>error</code> 변수를 선언하는 두 개 이상의 <code>catch</code> 절이 있는 경우 린터(linter)는 여전히 불만이 있는 것 같습니다. 변수가 안전하게 블록 스코프이기 때문에 이것은 실제로 재정의가 아니지만, 린터는 여전히 이에 대해 불만이 있습니다.
    <br/>
    <br/>
    이러한 불필요한 경고를 피하기 위해 일부 개발자들은 <strong><code>catch</code> 변수의 이름을 <code>err1</code>, <code>err2</code> 등으로 지정</strong>합니다. 다른 개발자는 <strong>중복 변수 이름에 대한 린트 검사를 해제</strong>합니다.
  </span>
</div>

`catch` 의 블록 스코프 특징은 쓸모없는 학문적 사실처럼 보일 수 있지만, 얼마나 유용한지에 대한 자세한 내용은 부록 B를 참조하세요.

<br/>

### let ❓

---

지금까지 자바스크립트에는 **블록 스코프 기능을 노출하는 이상한 틈새 동작(?)**만 있음을 보았습니다.

- 그것이 우리가 가진 전부이고 오랜 세월이었다면, 블록 스코프 지정은 자바스크립트 개발자에게 그다지 유용하지 않을 것입니다.

다행히 ES6는 이를 변경하고 변수를 선언하는 또 다른 방법으로 `var` 다음 **새로운 키워드인 `let` 을 도입했습니다.**

- `let` 키워드는 **변수 선언이 포함된 블록(일반적으로 `{...}` 쌍)의 스코프에 변수 선언을 포함**합니다.
  - 즉, `let` 은 암시적으로 **변수 선언에 대한 모든 블록의 스코프를 하이재킹(납치?)합니다.**

```js
var foo = true;

if (foo) {
  let bar = foo * 2;
  bar = something(bar);
  console.log(bar);
}

console.log(bar); // ReferenceError
```

문장이 유효한 문법인 곳에 `{...}` 쌍을 포함하기만 하면 `let` 이 바인딩할 임의의 블록을 만들 수 있습니다.

- 이 경우 `if` 문 내부에 **명시적인 블록**을 만들었습니다.
  - 이 블록은 둘러싸는 **`if` 문의 위치와 의미에 영향을 주지 않고**, 이후 리팩토링을 진행할 때 **전체 블록으로 더 쉽게 이동할 수 있습니다.**

<div style={{display: "flex", alignItems: "center", flexDirection: "column", border: "1px solid gray", borderRadius: "8px", padding: "20px", marginBottom: '1.5rem'}}>
  <h3>TIP</h3>
  <span>
    명시적 블록 스코프를 표현하는 다른 방법은 부록 B를 참조하세요
  </span>
</div>

4장에서는 **선언이 발생하는 스코프에 존재하는 것으로 간주되는 선언**에 대한 내용인 **호이스팅**에 대해 다룰 것입니다.

- 그러나 `let` 으로 만든 선언은 **해당 선언이 나타나는 블록의 전체 스코프로 호이스팅 되지 않습니다.**

```js
{
  console.log(bar); // ReferenceError!
  let bar = 2;
}
```

<br/>

### Garbage collection ❔

---

블록 스코프 지정이 유용한 다른 이유는 **메모리 회수를 위한 클로저 및 가비지 콜렉션**과 관련이 있습니다.

> **가비지 콜렉션(Garbage collection) 🔍**
>
> 가비지 콜렉션은 메모리 관리 기법 중의 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능이다.

- 여기서는 간략하게 설명하지만 클로저 메커니즘은 5장에서 자세히 설명합니다.

```js
function process(data) {
  // do something interesting
}

var someReallyBigData = { ... };

process(someReallyBigData);

var btn = document.getElementById("my_button");

btn.addEventListener(
  "click",
  function click(evt) {
    console.log("button clicked");
  },
  /*capturingPhase=*/ false
);
```

`click` 함수 클릭 핸들러 콜백에는 `someReallyBigData` 변수가 전혀 필요하지 않습니다.

- 즉, 이론적으로 `process(..)` 가 실행된 후 메모리를 많이 차지하는 데이터 구조가 가비지 콜렉팅의 대상이 될 수 있습니다.
  - 그러나 `click` 함수가 전체 스코프에 대해 클로저를 갖기 때문에, 자바스크립트 엔진이 여전히 구조를 유지해야 할 가능성이 매우 높습니다.

블록 스코프 지정은 이 문제를 해결할 수 있으므로, **엔진이 `someReallyBigData` 를 유지할 필요가 없다는 것**을 더 명확하게 알릴 수 있습니다.

```js
function process(data) {
  // do something interesting
}

// anything declared inside this block can go away after!
{
  let someReallyBigData = { ... };
  process(someReallyBigData);
}

var btn = document.getElementById("my_button");

btn.addEventListener(
  "click",
  function click(evt) {
    console.log("button clicked");
  },
  /*capturingPhase=*/ false
);
```

**로컬로 바인딩할 변수에 대한 명시적 블록을 선언하는 것**은 강력한 도구입니다.

<br/>

### let loops ❔

---

`let` 의 역할이 빛나는 경우는 이전에 논의한 **`for` 루프의 경우** 입니다.

```js
for (let i = 0; i < 10; i++) {
  console.log(i);
}
console.log(i); // ReferenceError
```

**`for` 루프 헤더의 `let`** 은 **`i` 를 `for` 루프 본문에 바인딩**할 뿐만 아니라, 실제로 **루프의 각 반복에 다시 바인딩**하여 이전 루프 반복의 끝에서 값을 다시 할당해야합니다.

다음은 발생하는 반복 당 바인딩 동작을 설명하는 또 다른 방법입니다.

```js
{
  let j;

  for (j = 0; j < 10; j++) {
    let i = j; // re-bound for each iteration!
    console.log(i);
  }
}
```

> 이 **반복 당 바인딩**이 흥미로운 이유는 클로저에 대해 논의할 때 5장에서 명확해질 것입니다.

`let` 선언은 둘러싸는 함수의 스코프(또는 전역)가 아닌 **임의의 블록에 연결**되기 때문에, 기존 코드가 함수 범위 `var` 선언에 숨겨진 의존성을 갖고 `var` 를 `let` 으로 교체하는 경우 리팩토링 할 때 추가적인 주의가 필요할 수 있습니다.

```js
var foo = true,
  baz = 10;

if (foo) {
  var bar = 3;
  if (baz > bar) {
    console.log(baz);
  }
  // ...
}
```

이 코드는 상당히 쉽게 다음과 같이 리팩토링됩니다.

```js
var foo = true,
  baz = 10;

if (foo) {
  var bar = 3;
  // ...
}

if (baz > bar) {
  console.log(baz);
}
```

그러나 블록 스코프 변수를 사용할 때는 다음과 같은 변경사항에 주의하세요.

```js
var foo = true,
  baz = 10;

if (foo) {
  let bar = 3;
  if (baz > bar) {
    // <-- don't forget `bar` when moving!
    console.log(baz);
  }
}
```

이러한 시나리오에 더 강력하고 유지 및 관리와 리팩토링이 더 쉬운 코드를 제공할 수 있는 **대체(보다 명시적인) 블록 스코프 지정 스타일**은 부록 B를 참조하세요.

<br/>

### const ❓

---

`let` 외에도 `ES6` 는 블록 스코프 변수를 생성하지만 **값이 고정(상수)인 `const`** 를 도입했습니다.

- `const` 로 선언한 **변수의 값을 변경하고자 하면 오류가 발생**합니다.

```js
var foo = true;

if (foo) {
  var a = 2;
  const b = 3; // block-scoped to the containing `if`

  a = 3; // just fine!
  b = 4; // error!
}

console.log(a); // 3
console.log(b); // ReferenceError!
```

<br/>

## Review ❕

---

- **함수**는 자바스크립트에서 **가장 일반적인 스코프 단위**입니다.
- 다른 함수 내에서 선언된 변수와 함수는 본질적으로 **둘러싸인 스코프에 숨겨져 있습니다.**
  - 이는 좋은 소프트웨어의 의도적인 설계 원칙입니다.
- 그러나 함수가 유일한 스코프 단위는 아니며, 블록 스코프는 변수와 함수가 둘러싸는 함수에만 속하지 않고 **코드의 임의 블록에 속할 수 있다는 것**을 보여줍니다.
- ES3부터 `try/catch` 구조는 **`catch` 절에 블록 스코프를 갖습니다.**
- ES6에서는 임의의 코드 블록에서 변수 선언을 허용하기 위한 **`let` 키워드**가 도입되었습니다.
- `if (..) { let a = 2; }` 는 본질적으로 `if` 의 `{...}` **블록 스코프를 가로채 그곳에 연결하는 변수 `a` 를 선언**합니다.
- 일부 사람들은 그것을 믿는 것처럼 보이지만 블록 스코프로 `var` 함수 스코프를 완전히 대체해서는 안됩니다.
- 두 가지 기능이 공존하며 개발자는 더 좋고, 읽기 쉽고, 유지 관리가 쉬운 코드를 생성하기 위해 각각 적절한 경우 함수 스코프와 블록 스코프 기술을 모두 사용할 수 있어야합니다.
