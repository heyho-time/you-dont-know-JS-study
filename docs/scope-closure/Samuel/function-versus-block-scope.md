---
title: Chapter 3. Function Versus Block Scope
tags: [function, block, scope]
sidebar_position: 3
---

<br/>

## 들어가며 🏃

---

2장에서 살펴본 바와 같이 **스코프는 각각의 컨테이너(혹은 버킷) 역할을 하는 일련의 버블로 구성**되며, 여기서 **식별자(변수나 함수)가 선언**됩니다. 그리고 해당 버블들은 **서로 중첩**되며 **코드 작성 시점에 정의**됩니다.

- 그렇다면 버블을 만드는 것은 단지 **함수뿐인가?** 다른 구조가 스코프 버블을 만들 수 있을까?

<br/>

## Scope From Functions ❕

---

> **TL;DR 🔖**
>
> - 선언된 함수는 **자체적인 스코프 버블을 생성**하며, **스코프에선 선언의 순서는 중요하지 않습니다.**

<br />

이러한 질문에 대한 가장 일반적인 대답은 **자바스크립트에 함수 기반 스코프가 있다는 것**입니다.

- 즉, **선언한 함수는 자체적으로 버블을 생성**하지만 다른 구조는 자체 스코프 버블을 생성하지 않습니다.
  - 잠시 후 살펴보겠지만 이것은 사실이 아닙니다.
- 하지만, 먼저 **함수 스코프와 그 의미**를 살펴보겠습니다.

```js
function foo(a) {
  var b = 2;
  // some code
  function bar() {
    // ...
  }
  // more code
  var c = 3;
}
```

이 스니펫에서 `foo()` 의 스코프 버블에는 식별자 `a`, `b`, `c` 및 `bar` 가 포함됩니다.

- 스코프에서 **선언의 위치는 중요하지 않습니다.**
- 변수 또는 함수는 **관계없이 포함하는 스코프 버블**에 속합니다.

> 다음 장에서 이것이 정확히 어떻게 작동하는지 알아볼 것입니다.

- `bar()` 에는 **자체 스코프 버블**이 있습니다.
  - `foo` 라는 하나의 식별자만 연결된 **전역 스코프**도 마찬가지입니다.
- `b`, `c` 및 `bar` 는 모두 `foo()` 의 스코프 버블에 속하므로 `foo()` 외부에서 접근할 수 없습니다.
  - 즉, **전역 스코프에서 식별자를 사용할 수 없기 때문에**, 다음 코드에서는 모두 **`ReferenceError` 오류를 발생**시킵니다.

```js
bar(); // fails
console.log(a, b, c); // all 3 fail
```

그러나 이러한 **모든 식별자(`a`, `b`, `c`, `foo` 및 `bar`)는 `foo()` 내부에서 접근할 수 있으며,** 실제로 **`bar()` 내부에서도 사용할 수 있습니다(`bar()` 내부에 섀도잉 선언이 없다고 가정).**

- 함수 스코프는 **모든 변수가 함수에 속하고 함수 전체에서 사용 및 재사용될 수 있다는 아이디어를 장려**합니다.
  - 실제로는 **중첩 스코프에서도 접근이 가능**합니다.
- 이 디자인 접근 방식은 매우 유용할 수 있으며, 필요에 따라 **다양한 타입의 값을 취하기 위해 자바스크립트 변수의 동적 특성을 최대한 활용할 수 있습니다.**
- 반면에 주의를 기울이지 않으면, **스코프 전체에 존재하는 변수**로 인해 예상치 못한 오류가 발생할 수 있습니다.

<br/>

## Hiding in Plain Scope ❕

---

> **TL;DR 🔖**
>
> - 함수 선언 내 **특정 코드 섹션을 래핑**하면 코드를 **숨길 수 있습니다.**
> - 코드를 숨기게 되면 **최소 권한의 원칙**에 따라 **필요한 사항만 노출**할 수 있고, **비공개 세부 정보를 내부에 숨길 수 있으며, 용도가 다른 두 가지 동명의 식별자 간의 충돌을 방지**할 수 있습니다.
> - 프로그램에 로드된 여러 라이브러리는 **내부 함수와 변수**를 제대로 숨기지 않으면 서로 충돌하기 쉬우며, 이를 위해 **모듈 관리** 방식을 사용하기도 합니다.

<br />

함수에 대한 전통적인 사고 방식은 **함수를 선언한 다음 그 안에 코드를 추가하는 것**입니다.

- 그러나 이에 대한 역발상은 똑같이 강력하고 유용합니다.
- 작성한 코드의 **임의의 섹션을 가져와 그 주위에 함수 선언을 래핑하면 실제로 코드를 숨깁니다.**
- 이에 대한 실제 결과는 **해당 코드 주위에 스코프 버블을 만드는 것**입니다.
  - 즉, **해당 코드의 모든 선언(변수 또는 함수)**은 이제 **이전이 아닌 새 래핑 함수의 스코프에 연결**됩니다.
    - 변수와 함수를 **함수 스코프에 넣어 숨길 수 있습니다.**

변수와 함수를 숨기는 것이 유용한 기술인 이유는 무엇일까요?

- 그들은 **최소 권한(Least Authority)** 또는 **최소 노출(Least Exposure)**이라고도 하는 **최소 권한(Least Privilege)의 소프트웨어 설계 원칙에서 발생하는 경향**이 있습니다.

> [**최소 권한의 원칙(The principle of least privilege)**](https://www.ibm.com/docs/en/aix/7.2?topic=software-least-privilege)은 소프트웨어 모듈이 **의도한 작업을 수행하는데 필요한 최소한의 기능을 제공해야 한다는 것**입니다.
>
> 해당 도서에서는 모듈/객체용 API와 같은 소프트웨어 설계에서 **최소한으로 필요한 것만 노출하고 나머지는 숨겨야한다고 명시하는 것**이라고 합니다.

이 원칙은 변수와 함수를 포함할 스코프의 선택으로 확장됩니다.

- 모든 변수와 함수가 **전역 스코프에 있으면 모든 중첩 범위에서 접근할 수 있습니다.**
  - 그러나 이것은 코드를 적절하게 사용하면 해당 변수/함수에 대한 접근을 방해하므로 **비공개로 유지해야 하는 많은 변수 또는 함수를 노출한다는 점에서 최소 권한 원칙에 위배**됩니다.

```js
function doSomething(a) {
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}

function doSomethingElse(a) {
  return a - 1;
}

var b;

doSomething(2); // 15
```

해당 스니펫에서 `b` 변수와 `doSomethingElse()` 함수는 `doSomething()` 이 작업을 수행하는 방법에 대한 **비공개 세부 정보**일 수 있습니다.

- 둘러싸는 스코프에 `b` 및 `doSomethingElse()` 에 대한 접근 권한을 부여하는 것은 불필요할 뿐만 아니라 의도적이든 아니든 예상치 못한 방식으로 사용될 수 있고, `doSomething` 의 전제 조건 가정을 위반할 수 있다는 점에서 위험할 수 있습니다.
- 보다 적절한 디자인은 다음과 같이 **doSomething()` 스코프 내에서 이러한 개인 세부 정보를 숨깁니다.**

```js
function doSomething(a) {
  function doSomethingElse(a) {
    return a - 1;
  }
  var b;

  b = a + doSomethingElse(a * 2);

  console.log(b * 3);
}

doSomething(2); // 15
```

이제 `b` 와 `doSomethingElse()` 는 외부 영향력에 의해 접근할 수 없으며, 대신에 **`doSomething()` 에 의해서만 제어**됩니다.

- 함수 및 최종 결과에 영향을 받지 않았지만, 디자인은 일반적으로 더 나은 소프트웨어로 간주되는 **개인 정보를 비공개로 유지합니다.**

<br/>

### Collision Avoidance ❓

---

스코프 내에서 변수와 함수를 숨기는 것의 또 다른 장점은 **용도가 다른 두 개의 같은 식별자 간의 의도하지 않은 충돌을 방지하는 것**입니다.

- 충돌로 인해 **예상치 못한 값 덮어쓰기가 발생하는 경우**가 많기 때문입니다.

```js
function foo() {
  function bar(a) {
    i = 3; // changing the `i` in the enclosing scope's
    // for-loop
    console.log(a + i);
  }

  for (var i = 0; i < 10; i++) {
    bar(i * 2); // oops, inifinite loop ahead!
  }
}

foo();
```

`bar()` 내부의 `i = 3` 할당은 예기치 않게 **`for` 루프에서 `foo()` 에 선언된 `i` 를 덮어씁니다.**

- 이 경우가 `i` 가 고정 값 `3` 으로 설정되고 영원히 `< 10` 으로 유지되기 때문에 **무한 루프가 발생합니다.**

`bar()` 내부의 할당은 **선택된 식별자 이름에 관계없이 사용할 지역 변수를 선언해야 합니다.**

- 변수 `i = 3;` 문제를 해결하고 **`i` 에 대해 앞에서 언급한 섀도잉 변수 선언을 생성**합니다.

추가 옵션은 `var j = 3;` 과 같이 **완전히 다른 식별자 이름을 선택하는 것**입니다.

- 그러나 소프트웨어 디자인은 자연스럽게 동일한 식별자 이름을 요구할 수 있으므로, **스코프를 활용하여 내부 선언을 숨기는 것이 이 경우엔 최선의 옵션**입니다.

<br/>

#### Global namespaces

---

변수 충돌의 대부분의 경우는 **전역 스코프**에서 발생합니다.

- 프로그램에 로드된 여러 라이브러리는 **내부 함수와 변수**를 제대로 숨기지 않으면 서로 충돌하기 쉽습니다.

이러한 라이브러리는 일반적으로 전역 스코프에서 충분히 **고유한 이름을 가진 단일 변수 선언(종종 객체)을 만듭니다.**

- 그런 다음 해당 객체는 **라이브러리의 네임스페이스**로 사용되며, 여기서 함수의 모든 특정 노출은 최상위 정적 스코프 식별자 자체가 아니라, **해당 객체(네임스페이스)의 속성으로 만들어집니다.**

```js
var MyReallyCoolLibrary = {
  awesome: "stuff",
  doSomething: function () {
    // ...
  },
  doAnotherThing: function () {
    // ...
  },
};
```

<br/>

#### Module management

---

충돌 방지를 위한 또 다른 옵션은 **다양한 의존성 관리자를 사용하는 보다 현대적인 모듈 접근 방식**입니다.

- 이러한 도구를 사용하면 어떤 라이브러리도 전역 범위에 식별자를 추가하지 않지만, 대신에 의존성 관리자의 다양한 매커니즘을 사용하여 **식별자를 명시적으로 다른 스코프로 가져와야 합니다.**
- 이러한 도구에는 정적 스코프 규칙에서 면제되는 **마법 기능이 없습니다.** 그들은 여기에 설명된 스코프 지정 규칙을 사용하여 **식별자가 공유 스코프에 편입되지 않도록 하고,** 대신에 충돌에 취약하지 않은 **비공개 범위에 보관**하여 우발적인 스코프 충돌을 방지합니다.

따라서 이를 선택하면 실제로 이를 사용할 필요 없이 **수동적으로 코딩하고 의존성 관리자와 동일한 결과를 얻을 수 있습니다.**

모듈 패턴의 자세한 내용은 5장을 참조하세요.
