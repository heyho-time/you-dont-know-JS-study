---
title: Chapter 2. Lexical Scope
tags: [scope, lexical]
sidebar_position: 2
---

<br />

## 들어가며 🏃

---

1장에서 우리는 **스코프**를 **엔진**이 **식별자로 변수를 조회**하고 **현재 스코프 또는 그 안에 포함된 중첩 범위에서 찾는 방법을 제어하는 규칙 집합**으로 정의했습니다.

스코프 작동 방식에는 **두 가지 주요 모델**이 있습니다.

- 하나는 **정적 스코프(Lexical scope)**로 대부분의 프로그래밍 언어에서 사용되는 가장 일반적인 경우입니다.
- 다른 모델은 **동적 스코프(Dynamic scope)**로 일부 언어에서 여전히 사용되는 다른 모델입니다.

> 동적 스코프는 부록 A에서 다룹니다. 여기서는 자바스크립트가 사용하는 스코프 모델인 **정적 스코프**와의 대조를 위해서만 언급합니다.

<br/>

## Lex-time ❕

---

> **TL;DR 🔖**
>
> - 정적 스코프는 **렉싱할 때 정의되는 범위**로 코드 작성을 할 때, **변수와 블록이 작성된 위치를 기반**으로 합니다.
> - 스코프마다 여러 레이어에 동일한 식별자를 정의할 수 있는데, 이를 **섀도잉**이라고 합니다.

<br />

1장에서 논의한 바와 같이 일반적인 언어 컴파일러의 첫 번째 단계는 **렉싱(일명 토큰화)**입니다.

- 기억한다면, **렉싱 프로세스**는 **소스 코드 문자의 문자열을 검사**하고 일부 **상태 기반 구문 분석의 결과로 토큰에 의미론적인 태그 등을 할당**합니다.
  - 정적 스코프가 무엇이며 어원이 무엇인지에 대해 이해하기 위한 기초를 제공하는 것은 이 개념입니다.
  - 다시 정의하자면, 정적 스코프는 **렉싱할 때 정의되는 범위**입니다.
    - 이는 **코드 작성을 할 때, 변수와 블록이 작성된 위치를 기반**으로 하기에 렉서가 코드를 처리할 때 **대부분 고정됩니다.**

> **Note 🗒️**
>
> 우리는 정적 스코프를 속이는 몇 가지 방법이 있다는 것을 조금 후에 알게 될 것입니다. 그렇기에 렉서가 지나간 후에 이를 수정하지만 이러한 것들은 눈살을 찌푸리게 합니다. 정적 스코프를 **사실상 정적 전용으로 취급**하여 본질적으로 전적으로 **코드 작성 시간 기준으로 처리하는 것이 모범 사례로 간주됩니다.**

```js
function foo(a) {
  var b = a * 2;
  function bar(c) {
    console.log(a, b, c);
  }
  bar(b * 3);
}

foo(2); // 2, 4, 12
```

해당 코드에는 세 가지 중첩 범위가 있습니다. 이러한 스코프를 서로 내부의 버블로 생각하는 것이 도움이 될 수 있습니다.

![bubble](/img/samuel/lexical-scope/bubble.png)

- 버블 1은 **전역 스코프를 포함**하며 그 안에 **`foo` 라는 하나의 식별자만 있습니다.**
- 버블 2는 `a`, `bar` 및 `b` 의 **세 가지 식별자를 포함하는 `foo` 의 범위를 포함합니다.**
- 버블 3은 `bar` 의 스코프를 포함하여 **하나의 식별자만 포함합니다.**

스코프 버블은 스코프 블록이 쓰여진 위치, 다른 블럭 안에 중첩된 스코프 등으로 정의됩니다.

> 다음 장에서 다양한 스코프 단위에 대해 논의할 것이지만 지금은 **각 함수가 새로운 스코프를 생성한다고 가정하겠습니다.**

`bar` 에 대한 버블은 `foo` 에 대한 버블 내로 완전히 포함되어 있습니다.

- 왜냐하면, 그것이 **우리가 `bar` 함수를 정의하기로 선택한 곳**이기 때문입니다.
  - 이러한 중첩된 버블은 **엄격하게 중첩되어 있습니다.**
    - 버블의 경계를 넘을 수 있는 벤 다이어그램에 대해 이야기하는 것이 아닙니다.
  - 다시 말해, 어떤 함수도 두 개의 상위 함수 각각의 내부에 부분적으로 있을 수 없는 것처럼 **일부 함수에 대한 버블은 두 가지의 다른 외부 스코프 버블 안에 동시에(부분적으로) 존재할 수 없습니다.**

<br/>

### Look-ups ❓

---

이러한 **스코프 버블의 구조**와 **상대적 배치**는 **엔진이 식별자를 찾기 위해 찾아야 하는 모든 위치를 완전히 설명합니다.**

- 이전 소스 코드에서 엔진은 `console.log()` 문을 실행하고 **세 가지의 참조 변수 `a`, `b`, `c` 를 찾습니다.**
  - 먼저, 가장 안쪽의 스코프 버블인 **`bar()` 함수의 스코프**부터 시작합니다.
  - **해당 스코프에서 찾을 수 없으므로,** 가장 가까운 스코프 버블인 **`foo()` 스코프로 이동합니다.**
  - `a` 를 그곳에서 찾고 이를 사용하며, `b` 도 마찬가지입니다.
  - 그러나 `c` 는 `bar()` 내부를 찾습니다.

`bar()` 내부와 `foo()` 내부 모두에 `c` 가 있었다면 `console.log()` 문은 `foo()` 가 아닌 `bar()` 에 있는 것을 찾아 사용했을 것입니다.

- **스코프 조회**는 **첫 번째 일치 항목을 찾으면 중단합니다.**
  - 중첩된 스코프의 **여러 레이어에 동일한 식별자 이름을 지정할 수 있습니다.**
  - 이를 **새도잉(shadowing)**이라고 합니다.
  - 섀도잉에 관계없이 **스코프 조회**는 항상 해당 시간에 실행되는 **가장 안쪽 범위에서 시작하여 첫 번째 일치까지 바깥쪽(위쪽)으로 작동하고 중단합니다.**

> **Note 🗒️**
>
> 전역 변수는 자동으로 전역 객체(브라우저 창 등)의 속성이기도 하므로 **정적 이름으로 직접 전역 변수를 참조하는 것이 아니라 전역 객체의 프로퍼티 참조로 간접적으로 전역 변수를 참조할 수 있습니다.**
>
> ```js
> window.a;
> ```
>
> 이 기술을 사용하면 **섀도잉으로 인해 접근할 수 없는 전역 변수에 대한 접근을 제공합니다.** 그러나 비전역 섀도우 변수에는 접근할 수 없습니다.

함수가 어디에서 호출되는지 또는 호출 방법에 관계없이 해당 함수의 **정적 스코프는 함수가 선언된 위치에 의해서만 정의됩니다.**

- 정적 스코프 조회 프로세스는 `a`, `b` 및 `c` 와 같은 **1급 식별자에만 적용됩니다.**
- 코드 조각에 `foo.bar.baz` 에 대한 참조가 있는 경우 `foo` 식별자를 찾는데 정적 스코프 조회가 적용되지만, 해당 변수를 찾으면 객체 프로퍼티 접근 규칙이 대신하여 `bar` 및 `baz` 프로퍼티를 해결합니다.

<br/>

## Cheating Lexical ❕

---

> **TL;DR 🔖**
>
> - 정적 스코프를 속이는 두 가지 방법은 `eval()` 또는 `with` 문을 사용하는 것입니다.
> - `eval()` 은 **문자열을 코드로 해석하여 기존 정적 스코프를 수정**하고, `with` 문은 **객체 참조를 새로운 스코프로 처리**하고 **런타임 단계에서 완전히 새로운 스코프를 생성합니다.**
> - 위 두 가지 방식은 **컴파일 단계에서 진행하는 스코프 관련 최적화 작업을 무력화하기에** 이를 지양해야합니다.

<br />

정적 스코프가 함수의 선언 위치에 의해서만 정의되고 이는 전적으로 코드 작성자의 결정이라면 런타임에 **정적 스코프를 "수정"(일명 속임수)하는 방법**이 있을까요?

자바스크립트에는 두 가지 메커니즘이 있습니다.

- 둘 다 넓은 커뮤니티에서 코드를 사용하는 나쁜 습관으로 이는 눈살을 찌푸리게 만듭니다.
- 그러나 그들의 일반적인 주장은 가장 중요한 점을 놓치는 경우가 많은데, 그것은 **정적 스코프를 속이면 성능이 저하된다는 점**입니다.

성능 문제를 설명하기 전에 두 메커니즘이 어떻게 작동하는지 알아보도록 하겠습니다.

<br/>

### eval ❓

---

자바스크립트의 **`eval()` 함수**는 **문자열을 인자로 사용**하고 **문자열의 내용을 프로그램의 해당 지점에서 실제로 작성된 코드인 것처럼 처리**합니다.

> **`eval()` 함수 짚고 가기 🔍**
>
> 간단히 말해, `eval()` 함수는 문자열로 된 내용을 코드로 실행합니다.

- 즉, **작성된 코드 내부에 프로그래밍 방식으로 코드를 생성**하고 **생성된 코드가 작성 시점에 있었던 것처럼 실행**할 수 있습니다.
- 그런 관점에서 `eval()` 을 평가하면 `eval()` 을 사용하여 작성 시점(일명 정적 시점) 코드가 계속 거기에 있었던 것처럼 속이고 가장하여 정적 스코프를 수정할 수 있는 방법이 명확해야 합니다.
- 코드의 뒤쪽에서 `eval()` 이 실행된 후 엔진은 문제는 **이전 코드가 동적으로 해석되어 정적 스코프 영역을 수정했다는 것을 "알려고 하거나" 또는 "관심을 두지" 않는다는 것**입니다.
- 엔진은 항상 그랬던 것처럼 단순히 정적 스코프 조회를 수행합니다.

다음 코드를 살펴봅시다.

```ts
function foo(str, a) {
  eval(str); // cheating!
  console.log(a, b);
}

var b = 2;

foo("var b = 3;", 1); // 1, 3
```

- 문자열 `"var b = 3;"` 는 **`eval()` 호출 시점에서 항상 있었던 코드로 처리**됩니다.
- 그 코드(`eval()`)는 **새로운 변수 `b` 를 선언**하기 때문에 **`foo()` 의 기존 정적 스코프를 수정**합니다.
  - 사실, 앞서 언급했듯이 이 코드는 실제로 **외부(전역) 스코프에서 선언된 `b` 를 새도우로 만드는 변수 `b` 를 `foo()` 내부에 생성**합니다.
  - `console.log()` 호출이 발생하면 `foo()` 스코프에서 `a` 와 `b` 를 찾고, 외부(전역) `b`는 찾지 않습니다.
  - 따라서 일반적으로 `"1, 2"` 대신 `"1, 3"` 을 출력합니다.

> **Note 🗒️**
>
> 이 예에서 단순함을 위해 우리가 전달하는 "코드" 문자열은 **고정된 리터럴**이었습니다. 그러나 프로그램 논리에 따라 문자를 함께 추가하여 프로그래밍 방식으로 쉽게 만들 수 있습니다.
>
> - `eval()` 은 일반적으로 **동적으로 생성된 코드를 실행하는 데 사용**됩니다.
> - 문자열 리터럴에서 본질적으로 정적 코드를 동적으로 평가하는 것은 코드를 직접 작성하는 것만으로는 실질적인 이점을 제공하지 않기 때문입니다.

기본적으로 **`eval()` 이 실행하는 코드 문자열에 하나 이상의 선언(변수 또는 함수)이 포함된 경우** 이 작업은 **`eval()` 이 있는 기존 정적 스코프를 수정**합니다.

- 기술적으로 `eval()` 은 다양한 속임수를 통해 간접적으로 호출할 수 있습니다.
- 그러나 두 경우 모두 `eval()` 은 런타임에 코드 작성 시간 기준 정적 스코프를 수정할 수 있습니다.

> **Note 🗒️**
>
> `"strict mode"` 프로그램에서 사용될 때, `eval()` 은 **자체 정적 스코프에서 작동**합니다. 즉, **`eval()` 내부의 선언은 중첩 스코프를 수정하지 않습니다.**
>
> ```ts
> function foo(str) {
>   "use strict";
>   eval(str);
>   console.log(a); // ReferenceError: a is not defined
> }
>
> foo("var a = 2");
> ```

자바스크립트에는 `eval()` 과 매우 유사한 다른 함수가 있습니다.

- `setTimeout()` 및 `setInterval()` 은 각각의 첫 번째 인수에 대해 문자열을 사용할 수 있으며, **그 내용은 동적으로 생성된 함수의 코드로 평가**됩니다. 이것은 **오래된 레거시 동작**이며 오랫동안 사용되지 않습니다.
- 새로운 `Function()` 함수 생성자는 유사하게 마지막 인수에서 **코드 문자열**을 사용하여 **동적으로 생성된 함수로 전환**합니다.
  - 이 함수 생성자 구문은 `eval()` 보다 약간 더 안전하지만 코드에서는 여전히 피해야 합니다.

**성능 저하로 인해 함수의 가치가 거의 없기 때문에** 프로그램 내부에서 동적으로 코드를 생성하는 사용 사례는 매우 드뭅니다.

<br/>

### with ❓

---

정적 스코프를 속이는 자바스크립트의 또 다른 기능은 `with` 입니다.

- `with` 를 설명할 수 있는 효과적인 방법은 여러가지가 있지만 여기서는 **정적 스코프와 상호 작용하고 정적 스코프에 영향을 미치는 관점**에서 설명하겠습니다.
- `with` 는 일반적으로 **매번 객체 참조를 반복하지 않고, 객체에 대해 여러 프로퍼티 참조를 만들기 위한 약어**로 설명할 수 있습니다.

예를 들어,

```ts
var obj = {
  a: 1,
  b: 2,
  c: 3,
};
// more "tedious" to repeat "obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;
// "easier" shorthand
with (obj) {
  a = 3;
  b = 4;
  c = 5;
}
```

그러나 여기에는 객체 프로퍼티 접근을 위한 편리한 약칭의 기능보다 더 많은 동작이 발생합니다.

```ts
function foo(obj) {
  with (obj) {
    a = 2;
  }
}

var o1 = { a: 3 };

var o2 = { b: 3 };

foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); // undefined
console.log(a); // 2—Oops, leaked global!
```

해당 코드에서는 두 개의 객체 `o1` 와 `o2` 가 생성됩니다.

- 하나는 프로퍼티가 있고, 하나는 프로퍼티가 없습니다.
- `foo()` 함수는 객체 `obj` 를 인자로 받아 참조를 통해 `with (obj) {}` 를 호출합니다.
- `with` 블록 내에서 변수 `a` 에 대한 일반적인 정적 참조로 보이는 것을, 실제로는 LHS 참조로 만들어 `a` 에 값 `2` 를 할당합니다.

`o1` 을 전달할 때 `a = 2` 할당은 `o1.a` 프로퍼티를 찾고 후속 `console.log(o1.a)` 문에 반영된 대로 값 `2` 를 할당합니다.

- 그러나 `o2` 를 전달할 때 **프로퍼티가 없기 때문에**, 그러한 프로퍼티가 생성되지 않고 **`o2` 는 정의되지 않은 상태로 유지**됩니다.
  - 근데 **`a = 2` 할당에 의해 전역 변수가 생성되었다는 사이드 이펙트**가 있었습니다.

`with` 문은 0개 이상의 속성이 있는 객체를 받아 **해당 객체를 완전히 별개의 정적 스코프인 것처럼 취급**하므로 **객체의 프로퍼티는 해당 스코프에서 정적으로 정의된 식별자로 처리**됩니다.

> **Note 🗒️**
>
> `with` 블록이 객체를 정적 스코프처럼 취급하더라도 **`with` 블록 내부의 일반적인 `var` 선언은 `with` 블록이 아니라 포함하는 함수 스코프로 지정**됩니다.

`eval()` 함수는 하나 이상의 선언이 포함된 코드 문자열을 사용하는 경우에 기존 정적 스코프를 수정할 수 있지만, with` 문은 **실제로 전달한 객체에서 완전히 새로운 정적 스코프를 생성합니다.**

- 이런 식으로 이해하면 `o1` 을 전달할 때 `with` 문에 의해 선언된 스코프는 `o1` 이었고 해당 스코프에는 `o1.a` 속성에 해당하는 식별자가 있습니다.
- 그러나 `o2` 를 스코프로 사용했을 때 **그러한 식별자가 없었기에 LHS 참조의 일반적인 규칙이 발생했습니다.**

`o2` 의 스코프에도 `foo()` 의 스코프에도, 전역 스코프에도 찾을 수 있는 식별자가 없기에 **`a = 2` 가 실행될 때 암묵적으로 전역 변수가 생성됩니다.**

> **Note 🗒️**
>
> 사용하지 않는 것이 좋을 뿐만 아니라 **`eval()` 과 `with` 모두 `"strict mode"` 의 영향(제한)을 받습니다.**

<br/>

### Performance ❓

---

`eval()` 및 `with` 속임수 모두 **런타임에서 코드 작성 시간에 정의된 정적 스코프를 수정하거나 생성합니다.**

위 두 가지가 더 정교한 기능과 코딩에서의 유연성을 제공하기에 좋은 기능이라고 생각할 수 있지만 **아닙니다.**

자바스크립트 엔진에는 **컴파일 단계에서 수행하는 여러 성능 최적화**가 있습니다. 이들 중 일부는 **렉싱할 때 본질적으로 코드를 정적으로 분석**하고 모든 변수 및 함수 선언이 있는 위치를 미리 결정할 수 있어, **실행 중에 식별자를 확인하는데 드는 리소스를 줄일 수 있습니다.**

그러나 엔진이 코드에서 `eval()` 또는 `with` 를 찾으면 본질적으로 **식별자 위치에 대한 모든 인지가 유효하지 않다고 가정해야 합니다.** **정적 스코프를 수정**하거나 참조할 새 정적 스코프를 만들기 위해 **전달할 객체의 내용을 수정합니다.**

다시 말해, 비관적인 의미에서 `eval()` 과 `with()` 가 있는 경우, 수행하는 **최적화의 대부분은 무의미하므로** 최적화를 전혀 수행하지 않습니다. 이는 위 두 가지만으로도 코드를 느리게 만드는 요인이 될 수 있다는 것입니다.

**결론적으로 엔진은 사이드 이펙트를 줄여야 하고, 최적화 없이는 코드가 더 느리게 실행되는 사실 또한 피할 수 없습니다.**

<br/>

## Review ❕

---

- **정적 스코프**는 스코프가 **함수 선언 위치**, 즉 **코드 작성 시간에 따라 결정**됨을 의미합니다.
- **컴파일의 렉싱 단계**는 기본적으로 모든 식별자가 선언된 위치와 방법을 알 수 있으므로 **실행 중에 참조되는 방법을 예측할 수 있습니다.**
- 자바스크립트의 두 가지 메커니즘인 `eval()` 과 `with` 문은 정적 스코프를 속일 수 있습니다.
- `eval()` 은 **문자열을 코드로 분석**하여 런타임에 기존 정적 스코프를 수정할 수 있습니다.
- `with` 는 본질적으로 **객체 참조를 스코프로 처리**하고 해당 객체의 프로퍼티를 스코프가 지정된 식별자로 처리하여 **런타임 단계에서 완전히 새로운 정적 스코프를 만듭니다.**
- 이러한 메커니즘의 단점은 엔진이 이러한 최적화가 유효하지 않을 것이라고 가정하기 때문에 **스코프 조회와 관련하여 컴파일 단계에서 진행하는 최적화를 무력화시킵니다.**
