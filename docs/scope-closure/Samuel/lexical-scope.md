---
title: Chapter 2. Lexical Scope
tags: [scope, lexical]
sidebar_position: 2
---

<br />

## 들어가며 🏃

---

1장에서 우리는 **스코프**를 **엔진**이 **식별자로 변수를 조회**하고 **현재 스코프 또는 그 안에 포함된 중첩 범위에서 찾는 방법을 제어하는 규칙 집합**으로 정의했습니다.

스코프 작동 방식에는 **두 가지 주요 모델**이 있습니다.

- 하나는 **정적 스코프(Lexical scope)**로 대부분의 프로그래밍 언어에서 사용되는 가장 일반적인 경우입니다.
- 다른 모델은 **동적 스코프(Dynamic scope)**로 일부 언어에서 여전히 사용되는 다른 모델입니다.

> 동적 스코프는 부록 A에서 다룹니다. 여기서는 자바스크립트가 사용하는 스코프 모델인 **정적 스코프**와의 대조를 위해서만 언급합니다.

<br/>

## Lex-time ❕

---

> **TL;DR 🔖**
>
> -

<br />

1장에서 논의한 바와 같이 일반적인 언어 컴파일러의 첫 번째 단계는 **렉싱(일명 토큰화)**입니다.

- 기억한다면, **렉싱 프로세스**는 **소스 코드 문자의 문자열을 검사**하고 일부 **상태 기반 구문 분석의 결과로 토큰에 의미론적인 태그 등을 할당**합니다.
  - 정적 스코프가 무엇이며 어원이 무엇인지에 대해 이해하기 위한 기초를 제공하는 것은 이 개념입니다.
  - 다시 정의하자면, 정적 스코프는 **렉싱할 때 정의되는 범위**입니다.
    - 이는 **코드 작성을 할 때, 변수와 블록이 작성된 위치를 기반**으로 하기에 렉서가 코드를 처리할 때 **대부분 고정됩니다.**

> **Note 🗒️**
>
> 우리는 정적 스코프를 속이는 몇 가지 방법이 있다는 것을 조금 후에 알게 될 것입니다. 그렇기에 렉서가 지나간 후에 이를 수정하지만 이러한 것들은 눈살을 찌푸리게 합니다. 정적 스코프를 **사실상 정적 전용으로 취급**하여 본질적으로 전적으로 **코드 작성 시간 기준으로 처리하는 것이 모범 사례로 간주됩니다.**

```js
function foo(a) {
  var b = a * 2;
  function bar(c) {
    console.log(a, b, c);
  }
  bar(b * 3);
}

foo(2); // 2, 4, 12
```

해당 코드에는 세 가지 중첩 범위가 있습니다. 이러한 스코프를 서로 내부의 버블로 생각하는 것이 도움이 될 수 있습니다.

![bubble](/img/samuel/lexical-scope/bubble.png)

- 버블 1은 **전역 스코프를 포함**하며 그 안에 **`foo` 라는 하나의 식별자만 있습니다.**
- 버블 2는 `a`, `bar` 및 `b` 의 **세 가지 식별자를 포함하는 `foo` 의 범위를 포함합니다.**
- 버블 3은 `bar` 의 스코프를 포함하여 **하나의 식별자만 포함합니다.**

스코프 버블은 스코프 블록이 쓰여진 위치, 다른 블럭 안에 중첩된 스코프 등으로 정의됩니다.

> 다음 장에서 다양한 스코프 단위에 대해 논의할 것이지만 지금은 **각 함수가 새로운 스코프를 생성한다고 가정하겠습니다.**

`bar` 에 대한 버블은 `foo` 에 대한 버블 내로 완전히 포함되어 있습니다.

- 왜냐하면, 그것이 **우리가 `bar` 함수를 정의하기로 선택한 곳**이기 때문입니다.
  - 이러한 중첩된 버블은 **엄격하게 중첩되어 있습니다.**
    - 버블의 경계를 넘을 수 있는 벤 다이어그램에 대해 이야기하는 것이 아닙니다.
  - 다시 말해, 어떤 함수도 두 개의 상위 함수 각각의 내부에 부분적으로 있을 수 없는 것처럼 **일부 함수에 대한 버블은 두 가지의 다른 외부 스코프 버블 안에 동시에(부분적으로) 존재할 수 없습니다.**

<br/>

### Look-ups ❓

---

이러한 **스코프 버블의 구조**와 **상대적 배치**는 **엔진이 식별자를 찾기 위해 찾아야 하는 모든 위치를 완전히 설명합니다.**

- 이전 소스 코드에서 엔진은 `console.log()` 문을 실행하고 **세 가지의 참조 변수 `a`, `b`, `c` 를 찾습니다.**
  - 먼저, 가장 안쪽의 스코프 버블인 **`bar()` 함수의 스코프**부터 시작합니다.
  - **해당 스코프에서 찾을 수 없으므로,** 가장 가까운 스코프 버블인 **`foo()` 스코프로 이동합니다.**
  - `a` 를 그곳에서 찾고 이를 사용하며, `b` 도 마찬가지입니다.
  - 그러나 `c` 는 `bar()` 내부를 찾습니다.

`bar()` 내부와 `foo()` 내부 모두에 `c` 가 있었다면 `console.log()` 문은 `foo()` 가 아닌 `bar()` 에 있는 것을 찾아 사용했을 것입니다.

- **스코프 조회**는 **첫 번째 일치 항목을 찾으면 중단합니다.**
  - 중첩된 스코프의 **여러 레이어에 동일한 식별자 이름을 지정할 수 있습니다.**
  - 이를 **새도잉(shadowing)**이라고 합니다.
  - 섀도잉에 관계없이 **스코프 조회**는 항상 해당 시간에 실행되는 **가장 안쪽 범위에서 시작하여 첫 번째 일치까지 바깥쪽(위쪽)으로 작동하고 중단합니다.**

> **Note 🗒️**
>
> 전역 변수는 자동으로 전역 객체(브라우저 창 등)의 속성이기도 하므로 **정적 이름으로 직접 전역 변수를 참조하는 것이 아니라 전역 객체의 프로퍼티 참조로 간접적으로 전역 변수를 참조할 수 있습니다.**
>
> ```js
> window.a;
> ```
>
> 이 기술을 사용하면 **섀도잉으로 인해 접근할 수 없는 전역 변수에 대한 접근을 제공합니다.** 그러나 비전역 섀도우 변수에는 접근할 수 없습니다.

함수가 어디에서 호출되는지 또는 호출 방법에 관계없이 해당 함수의 **정적 스코프는 함수가 선언된 위치에 의해서만 정의됩니다.**

- 정적 스코프 조회 프로세스는 `a`, `b` 및 `c` 와 같은 **1급 식별자에만 적용됩니다.**
- 코드 조각에 `foo.bar.baz` 에 대한 참조가 있는 경우 `foo` 식별자를 찾는데 정적 스코프 조회가 적용되지만, 해당 변수를 찾으면 객체 프로퍼티 접근 규칙이 대신하여 `bar` 및 `baz` 프로퍼티를 해결합니다.
