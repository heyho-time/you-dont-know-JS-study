---
title: Chapter 1. What Is Scope?
tags: [scope]
sidebar_position: 1
---

<br />

## 들어가며 🏃

---

대부분의 프로그래밍 언어의 가장 기본적인 패러다임 중 하나는 **변수에 값을 저장**하고 나중에 **해당 값을 검색하거나 수정**하는 기능입니다.

- 사실 값을 저장하고 가져오는 기능은 **프로그램 상태를 제공하는 것**입니다.
- 여기서 중요한 부분은 **그 변수는 어디에 저장되고 어디서 찾는 지에 대한 내용**입니다.

위 질문에 대답하기 위해선 **잘 정의된 규칙 집합의 필요성**을 나타내고, 자바스크립트에선 그 규칙 집합을 **스코프**라고 정의할 것입니다.

<br />

## Compiler Theory ❕

---

> **TL;DR 🔖**
>
> - 자바스크립트는 인터프리터 방식으로 실행되지만 **컴파일**을 진행합니다.
> - 컴파일 과정은 **토크나이징, 렉싱, 파싱, 코드 생성의 과정**으로 구분됩니다.

<br />

자바스크립트가 동적 혹은 인터프리터 언어의 일반적인 범주에 속한다는 사실에도 불구하고 실제로 **자바스크립트는 컴파일된 언어**입니다.

> 이에 대한 [**간단한 포스팅**](https://you-dont-know-js-study.vercel.app/blog/week-1/samuel)을 진행했습니다! 필요하신 분들은 참고해주세요 😊

- 그러나 전통적인 컴파일 언어처럼 **사전에 잘 컴파일되지 않으며**, **컴파일 결과를 다양한 분산 시스템 간에 이식할 수도 없습니다.**
- 그럼에도 불구하고 자바스크립트 엔진은 우리가 일반적으로 알고 있는 것보다 더 정교한 방식으로 **기존 컴파일러 언어와 동일한 단계를 많이 수행**합니다.

컴파일 언어의 프로세스에서 프로그램은 일반적으로 실행되기 전에 **컴파일**이라고 하는 세 단계를 거칩니다.

<br />

#### Tokenizing/Lexing

---

문자열을 **토큰(token)**이라고 하는 의미 있는(언어에 대한) **청크**로 나눕니다.

> **Chunk**의 사전적 정의 📚
>
> 분야별 의미가 있지만 **프로그램 단위에서 관리하는 정보 조각**의 의미가 가장 적절하다 판단됩니다. 😉
>
> [**참고 링크 : 위키백과**](<https://en.wikipedia.org/wiki/Chunk_(information)>) 🔖

예를 들어, `var a = 2;` 라는 프로그램이 있다고 가정해봅시다.

- 해당 프로그램은 `var`, `a`, `=`, `2`, `;` 와 같은 토큰으로 나눌 수 있습니다.
- **공백**은 **의미 유무에 따라 토큰 지속 여부**가 정해집니다.

> **Note 🗒️**
>
> **토큰화(Tokenizing)와 렉싱(Lexing)의 차이점**은 이러한 토큰이 **상태 저장/비저장 방식으로 식별되는지에 대한 구분**에 중점을 둡니다. 간단히 말해, 토크나이저가 고유한 토큰으로 간주되어야 하는지를 파악하기 위해 상태 저장 구문 분석 규칙을 호출하는 경우 **이는 렉싱이 됩니다.**

솔직히 위 번역을 보고도 이해가 잘 되지 않아 아래와 같이 별도로 이해를 정리해봤습니다.

> **토크나이저(Tokenizer)와 렉서(Lexer) 그리고 파서(Parser)** 📓
>
> ![diff-tlp](/img/samuel/what-is-scope/difference-of-tlp.png)
>
> <p style={{fontSize: '0.85rem', paddingBottom: '0.5rem'}}>가장 이해가 쉬웠던 내용</p>
> 토크나이저와 렉싱의 차이점만을 구분지어보기 위함이었지만, 찾다보니 같이 나오는 개념이기도 하고 이어서 금방 나올 개념이기에 <strong>파서</strong>도 함께 정의해보고자 합니다.
>
> 위 내용을 번역하면 <strong>토크나이저</strong>란 <strong>텍스트를 단어와 같은 더 작은 단위로 나누는 역할</strong>을 하며 <strong>문자, 음절, 문장 등으로 토큰화하는 것도 가능</strong>하다고 합니다. <strong>렉서</strong>는 동일한 작업을 수행하지만, <strong>각 토큰에 추가 정보를 첨부하는 역할</strong>을 한다고 합니다. 마지막으로 <strong>파서</strong>는 일반적으로 렉서의 출력을 사용하고 <strong>파스 트리(parse tree)를 구성</strong>합니다.

<br />

#### Parsing

---

**토큰 스트림(배열)을 가져와** 프로그램의 문법 구조를 집합적으로 나타내는 **중첩 요소 트리로 변환하는 역할**을 하고, 해당 트리를 **AST(Abstract Syntax Tree : 추상 구문 트리)**라고 합니다.

예를 들어, `var a = 2;` 에 대한 트리는 **VariableDeclaration이라는 최상위 노드**에서 시작하여 해당 노드는 **Identifier(값이 `a`)라는 자식 노드**와 **NumericLiteral(값이 `2`)을 자식으로 갖는 AssignmentExpression라는 자식 노드**를 갖습니다.

<br />

#### Code-Generation

---

AST를 가져와 실행 가능한 코드로 만드는 과정은 **언어와 대상 플랫폼 등에 따라 크게 다릅니다.**

- 간단하게 설명하자면, `a` 라는 변수(메모리 예약)를 실제로 생성하는 **일련의 기계 명령어로 변환한 다음 `a` 에 값을 저장**합니다.

> **Note 🗒️**
>
> 엔진이 시스템 리소스를 관리하는 방법에 대한 세부 사항은 우리가 파헤칠 것보다 더 깊으므로 **엔진이 필요에 따라 변수를 생성하고 저장할 수 있다는 사실**을 당연하게 넘기고 넘어갈 것입니다.

자바스크립트 엔진은 대부분의 다른 언어 컴파일러와 마찬가지로 이 세 단계보다 훨씬 더 복잡합니다.

- 예를 들어, 파싱(Parsing)과 코드 생성(Code-generation)의 과정에서 **중복 요소 축소** 등을 포함하여 **실행 성능을 최적화하는 단계**가 분명히 있습니다.
- 우선 자바스크립트 엔진은 다른 언어와 마찬가지로 **사전 빌드 단계에서 컴파일이 발생하지 않기 때문에**, 최적화할 충분한 시간을 갖지 못합니다.
- 자바스크립트의 경우 **코드 실행 전 아주 근소한 시간 동안 컴파일을 실행**합니다.
- 가장 빠른 성능을 보장하기 위해 자바스크립트 엔진은 여기에서 논의하는 **스코프**를 넘어서는 **모든 종류의 트릭(예를 들어, 지연 컴파일 및 핫 재컴파일 등)을 사용**합니다.

<br/>

## Understanding Scope ❕

---

> **TL;DR 🔖**
>
> -

<br />
