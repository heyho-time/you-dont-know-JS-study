---
title: Chapter 1. What Is Scope?
tags: [scope]
sidebar_position: 1
---

<br />

## 들어가며 🏃

---

대부분의 프로그래밍 언어의 가장 기본적인 패러다임 중 하나는 **변수에 값을 저장**하고 나중에 **해당 값을 검색하거나 수정**하는 기능입니다.

- 사실 값을 저장하고 가져오는 기능은 **프로그램 상태를 제공하는 것**입니다.
- 여기서 중요한 부분은 **그 변수는 어디에 저장되고 어디서 찾는 지에 대한 내용**입니다.

위 질문에 대답하기 위해선 **잘 정의된 규칙 집합의 필요성**을 나타내고, 자바스크립트에선 그 규칙 집합을 **스코프**라고 정의할 것입니다.

<br />

## Compiler Theory ❕

---

> **TL;DR 🔖**
>
> - 자바스크립트는 인터프리터 방식으로 실행되지만 **컴파일**을 진행합니다.
> - 컴파일 과정은 **토크나이징, 렉싱, 파싱, 코드 생성의 과정**으로 구분됩니다.

<br />

자바스크립트가 동적 혹은 인터프리터 언어의 일반적인 범주에 속한다는 사실에도 불구하고 실제로 **자바스크립트는 컴파일된 언어**입니다.

> 이에 대한 [**간단한 포스팅**](https://you-dont-know-js-study.vercel.app/blog/week-1/samuel)을 진행했습니다! 필요하신 분들은 참고해주세요 😊

- 그러나 전통적인 컴파일 언어처럼 **사전에 잘 컴파일되지 않으며**, **컴파일 결과를 다양한 분산 시스템 간에 이식할 수도 없습니다.**
- 그럼에도 불구하고 자바스크립트 엔진은 우리가 일반적으로 알고 있는 것보다 더 정교한 방식으로 **기존 컴파일러 언어와 동일한 단계를 많이 수행**합니다.

컴파일 언어의 프로세스에서 프로그램은 일반적으로 실행되기 전에 **컴파일**이라고 하는 세 단계를 거칩니다.

<br />

#### Tokenizing/Lexing

---

문자열을 **토큰(token)**이라고 하는 의미 있는(언어에 대한) **청크**로 나눕니다.

> **Chunk**의 사전적 정의 📚
>
> 분야별 의미가 있지만 **프로그램 단위에서 관리하는 정보 조각**의 의미가 가장 적절하다 판단됩니다. 😉
>
> [**참고 링크 : 위키백과**](<https://en.wikipedia.org/wiki/Chunk_(information)>) 🔖

예를 들어, `var a = 2;` 라는 프로그램이 있다고 가정해봅시다.

- 해당 프로그램은 `var`, `a`, `=`, `2`, `;` 와 같은 토큰으로 나눌 수 있습니다.
- **공백**은 **의미 유무에 따라 토큰 지속 여부**가 정해집니다.

> **Note 🗒️**
>
> **토큰화(Tokenizing)와 렉싱(Lexing)의 차이점**은 이러한 토큰이 **상태 저장/비저장 방식으로 식별되는지에 대한 구분**에 중점을 둡니다. 간단히 말해, 토크나이저가 고유한 토큰으로 간주되어야 하는지를 파악하기 위해 상태 저장 구문 분석 규칙을 호출하는 경우 **이는 렉싱이 됩니다.**

솔직히 위 번역을 보고도 이해가 잘 되지 않아 아래와 같이 별도로 이해를 정리해봤습니다.

> **토크나이저(Tokenizer)와 렉서(Lexer) 그리고 파서(Parser)** 📓
>
> ![diff-tlp](/img/samuel/what-is-scope/difference-of-tlp.png)
>
> <p style={{fontSize: '0.85rem', paddingBottom: '0.5rem'}}>가장 이해가 쉬웠던 내용</p>
> 토크나이저와 렉싱의 차이점만을 구분지어보기 위함이었지만, 찾다보니 같이 나오는 개념이기도 하고 이어서 금방 나올 개념이기에 <strong>파서</strong>도 함께 정의해보고자 합니다.
>
> 위 내용을 번역하면 <strong>토크나이저</strong>란 <strong>텍스트를 단어와 같은 더 작은 단위로 나누는 역할</strong>을 하며 <strong>문자, 음절, 문장 등으로 토큰화하는 것도 가능</strong>하다고 합니다. <strong>렉서</strong>는 동일한 작업을 수행하지만, <strong>각 토큰에 추가 정보를 첨부하는 역할</strong>을 한다고 합니다. 마지막으로 <strong>파서</strong>는 일반적으로 렉서의 출력을 사용하고 <strong>파스 트리(parse tree)를 구성</strong>합니다.

<br />

#### Parsing

---

**토큰 스트림(배열)을 가져와** 프로그램의 문법 구조를 집합적으로 나타내는 **중첩 요소 트리로 변환하는 역할**을 하고, 해당 트리를 **AST(Abstract Syntax Tree : 추상 구문 트리)**라고 합니다.

예를 들어, `var a = 2;` 에 대한 트리는 **VariableDeclaration이라는 최상위 노드**에서 시작하여 해당 노드는 **Identifier(값이 `a`)라는 자식 노드**와 **NumericLiteral(값이 `2`)을 자식으로 갖는 AssignmentExpression라는 자식 노드**를 갖습니다.

<br />

#### Code-Generation

---

AST를 가져와 실행 가능한 코드로 만드는 과정은 **언어와 대상 플랫폼 등에 따라 크게 다릅니다.**

- 간단하게 설명하자면, `a` 라는 변수(메모리 예약)를 실제로 생성하는 **일련의 기계 명령어로 변환한 다음 `a` 에 값을 저장**합니다.

> **Note 🗒️**
>
> 엔진이 시스템 리소스를 관리하는 방법에 대한 세부 사항은 우리가 파헤칠 것보다 더 깊으므로 **엔진이 필요에 따라 변수를 생성하고 저장할 수 있다는 사실**을 당연하게 넘기고 넘어갈 것입니다.

자바스크립트 엔진은 대부분의 다른 언어 컴파일러와 마찬가지로 이 세 단계보다 훨씬 더 복잡합니다.

- 예를 들어, 파싱(Parsing)과 코드 생성(Code-generation)의 과정에서 **중복 요소 축소** 등을 포함하여 **실행 성능을 최적화하는 단계**가 분명히 있습니다.
- 우선 자바스크립트 엔진은 다른 언어와 마찬가지로 **사전 빌드 단계에서 컴파일이 발생하지 않기 때문에**, 최적화할 충분한 시간을 갖지 못합니다.
- 자바스크립트의 경우 **코드 실행 전 아주 근소한 시간 동안 컴파일을 실행**합니다.
- 가장 빠른 성능을 보장하기 위해 자바스크립트 엔진은 여기에서 논의하는 **스코프**를 넘어서는 **모든 종류의 트릭(예를 들어, 지연 컴파일 및 핫 재컴파일 등)을 사용**합니다.

<br/>

## Understanding Scope ❕

---

> **TL;DR 🔖**
>
> -

<br />

스코프 학습의 접근 방식은 **대화의 관점**에서 프로세스를 생각하는 것입니다.

> 누가 대화를 하는 지에 대해 알아봅시다. 🔍

<br/>

### The Cast ❓

---

프로그램 `var a = 2;` 를 처리하기 위해 상호 작용하는 캐릭터의 출연진들을 만나서 해당 대화를 이해해봅시다.

<br/>

#### Engine

---

자바스크립트 프로그램의 처음부터 끝가지 **컴파일 및 실행**을 담당합니다.

#### Compiler

---

엔진의 친구 중 한 명으로, **구문 분석 및 코드 생성의 모든 실질적인 사항**을 처리합니다.

#### Scope

---

엔진의 또 다른 친구로, **선언된 모든 식별자(변수)의 조회 목록을 수집 및 유지 관리**하고, **현재 실행 중인 코드에서** 이러한 **식별자에 엑세스할 수 있는 방법에 대해 엄격한 규칙을 적용**합니다.

자바스크립트가 작동하는 방식을 완전히 이해하기 위해선 엔진과 친구들처럼 생각하고 질문에 대답해야 합니다.

<br/>

### Back and Forth ❓

---

`var a = 2;` 라는 프로그램을 보면 **명령문**으로 생각할 가능성이 크지만, 엔진은 그렇지 않습니다.

- 실제로 엔진은 두 가지의 별개 명령문을 봅니다.
  - 하나는 **컴파일러가 컴파일 중에 처리**하고 다른 하나는 **엔진이 실행 중에 처리**합니다.

따라서 엔진과 친구들이 `var a = 2;` 프로그램에 접근하는 방법을 분석해보겠습니다.

- 컴파일러가 해당 프로그램으로 할 첫 번째 일은 **렉싱**을 수행하여 **토큰으로 분해**한 다음 **트리로 파싱**하는 것입니다.
- 그러나 컴파일러가 **코드 생성**에 도달하면 이 프로그램을 가정한 것과 다소 다르게 처리합니다.
  - 합리적인 가정은 **컴파일러가 다음 의사 코드로 요약될 수 있는 코드를 생성한다는 것**입니다.

> **의사코드(Pseudocode) 📓**
>
> 간단히 **의사코드**라는 어휘에 대해 짚고 넘어갑시다. 사전적 정의는 **프로그램을 작성할 때 각 모듈이 작동하는 로직을 표현하기 위한 언어**라고 합니다.
>
> 일반적인 언어로 코드를 흉내내어 알고리즘을 써놓은 코드를 말한다고 하네요.

하지만 불행히도 가정은 정확하지 않으며, 컴파일러는 대신 다음과 같이 진행합니다.

- `var a` 를 만나면 컴파일러는 **스코프의 특정 범위 컬렉션에 대해 변수 `a` 가 이미 존재하는지 확인하도록 요청**합니다.
  - 존재한다면 컴파일러는 이 선언을 무시하고 계속 진행하고, 그렇지 않다면 컴파일러는 스코프에 다음을 선언하도록 요청합니다.
- 컴파일러는 **엔진이 나중에 실행할 코드를 생성**하여 **`a = 2` 할당을 처리**합니다.
  - 엔진이 실행하는 코드가 **스코프의 현재 범위 컬렉션에서 액세스할 수 있는 변수**라면 엔진은 해당 변수를 사용합니다
  - 그렇지 않다면 **엔진은 다른 곳(중첩 범위)을 찾습니다.**
  - 그리고 엔진이 변수를 찾았을 때, `2` 를 할당합니다.

<br/>

> **요약! 🔖**
>
> 변수 할당에 대한 두 가지 고유한 작업이 수행됩니다.
>
> 첫째, **컴파일러는 현재 범위에서 변수를 선언(이전에 선언되지 않은 경우)**하고, <br/> 두 번째는 **실행할 때 엔진이 범위에서 변수를 찾아 변수를 찾은 경우 할당**합니다.
