---
title: Chapter 1. What Is Scope?
tags: [scope, compile, tokenize, parse, engine]
sidebar_position: 1
---

<br />

## 들어가며 🏃

---

대부분의 프로그래밍 언어의 가장 기본적인 패러다임 중 하나는 **변수에 값을 저장**하고 나중에 **해당 값을 검색하거나 수정**하는 기능입니다.

- 사실 값을 저장하고 가져오는 기능은 **프로그램 상태를 제공하는 것**입니다.
- 여기서 중요한 부분은 **그 변수는 어디에 저장되고 어디서 찾는 지에 대한 내용**입니다.

위 질문에 대답하기 위해선 **잘 정의된 규칙 집합의 필요성**을 나타내고, 자바스크립트에선 그 규칙 집합을 **스코프**라고 정의할 것입니다.

<br />

## Compiler Theory ❕

---

> **TL;DR 🔖**
>
> - 자바스크립트는 인터프리터 방식으로 실행되지만 **컴파일**을 진행합니다.
> - 컴파일 과정은 **토크나이징, 렉싱, 파싱, 코드 생성의 과정**으로 구분됩니다.

<br />

자바스크립트가 동적 혹은 인터프리터 언어의 일반적인 범주에 속한다는 사실에도 불구하고 실제로 **자바스크립트는 컴파일된 언어**입니다.

> 이에 대한 [**간단한 포스팅**](https://you-dont-know-js-study.vercel.app/blog/week-1/samuel)을 진행했습니다! 필요하신 분들은 참고해주세요 😊

- 그러나 전통적인 컴파일 언어처럼 **사전에 잘 컴파일되지 않으며**, **컴파일 결과를 다양한 분산 시스템 간에 이식할 수도 없습니다.**
- 그럼에도 불구하고 자바스크립트 엔진은 우리가 일반적으로 알고 있는 것보다 더 정교한 방식으로 **기존 컴파일러 언어와 동일한 단계를 많이 수행**합니다.

컴파일 언어의 프로세스에서 프로그램은 일반적으로 실행되기 전에 **컴파일**이라고 하는 세 단계를 거칩니다.

<br />

#### Tokenizing/Lexing

---

문자열을 **토큰(token)**이라고 하는 의미 있는(언어에 대한) **청크**로 나눕니다.

> **Chunk**의 사전적 정의 📚
>
> 분야별 의미가 있지만 **프로그램 단위에서 관리하는 정보 조각**의 의미가 가장 적절하다 판단됩니다. 😉
>
> [**참고 링크 : 위키백과**](<https://en.wikipedia.org/wiki/Chunk_(information)>) 🔖

예를 들어, `var a = 2;` 라는 프로그램이 있다고 가정해봅시다.

- 해당 프로그램은 `var`, `a`, `=`, `2`, `;` 와 같은 토큰으로 나눌 수 있습니다.
- **공백**은 **의미 유무에 따라 토큰 지속 여부**가 정해집니다.

> **Note 🗒️**
>
> **토큰화(Tokenizing)와 렉싱(Lexing)의 차이점**은 이러한 토큰이 **상태 저장/비저장 방식으로 식별되는지에 대한 구분**에 중점을 둡니다. 간단히 말해, 토크나이저가 고유한 토큰으로 간주되어야 하는지를 파악하기 위해 상태 저장 구문 분석 규칙을 호출하는 경우 **이는 렉싱이 됩니다.**

솔직히 위 번역을 보고도 이해가 잘 되지 않아 아래와 같이 별도로 이해를 정리해봤습니다.

> **토크나이저(Tokenizer)와 렉서(Lexer) 그리고 파서(Parser)** 📓
>
> ![diff-tlp](/img/samuel/what-is-scope/difference-of-tlp.png)
>
> <p style={{ fontSize: "0.85rem", paddingBottom: "0.5rem" }}>
>   가장 이해가 쉬웠던 내용
> </p>
> 토크나이저와 렉싱의 차이점만을 구분지어보기 위함이었지만, 찾다보니 같이 나오는
> 개념이기도 하고 이어서 금방 나올 개념이기에 <strong>파서</strong>도 함께
> 정의해보고자 합니다.
>
> 위 내용을 번역하면 <strong>토크나이저</strong>란 <strong>텍스트를 단어와 같은 더 작은 단위로 나누는 역할</strong>을 하며 <strong>문자, 음절, 문장 등으로 토큰화하는 것도 가능</strong>하다고 합니다. <strong>렉서</strong>는 동일한 작업을 수행하지만, <strong>각 토큰에 추가 정보를 첨부하는 역할</strong>을 한다고 합니다. 마지막으로 <strong>파서</strong>는 일반적으로 렉서의 출력을 사용하고 <strong>파스 트리(parse tree)를 구성</strong>합니다.

<br />

#### Parsing

---

**토큰 스트림(배열)을 가져와** 프로그램의 문법 구조를 집합적으로 나타내는 **중첩 요소 트리로 변환하는 역할**을 하고, 해당 트리를 **AST(Abstract Syntax Tree : 추상 구문 트리)**라고 합니다.

예를 들어, `var a = 2;` 에 대한 트리는 **VariableDeclaration이라는 최상위 노드**에서 시작하여 해당 노드는 **Identifier(값이 `a`)라는 자식 노드**와 **NumericLiteral(값이 `2`)을 자식으로 갖는 AssignmentExpression라는 자식 노드**를 갖습니다.

<br />

#### Code-Generation

---

AST를 가져와 실행 가능한 코드로 만드는 과정은 **언어와 대상 플랫폼 등에 따라 크게 다릅니다.**

- 간단하게 설명하자면, `a` 라는 변수(메모리 예약)를 실제로 생성하는 **일련의 기계 명령어로 변환한 다음 `a` 에 값을 저장**합니다.

> **Note 🗒️**
>
> 엔진이 시스템 리소스를 관리하는 방법에 대한 세부 사항은 우리가 파헤칠 것보다 더 깊으므로 **엔진이 필요에 따라 변수를 생성하고 저장할 수 있다는 사실**을 당연하게 넘기고 넘어갈 것입니다.

자바스크립트 엔진은 대부분의 다른 언어 컴파일러와 마찬가지로 이 세 단계보다 훨씬 더 복잡합니다.

- 예를 들어, 파싱(Parsing)과 코드 생성(Code-generation)의 과정에서 **중복 요소 축소** 등을 포함하여 **실행 성능을 최적화하는 단계**가 분명히 있습니다.
- 우선 자바스크립트 엔진은 다른 언어와 마찬가지로 **사전 빌드 단계에서 컴파일이 발생하지 않기 때문에**, 최적화할 충분한 시간을 갖지 못합니다.
- 자바스크립트의 경우 **코드 실행 전 아주 근소한 시간 동안 컴파일을 실행**합니다.
- 가장 빠른 성능을 보장하기 위해 자바스크립트 엔진은 여기에서 논의하는 **스코프**를 넘어서는 **모든 종류의 트릭(예를 들어, 지연 컴파일 및 핫 재컴파일 등)을 사용**합니다.

<br />

## Understanding Scope ❕

---

> **TL;DR 🔖**
>
> - 스코프를 이해하기 위해 대화를 한다는 관점에서 프로세스를 생각할 수 있고, 이에 대한 출연진은 **엔진, 컴파일러, 스코프** 등이 있습니다.
> - 컴파일러는 **엔진이 실행하기 위한 코드를 생성**하고 엔진과 스코프는 **참조(LHS, RHS)**를 통해 변수를 찾아와 할당하거나 알맞은 메서드를 호출합니다.

<br />

스코프 학습의 접근 방식은 **대화의 관점**에서 프로세스를 생각하는 것입니다.

> 누가 대화를 하는 지에 대해 알아봅시다. 🔍

<br />

### The Cast ❓

---

프로그램 `var a = 2;` 를 처리하기 위해 상호 작용하는 캐릭터의 출연진들을 만나서 해당 대화를 이해해봅시다.

<br />

#### Engine

---

자바스크립트 프로그램의 처음부터 끝가지 **컴파일 및 실행**을 담당합니다.

#### Compiler

---

엔진의 친구 중 한 명으로, **구문 분석 및 코드 생성의 모든 실질적인 사항**을 처리합니다.

#### Scope

---

엔진의 또 다른 친구로, **선언된 모든 식별자(변수)의 조회 목록을 수집 및 유지 관리**하고, **현재 실행 중인 코드에서** 이러한 **식별자에 엑세스할 수 있는 방법에 대해 엄격한 규칙을 적용**합니다.

자바스크립트가 작동하는 방식을 완전히 이해하기 위해선 엔진과 친구들처럼 생각하고 질문에 대답해야 합니다.

<br />

### Back and Forth ❓

---

`var a = 2;` 라는 프로그램을 보면 **명령문**으로 생각할 가능성이 크지만, 엔진은 그렇지 않습니다.

- 실제로 엔진은 두 가지의 별개 명령문을 봅니다.
  - 하나는 **컴파일러가 컴파일 중에 처리**하고 다른 하나는 **엔진이 실행 중에 처리**합니다.

따라서 엔진과 친구들이 `var a = 2;` 프로그램에 접근하는 방법을 분석해보겠습니다.

- 컴파일러가 해당 프로그램으로 할 첫 번째 일은 **렉싱**을 수행하여 **토큰으로 분해**한 다음 **트리로 파싱**하는 것입니다.
- 그러나 컴파일러가 **코드 생성**에 도달하면 이 프로그램을 가정한 것과 다소 다르게 처리합니다.
  - 합리적인 가정은 **컴파일러가 다음 의사 코드로 요약될 수 있는 코드를 생성한다는 것**입니다.

> **의사코드(Pseudocode) 📓**
>
> 간단히 **의사코드**라는 어휘에 대해 짚고 넘어갑시다. 사전적 정의는 **프로그램을 작성할 때 각 모듈이 작동하는 로직을 표현하기 위한 언어**라고 합니다.
>
> 일반적인 언어로 코드를 흉내내어 알고리즘을 써놓은 코드를 말한다고 하네요.

하지만 불행히도 가정은 정확하지 않으며, 컴파일러는 대신 다음과 같이 진행합니다.

- `var a` 를 만나면 컴파일러는 **스코프의 특정 범위 컬렉션에 대해 변수 `a` 가 이미 존재하는지 확인하도록 요청**합니다.
  - 존재한다면 컴파일러는 이 선언을 무시하고 계속 진행하고, 그렇지 않다면 컴파일러는 스코프에 다음을 선언하도록 요청합니다.
- 컴파일러는 **엔진이 나중에 실행할 코드를 생성**하여 **`a = 2` 할당을 처리**합니다.
  - 엔진이 실행하는 코드가 **스코프의 현재 범위 컬렉션에서 액세스할 수 있는 변수**라면 엔진은 해당 변수를 사용합니다
  - 그렇지 않다면 **엔진은 다른 곳(중첩 범위)을 찾습니다.**
  - 그리고 엔진이 변수를 찾았을 때, `2` 를 할당합니다.

<br />

> **요약! 🔖**
>
> 변수 할당에 대한 두 가지 고유한 작업이 수행됩니다.
>
> 첫째, **컴파일러는 현재 범위에서 변수를 선언(이전에 선언되지 않은 경우)**하고, <br/> 두 번째는 **실행할 때 엔진이 범위에서 변수를 찾아 변수를 찾은 경우 할당**합니다.

<br />

### Compiler Speak ❓

---

이해를 돕기 위한 추가적인 컴파일러 용어가 필요합니다.

- 엔진이 2단계에서 컴파일러가 생성한 코드를 실행할 때, 변수가 선언되었는지 확인하기 위해 **변수를 조회**해야 하며 이 조회는 **참조(Consulting)**입니다.
  - 그러나 엔진이 수행하는 **조회 유형은 조회 결과에 영향을 미칩니다.**
- 우리의 경우 엔진이 변수에 대해 **LHS 조회를 수행한다**고 합니다. 반대의 경우, **RHS**라고 합니다.
  - 여기서 L/R은 **할당 작업의 방향**에 대한 **왼쪽과 오른쪽**을 의미합니다.
  - 할당 연산의 왼쪽에 변수가 있다면 LHS, 반대의 경우 RHS입니다.
  - 정확히 짚고 넘어가자면, RHS는 변수의 값 조회와 구별할 수 없기에 할당의 오른쪽이라고 하기 보다는 **"왼쪽이 아닌"**을 의미합니다.

```js
console.log(a);
```

여기에는 아무것도 할당되지 않았기에 `a` 에 대한 참조는 **RHS 참조**입니다.

- 대신 값을 **`console.log()` 에 전달할 수 있도록 값을 검색**합니다.

반대로,

```js
a = 2;
```

여기서 `a` 에 대한 참조는 **LHS 참조**입니다.

- 실제로 현재 값이 무엇인지 신경쓰지 않기 때문에 **`= 2` 할당 작업의 대상으로 변수를 찾고 싶을 뿐**입니다.

> **Note 🗒️**
>
> - `LHS` 와 `RHS` 가 **반드시 문자 그대로 `=` 연산자의 왼쪽, 오른쪽을 의미하는 것이 아닙니다.**
> - 이를 구분하는 용이한 방법은 **할당의 대상(LHS)이 누구인가와 할당의 출처(RHS)는 누구인가**에 대한 내용일 것입니다.

다음 함수는 LHS와 RHS 참조가 모두 있는 프로그램입니다.

```js
function foo(a) {
  console.log(a); // 2
}

foo(2);
```

- `foo()` 를 **함수 호출**로 호출하는 마지막 줄은 `foo` 에 대한 RHS 참조가 필요합니다.
- 또한 `()` 는 **`foo` 의 값이 실행되어야 함**을 의미하므로 실제로 **함수가 되는 것**이 문맥상 맞는 것으로 보입니다.

여기에 놓칠 수 있는 **할당**이 하나 있습니다.

- 그것은 해당 코드에서 암시적으로 실행된 **`a = 2`** 를 의미합니다.
  - 이는 값 **`2` 가 `foo()` 함수에 인자로 전달될 때** 발생합니다.
  - 이러한 경우 **`2` 값이 매개변수 `a` 에 할당되며,** 암시적으로 매개변수 `a` 에 할당하기 위한 **LHS 조회도 실행**됩니다.

값에 대한 RHS 참조도 있으며 **그 결과 값은 `console.log()` 에 전달**됩니다.

- `console.log()` 를 실행하려면 **참조**가 필요합니다.
  - 이것은 **`console` 객체에 대한 RHS 조회**이며, 그 다음에는 `log` 라는 메서드가 있는지 확인하기 위해 **프로퍼티 확인이 발생**합니다.

결국 우리는 다음과 같은 내용을 개념화할 수 있습니다.

- 값 `2`(변수 `a` 의 RHS 조회를 통해)를 `log()` 에 전달하는 LHS/RHS 교환이 있다는 것
- `log()` 의 기본 구현 내부에 매개변수가 있다고 가정할 수 있는 것
- 매개변수 중 첫 번째(`arg1` 이라고 함)에는 `2` 를 할당하기 전에 LHS 참조 조회가 있다는 것

> **Note 🗒️**
>
> 함수 선언 `function foo(a) {...}` 를 `var foo` 및 `foo = function(a) {...}` 와 같은 **일반적인 변수 선언 및 할당으로 개념화하고 싶을 수 있습니다.** <br/> 하지만 미묘한 차이점이 있는데, **컴파일러가 코드 생성 중에 선언과 값 정의를 모두 처리하므로** 엔진이 **코드를 실행할 때 `foo` 함수 값을 할당하는데 필요한 처리가 필요하지 않다는 점**입니다. <br/> 따라서 여기에서 논의하는 방식으로 **함수 선언식을 LHS 조회 할당으로 생각하는 것**은 적절하지 않습니다.

<br />

### Engine/Scope Conversation ❓

---

```js
function foo(a) {
  console.log(a); // 2
}

foo(2);
```

위 코드를 대화로 상상해보면 다음과 같을 것입니다.

- `Engine` : 스코프님, `foo` 에 대한 RHS 참조가 있습니다. 들어본 적이 있나요?
- `Scope` : 네, 그렇습니다. 컴파일러가 1초 전에 선언했네요. 함수에요, 여기 있습니다.
- `Engine` : 감사합니다. `foo` 를 실행합니다.
- `Engine` : 스코프님, `a` 에 대한 LHS 참조가 있네요. 들어본 적이 있나요?
- `Scope` : 네, 그렇습니다. 컴파일러가 `foo` 에 대한 매개변수로 선언했네요. 여기 있습니다.
- `Engine` : 매번 감사드립니다. `2` 를 할당하겠습니다.
- `Engine` : 번거롭게 해드려 죄송합니다. `console` 에 대한 RHS 조회가 필요합니다. 들어본 적이 있나요?
- `Scope` : 괜찮아요, 제 업무인걸요. `console` 이 내장되어 있네요, 여기 있습니다.
- `Engine` : 완벽해요 `log` 를 찾았습니다. 좋아요, 함수네요.
- `Engine` : 스코프님 `a` 에 대한 RHS 참조를 도와주실 수 있나요? 기억이 나는 것 같은데 확실히 하고 싶습니다!
- `Scope` : 당신 말이 맞습니다. 동일한 변수이며 변경되지 않았습니다. 여기 있습니다.
- `Engine` : `a` 의 값인 `2` 를 `log()` 에 전달합니다.

<br />

### Quiz ❓

---

이를 바탕으로 `Engine` 의 입장에서 `Scope` 와 대화를 해보세요.

```js
function foo(a) {
  var b = a;
  return a + b;
}

var c = foo(2);
```

- 변수 `c` 가 존재하는지 묻기
- 존재하지 않기에 선언 요청 및 값 할당을 위한 `foo` 실행
- 함수 `foo` 에 대한 RHS 참조 묻기
- `a` 에 대한 LHS 참조 묻고 `2` 할당
- 변수 `b` 가 있는지 묻고 없기에 선언을 진행
- 이후 `b` 에 대한 할당을 위해 LHS 참조를 묻고 `a` 에 대한 RHS 참조를 통해 `b` 에 `2` 할당
- `a` 와 `b` 에 각각 RHS 참조를 다시 묻고 이를 더해 `4` 를 반환
- 최종적으로 반환된 `4` 를 선언되었던 `c` 의 RHS 참조를 통해 할당

<br />

## Nested Scope ❕

---

> **TL;DR 🔖**
>
> - 현재 스코프에서 변수를 찾지 못한 경우 **중첩 스코프**를 통해 변수를 찾아갑니다.
> - **현재 스코프**에서 시작해서 중첩 스코프를 한 단계씩 올라가다 **전역 스코프**에 도달했을 때, 변수 찾음 여부와 상관없이 이를 중단합니다.
> - 충족되지 않은 RHS 참조로 인해 **`ReferenceError` 가 발생**하고, 충족되지 않은 LHS 참조는 `strict mode` 가 아닌 경우 **암시적 전역 변수 선언**을 수행하고, 그렇지 않은 경우 **`ReferenceError` 를 발생**시킵니다.

<br />

스코프는 **식별자로 변수를 찾는 일련의 규칙**이라고 말한 바가 있습니다.

- 그러나 일반적으로 **하나 이상의 범위를 고려**해야 합니다.
- 블록이나 함수가 다른 블록이나 함수 안에 중첩되는 것처럼 **스코프도 다른 스코프 안에 중첩됩니다.**
- 따라서 즉각적인 범위에서 변수를 찾을 수 없는 경우, **엔진은 외부 스코프를 참조하여 찾고, 전역에 도달할 때까지 이를 계속합니다.**

```js
function foo(a) {
  console.log(a + b);
}

var b = 2;

foo(2); // 4
```

- `b` 에 대한 RHS 참조는 `foo` 함수 내에서 확인할 수 없지만, **이를 둘러싼 스코프에서 확인할 수 있습니다.**
  - 그렇기에 **전역 스코프 내 변수 `b` 에서 이를 참조**하여 결과적으로 `4` 를 반환합니다.
  - 이러한 매커니즘은 현재 실행 중인 스코프에서 한 수준씩 스코프를 올라가며 찾다가 전역에 도달할 때 변수를 찾지 못했더라도 이를 중단합니다.

<br />

### Building on Metaphors ❓

---

중첩 스코프 해결 프로세스를 시각화하려면 다음과 같은 고층 건물을 생각할 수 있습니다.

![building](/img/samuel/what-is-scope/building.png)

- 건물은 **프로그램의 중첩 스코프 규칙 집합**을 나타냅니다.
- 건물 1층은 어디에 있든 **현재 실행 중인 스코프**를 나타냅니다.
- 건물 최상위 층은 **전역 스코프**입니다.

현재 층을 통해 LHS 및 RHS 참조를 해결하고, 참지 못하면 엘리베이터를 타고 다음 층으로 이동합니다.

- 이러한 과정을 계속 진행하다가 **최상층에 도달했을 때,** 이를 찾지 못했더라도 그만두어야할 것입니다.

<br />

### Errors ❓

---

여기서 LHS와 RHS라고 부르는 것이 중요한 이유는 무엇일까요?

- 이 두 가지 유형의 참조는 **변수가 아직 선언되지 않은 상황에서 다르게 작동**하기 때문입니다.

```js
function foo(a) {
  console.log(a + b);
  b = a;
}

foo(2);
```

`b` 에 대해 RHS 참조를 처음 진행했을 때에는 이를 찾을 수 없습니다.

- 이는 스코프에서 찾을 수 없기 때문에 **"선언되지 않은 변수"**라고 합니다.
- RHS 조회가 중첩 스코프 어디에서도 변수를 찾지 못하면 엔진에서 `ReferenceError` 를 발생시킵니다.
  - 오류가 `ReferenceError` 유형이라는 점에 유의하는 것이 중요합니다.

반대로 엔진이 LHS 참조를 수행하는데 이를 찾지 못하고 전역 스코프에 도달하는 경우엔, 프로그램이 **`strict mode` 에서 실행되지 않으면 전역 스코프는 해당 이름의 변수를 자동으로 생성하고 엔진으로 전달**합니다.

- **`strict mode` 를 실행한 경우,** 암시적 전역 변수 선언을 허용하지 않기에 엔진은 **RHS의 경우와 유사하게 `ReferenceError` 를 발생**시킵니다.

이제 RHS 조회를 위한 변수가 발견되었지만, **함수로 실행되지 않는 값을 함수로 실행하거나 `null` 혹은 `undefined` 와 같은 값의 프로퍼티를 참조하는 것**과 같이 불가능한 값으로 작업을 시도하는 경우, 엔진은 **`TypeError`** 라고 하는 다른 종류의 오류를 발생시킵니다.

- `ReferenceError` 는 **스코프 확인 실패**와 관련된 반면 `TypeError` 는 스코프 확인에 성공했지만 **결과에 대해 불법적/불가능한 작업이 시도되었음을 의미**합니다.

<br />

### Review ❓

---

- 스코프는 **변수(식별자)를 참조할 수 있는 위치와 방법을 결정하는 일련의 규칙**입니다.
- 해당 참조는 **LHS(변수 할당을 위한 것) 혹은 RHS(해당 값을 검색하기 위한 것) 참조** 중 하나입니다.
- LHS 참조는 **할당 작업의 결과**이며, 스코프 관련 할당은 **`=` 연산자를 사용**하거나, **함수 매개변수에 인자를 전달(할당)**하여 수행할 수 있습니다.
- 자바스크립트 엔진은 실행되기 전에 먼저 코드를 **컴파일**하고, 그러는 동안 `var a = 2` 와 같은 **명령문을 분할**하는데 이는 두 단계로 나뉩니다.
  - 먼저 `var` 를 사용하여 해당 스코프에서 선언합니다. 이것은 **코드 실행 전, 처음에 수행됩니다.**
  - 나중에 `a = 2` 를 사용하여 **변수(LHS 참조)를 찾고 발견되면 할당**합니다.
- LHS 및 RHS 참조는 모두 **현재 실행 중인 스코프에서 시작**하고 필요한 경우 **중첩된 스코프**를 한 단계씩 올라가다가 **전역 스코프**에 도달했을 때, 찾은 지의 여부와 상관 없이 **이를 중단합니다.**
- 충족되지 않은 RHS 참조로 인해 **`ReferenceError` 가 발생**하고, 충족되지 않은 LHS 참조는 `strict mode` 가 아닌 경우 **암시적 전역 변수 선언**을 수행하고, 그렇지 않은 경우 **`ReferenceError` 를 발생**시킵니다.
