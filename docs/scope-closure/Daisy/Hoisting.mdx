---
slug: /scope_closure/daisy/hoisting
title: Hoisting
tags: [scope]
sidebar_position: 4
---

---

변수가 선언된 스코프의 위치와 방법에 따라 다양한 범위에 변수가 결정되는 규칙을 알게 되었다.
함수 스코프와 블록 스코프는 모두 이와 동일한 규칙에 따라 작동한다. 스코프 내에서 선언된 모든 변수는 해당 스코프에 연결된다.
스코프 내의 다양한 위치에 나타나는 변수 선언에 따른 세부 작동 방식이 있으므로 이에 대해 알아보자.

## 무엇이 먼저인가?

자바스크립트 프로그램은 위에서 아래로 순차적으로 실행된다고 생각하는 경우가 많다.
이 부분이 사실이긴 하지만, 이는 잘못된 생각일 수 있다.

```js
a = 2;
var a;
console.log(a);
```

위 예제에서 a 변수에 대한 선언이 값 할당보다 나중에 일어났으므로, 정의되지 않은 변수일 것이라고 예상하지만 2라는 값을 출력한다.

```js
console.log(a);
var a = 2;
```

해당 예제는 이전 예제처럼 2가 출력되거나, 변수가 선언되기 전에 사용되었으므로 ReferenceError를 발생시킬 것이라고 생각하지만,
예상과 다르게 `undefined`가 출력된다. 도대체 어떤 것이 먼저인 것일까?

## 컴파일러

자바스크립트 엔진은 실제로 코드를 해석하기 전에 컴파일한다. 컴파일 단계에서는 **모든 선언을 찾아 적절한 스코프에 연결**한다. 이것이 lexical scope의 핵심이다.
따라서, 변수와 함수의 선언이 코드의 어떤 부분이 실행되기 전에 먼저 처리된다고 생각하는 것이 가장 좋다.

`var a = 2;` 구문을 보면 한 문장으로 생각되지만 자바스크립트는 `var a`와 `a = 2;` 두 문장으로 나누어 생각한다. 즉, 선언문과 할당문으로 나누어 생각하는 것인데 선언문은 컴파일 단계에서 처리되고 할당문은 실행 단계에서 처리된다.
따라서 두 번째 코드문은 다음과 같이 실행된다.

```js
var a;
console.log(a);
a = 2;
```

변수와 함수 선언이 코드가 실행되는 범위에서 코드의 맨 위로 이동되고, 이것이 **호이스트**이다.

<div
  style={{ border: "1px solid #667085", borderRadius: "6px", padding: "10px" }}
>
  <h3 style={{ textAlign: "center" }}>Note</h3>값 할당 및 실행 로직은 제자리에
  그대로 있고, 선언문 자체만 호이스팅 되는 것이다. 실행 로직을 재정렬 하는
  것이라면 혼란을 야기할 수 있다.
</div>

<br />
```js foo();

functino foo() {
console.log(a); // undefined
var a = 2;
}

````

foo()의 선언은 foo() 호출문이 실행될 수 있도록 호이스팅된다.
호이스팅은 스코프마다 이루어진다. 따라서 foo() 함수에서 `var a`는 함수 내부의 맨 위로 호이스팅 된다.
따라서 다음 처럼 해석될 수 있다.

```js
function foo() {
  var a;
  console.log(a); // undefined
  a = 2;
}

foo();
````

함수 선언은 호이스팅 되었지만, 함수 표현식은 호이스팅 되지 않았다.

```js
foo();  // TypeError
var foo = function bar() { ... }
```

변수 식별자 foo는 호이스팅 되어 전역 스코프에 연결되므로 ReferenceError가 발생하지 않는다.
하지만 foo는 정의된 값이 없으므로 TypeError를 발생시킨다.
또햔 이름이 지정된 함수 표현식이라도 이름 식별자는 둘러싸는 범위에서 사용할 수 없다.

```js
foo();  // TypeError
bar();  // ReferenceError가

var foo = function bar(){...};
```

위 코드는 다음과 같이 해석된다.

```js
var foo;

foo();  // TypeError
bar();  // ReferenceError

foo() = function(){
    var bar = ...self...
}
```

## 함수 먼저

함수 선언과 변수 선언 둘 다 호이스팅된다. 그러나 더 자세하게 살펴보면 함수가 변수보다 먼저 호이스팅된다.

```js
foo();

var foo;

function foo() {
  console.log(1);
}

foo = function () {
  console.log(2);
};
```

위 코드를 실행시키면 2 대신 1이 출력된다. 엔진은 다음과 같이 해석한다.

```js
functino foo() {
    console.log(2);
}

foo();  // 1

foo = function() {
    console.log(2);
}
```

foo 변수 선언문이 foo 함수 선언보다 먼저 선언되었다. 두 변수명 중복으로 선언되었으므로 하나의 선언은 무시되는데, 나중에 선언된 함수가 변수보다 우선시되어 변수가 무시되고 함수가 실행되었음을 볼 수 있다.

```js
foo(); // 3

function foo() {
  console.log(1);
}

var foo = function () {
  console.log(2);
};

function foo() {
  console.log(3);
}
```

위 코드는 동일한 스코프 내에서의 중복 선언이 얼마나 큰 혼란을 야기하는지 알 수 있다.
블록 스코프 내부에서 나타나는 함수 선언은 코드의 조건문을 실행하는 대신 **둘러싸인 스코프의 위로 올라간다**.

```js
foo(); // "b"

var a = true;
if (a) {
  function foo() {
    console.log("a");
  }
} else {
  function foo() {
    console.log("b");
  }
}
```

위 예제를 보면 변수 a가 true이므로 if문의 첫번째 함수가 실행될 것으로 보이지만,
중복된 함수 선언이므로 첫 번째 함수가 무시되고 두번째 함수가 호이스팅 되어 "b"를 출력한 것이다.

그러나 이러한 동작을 신뢰할 수 없고, 추후 자바스크립트에서 변경될 수 있는 부분이므로 블록에서 함수를 선언하는 것은 좋지 않다.

## Review

자바스크립트는 `var a = 2;`를 선언문과 할당문 두 가지 별개로 생각한다. 첫 번째는 컴파일러 작업, 두 번째는 실행 작업에 해당한다.
이로 인해 변수가 나타나는 위치에 상관없이 스코프의 모든 선언이 코드가 실행되기 전에 먼저 처리된다.
변수 및 함수의 선언이 스코프 내부의 맨 위로 이동하는 것을 호이스팅이라고 하는데, 선언문은 호이스팅 되지만 할당문은 호이스팅 되지 않는다.
중복된 선언(특히 변수와 함수끼리의 중복된 선언)은 주의해야 한다.
