---
slug: /up-going/daisy/function_vs_blockscope
title: Function vs Block Scope
tags: [scope]
sidebar_position: 3
---

---

## 함수가 생성한 스코프

자바스크립트에서 함수는 자체적인 스코프를 생성하고, 다른 구조들은 그렇지 않다고 생각할 수 있지만, 이는 사실이 아니다.
먼저, 함수 스코프와 그 역할에 대해서 알아보자.

```js
function foo(a) {
  var b = 2;

  function bar() {
    // ...
  }

  var c = 3;
}
```

위 코드에서 a, b, c, bar는 foo() 스코프에 속하기 때문에 foo() 외부에서는 접근할 수 없다. <br/>
즉, 글로벌 스코프에서 해당 식별자들을 사용할 수 없기 때문에 다음 코드들은 오류를 발생시킨다.

```js
bar(); // falls
console.log(a, b, c); // all 3 fail
```

하지만 이 식별자들은 foo()와 bar() 내부에서는 사용할 수 있다. <br/>
함수 스코프는 모든 변수가 해당 함수에 속하며, 함수 전체에 걸쳐 재사용 될 수 있다고 생각된다.
따라서 필요에 따라 다양한 유형의 값을 사용하기 위해 js 변수의 **동적**인 특성을 최대한 활용할 수 있다.

하지만 의도치 않게 범위 전체에 걸치는 변수가 만들어질 경우, 예상치 못한 결과를 초래할 수 있다.

## 일반 스코프에서 숨기기

대부분 함수를 선언한 뒤 그 안에 코드를 추가하지만, 반대로 작성한 코드 임의의 부분을 함수로 둘러쌀 수도 있다.
이것을 바로 '코드 숨기기'라고 한다. 이렇게 되면 해당 코드 주변에 스코프 버블을 생성하는데, 이는 해당 코드에 있는 모든 선언(변수, 함수)이 이전에 속하던 범위가 아닌 새로운 함수에 속하게 된다.
즉 변수와 함수를 둘러싸는 범위(함수)의 범위에 포함시켜 **숨길** 수 있다. 그렇다면 이러한 숨김 기술이 왜 필요할까?

이는 바로 소프트웨어 설계 원칙에서 필요한 것만 노출하고 최대한 숨겨야 한다는 '최소한의 노출' 원칙과 관련있다.<br/>
모든 변수나 함수가 전역 범위에 있는 경우 중첩된 범위에서 접근 가능하므로 '최소한의 노출' 원칙에 위배된다.

```js
function doSomething(a) {
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}

function doSomethingElse(a) {
  return a - 1;
}

var b;

doSomething(2); //15
```

위 예제에서 `doSomethingElse()`는 오직 `doSomething()`이 개인적으로 사용하기 위한 코드인데 전역에서 접근할 수 있음을 알 수 있다.
이렇게 접근 범위를 부여하는 것은 의도치 않은 작동을 일으킬 수 있으므로 위험할 수 있다.
따라서 다음과 같이 수정해야 한다.

```js
function doSomething(a) {
  function doSometingElse(a) {
    return a - 1;
  }

  var b;
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}

doSomething(2);
```

### 충돌 회피(Collision Avoidance)

변수와 함수를 숨기는 또 다른 장점은 이름은 같지만 용도는 다른 두 식별자의 의도치 않은 충돌을 피할 수 있다는 것이다.

```js
function foo() {
  function bar(a) {
    i = 3; // changing the 'i' in the enclosing scope's for-loop
    console.log(a + i);
  }

  for (var i = 0; i < 10; i++) {
    bar(i * 2); // infinite loop
  }

  foo();
}
```

위 예제에서 for 문이 돌면서 `bar()`를 호출하면, `bar()` 내부에 있는 `i = 3`이 for문의 `i`를 덮어씌우므로 무한루프에 빠지게 된다.
따라서 `bar()` 내부의 `i`는 식별자 이름이 무엇이 되던간에 로컬 변수로 선언해주어야 한다.

#### 전역 네임스페이스

변수의 충돌은 대부분 전역 스코프에서 발생한다. 프로그램에 로드된 라이브러리는 기능과 변수를 내부에 숨기지 않으면 서로 충돌하기 쉽다.<br/>
따라서 일반적으로 라이브러리는 전역 범위에서 충분히 고유할 수 있는 이름으로 단일 변수 또는 객체를 선언한다. 그리고 이 변수는 해당 라이브러리의 **네임스페이스**로 사용되고,
이 라이브러리의 기능에 대한 노출은 최상위 lexical scope가 아닌 해당 네임스페이스의 공간에 속하게 된다.

<div
  style={{ border: "1px solid #667085", borderRadius: "6px", padding: "10px" }}
>
  <h3>NameSpace</h3>
  네임스페이스는 개체를 구분할 수 있는 범위를 나타내는 말로, '소속을 알리는 역할'을
  한다.

```js
namespace Box1{
   int boxSide = 4;
}

namespace Box2{
   int boxSide = 12;
}

int main () {
  cout << Box1::boxSide << endl;  //output 4
  cout << Box2::boxSide << endl;  //output 12
  return 0;
}
```

</div>

#### 모듈 관리

충돌을 피하기 위한 또 다른 방법은 다양한 종속성 관리자를 사용하는 방법이다.
이러한 도구를 사용하면 어떤 라이브러리도 식별자를 전역 스코프에 포함시키지는 않지만, 대신 식별자를 특정 범위에 명시적으로 가져와야 한다.
Lexical scope 규칙에서 면제되지는 않으므로 설명되어있는 범위 지정 규칙을 이용해 식별자를 비공개 범위에 지정하여 충돌을 방지한다.

## 함수를 스코프로 사용하기

코드 조각을 함수로 감싸서 변수나 함수를 효과적으로 숨길 수 있음을 알게되었다.

```js
var a = 2;

function foo() {
  // insert
  var a = 3;
  console.log(a); // 3
} // insert

foo(); // insert
console.log(a); // 2
```

위 예시와 같은 방법은 foo라는 함수명, 함수 호출 구문 등의 코드를 추가해야 하므로 좋은 방법은 아니다. ㅇ
자바스크립트는 이러한 문제를 두 가지 방법으로 해결할 수 있다.

```js
var a = 2;

(function foo() {
  // insert
  var a = 3;
  console.log(a); // 3
})(); // insert

console.log(a); // 2
```

위 코드는 함수를 표준으로 선언된 것이 아닌 함수 표현식으로 처리한다.

<div
  style={{ border: "1px solid #667085", borderRadius: "6px", padding: "10px" }}
>
  <h3 style={{ textAlign: "center" }}>Note</h3>
  선언식과 표현식을 구별하는 가장 쉬운 방법은 코드에서 function의 위치이다. <br />
  명령문에서 function이 맨 처음에 있는 경우는 선언식이고, 그 외의 경우는
  표현식이다.
</div>

첫 번째 예시에서 `foo()`는 둘러싼 범위 내에서 바인딩 되는데, 두 번째 예시에서 `foo()`는 둘러싼 범위에 바인딩 되지 않고 자신의 함수 내에서만 바인딩 된다.
이는 외부 범위에 속하지 않음을 의미하며, 둘러싸인 범위를 불필요하게 오염시키지 않는다는 것을 의미한다.

### 익명 vs 이름이 있는

함수 표현식은 익명이 가능하지만, 함수 선언식은 이름을 생략할 수 없다.
익명 함수 표현식은 빠르게 코드를 작성하거나 다양한 코드 표현에 사용될 수 있는 등의 장점이 있지만, 몇가지 고려해야 할 점이 있다.

1. 익명 함수는 스택 추적에 표시될 때 의미 없는 이름을 가지므로 디버깅이 어려울 수 있다.
2. 이름 없이 함수가 자기 자신을 참조할 때(재귀), 사용되지 않는 `arguments.call` 참조가 필요하다.<br/>
   자체 참조가 필요한 또 다른 경우는 이벤트 핸들러 함수가 발생한 후 자체적으로 바인딩을 해제하려는 경우가 있다.
3. 익명 함수는 가독성 좋은 코드를 작성하는데 도움이 되지만, 작명된 함수는 코드를 문서화 하는데 도움이 된다.

이름 있는 함수를 써서 나쁠 것이 없으므로, 함수식에 항상 이름을 지정하는 것이 좋다. 인라인 함수도 마찬가지!

```js
setTimeout(function timeoutHandler() {
  console.log("I waited 1 second!");
}, 1000);
```

### 함수 즉시 호출식

IIFE(함수 즉시 호출식)를 사용하면 첫 번째 `()`가 함수식을 만들고 두 번째 `()`가 함수를 실행한다.
IIFE는 이름을 필요로 하지 않는데, 익명 함수 표현식 보다 더 많은 이점이 있으므로 사용하면 좋다.

예전 IIFE의 형태는 현재와 차이점이 있는데, 호출식이 `(function())`의 바깥쪽에 있는 것과 안쪽에 있는 것이다.
두 형태 다 기능은 동일하므로 선호하는 방식을 사용하면 된다.

```js
var a = 2;

(function IIFE(global) {
  var a = 3;
  console.log(a); // 3
  console.log(global.a); //2
})(window);

console.log(a); // 2
```

window 객체를 인자로 전달하지만 매개변수의 이름을 global로 지정함으로써, global vs non-global 참조에 대해 명확한 스타일로 설명한다.
스코프 내에서는 무엇이든 전달 가능하며 매개변수 이름도 원하는 대로 지을 수 있다.

또한, 정의 되지 않은 식별자의 값을 잘못 덮어씀으로써 발생하는 예상치 못한 결과를 방지할 수 있다.
매개변수에 정의 되지 않은 이름을 지정하지만, 해당 인수에 값을 전달하지 않으면 헤딩 식별자가 코드 블록에서 정의되지 않은 값임을 보장할 수 있다.

```js
undefined = true;

(function IIFE(undefined) {
  var a;
  if(a === undefined) {
    console.log("Undefined is safe here!);
  }
})();
```

IIFE의 또 다른 변형은 호출 및 전달할 매개변수 다음에 실행할 함수가 두 번째로 주어지는 것의 순서를 뒤집는다.
이러한 패턴을 UMD(Universal Module Definition)이라고 부른다.

```js
var a = 2;

(function IIFE(def) {
  def(window);
})(function def(global) {
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
});
```

`def` 함수 표현식은 코드의 후반부에 작성되고, 전반부에 정의된 `IIFE` 함수의 매개변수로 전달된다.
마지막으로 매개변수 `def()`가 호출되어 window를 전역 매개변수로 전달한다.
