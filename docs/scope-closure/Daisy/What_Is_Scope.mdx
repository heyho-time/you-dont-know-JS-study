---
slug: /up-going/daisy/what-is-scope
title: What is Scope?
tags: [scope]
sidebar_position: 1
---

---

프로그래밍 언어의 가장 중요한 역할 중 하나는 **변수에 값을 저장하고 가져다 쓸 수 있도록 하는 것**이다.
따라서 그 변수들이 어디에 저장되는지, 어디에서 가져다 쓸 수 있는지를 잘 알고 있어야 한다.

변수를 특정 위치에 저장하고 그 변수를 찾기 위해서는 범위에 대한 규칙이 필요한데,
이러한 규칙을 스코프라고 한다. 이러한 범위의 규칙이 어디서 어떻게 설정되는지 알아보자.

## 컴파일러에 대하여

자바스크립트는 일반적으로 동적 + 인터프리팅 된 언어라고 알고있지만, 사실은 컴파일 된 언어이다.
다른 컴파일 언어처럼 사전에 컴파일되지 않으며, 컴파일 결과가 다양한 분산 시스템에서 호환되지는 않는다.
자바스크립트 엔진의 컴파일 방식은 일반적으로 알고 있는 것보다 더 복잡하지만, 다른 전통적인 컴파일러 언어와 공통적인 컴파일 단계를 거친다.
전통적인 컴파일 언어 프로세스에서 소스코드가 실행되기 전에 3단계를 거친다.

### 토큰화(Tokenizing) / 낱말 분석(Lexing)

일련의 문자열을 **토큰**이라는 의미있는 덩어리(언어)로 분할한다.<br/>
`var a = 2`는 `var`, `a`, `=`, `2`, `;`로 나누어진다.
공백은 의미가 있냐 없냐에 따라 토큰으로 나뉘어질 수도 있고, 아닐 수도 있다.

<div
  style={{ border: "1px solid #667085", borderRadius: "6px", padding: "10px" }}
>
  <h3 style={{ textAlign: "center" }}>Note</h3>
  토큰화와 렉싱의 차이는 토큰이 상태를 저장하는지 저장하지 않는지 여부에 중점을 둔다.{" "}
  <br />
  간단히 말해서, 토크나이저가 `a`를 별개의 토큰으로 판단할지, 아니면 다른 토큰의
  일부로 판단할지를 알아내기 위해 stateful parsing rule을 호출한다면, 그것은
  lexing이다.
</div>

### 파싱(Parsing)

토큰 배열을 가져와서 중첩된 엘리먼트의 트리로 나타내는데, 이 트리는 프로그램의 문법 구조를 집합적으로 표현한다.
이 트리는 AST(Abstract Syntax Tree, 추상 구문 트리)라고 한다.<br/>

`var a = 2;`의 트리는 다음과 같을 것이다. <br/>
변수 정의(Variable Declaration)이라고 불리는 최상위 노드가 있고, 그 아래에 식별자(Indentifier)라고 불리는 자식 노드(값은 a)가 있을 것이다.
그리고 또 다른 자식 노드인 할당 표현식(Assignment Expression)이 있고, 해당 노드는 값이 2인 숫자 리터럴(Numerial Literal) 이라는 자식 노드를 가지고 있다.

<img
  src="/img/daisy/parsing_tree.png"
  alt="parsingTree"
  style={{ width: "100%" }}
/>

### 코드 생성(Code Generation)

AST를 실행 가능한 코드로 변환하는 프로세스이며 언어, 사용 플랫폼 등에 따라 크게 달라진다.<br/>
이러한 세부 사항에 얽매이지 않고 AST를 기계어 명렁 집합으로 변환하여 `a`라는 실제 변수를 생성하고 값을 `a`에 저장하는 방법이 있다.

자바스크립트 엔진은 위의 세 단계에서 실행 성능을 최적화하는 단계가 추가되는 등 더 복잡하다.
다른 컴파일러 언어는 빌드보다 컴파일이 더 먼저 실행되는 반면, 자바스크립트 엔진은 그렇지 않기 때문에 최적화할 시간이 많지 않다.
따라서 코드가 실행되기 전, 마이크로초 동안만 컴파일이 발생한다. <br/>
즉, 자바스크립트 코드는 실행되기 전에 컴파일되어야 한다.

---

## 스코프 이해하기

1. **Engine**<br/>
   Js 프로그램 처음부터 끝까지의 컴파일 및 실행 담당
2. **Compiler**<br/>
   구문 분석 및 코드 생성 등 모든 복잡한 작업 처리 담당
3. **Scope**<br/>
   선언된 모든 식별자(변수)의 **조회 리스트**를 수집 및 유지하며, 현재 실행중인 코드에서 이러한 변수에 접근할 수 있는 방법에 대한 엄격한 규칙 시행

우리는 `var a = 2;`를 하나의 구문으로 보지만, 자바스크립트 엔진은 두 개의 구분된 구문으로 본다. 하나는 컴파일 중에 컴파일러가 핸들링 할 구문, 그리고 하나는 실행 중 엔진이 핸들링 할 구문이다.

먼저 컴파일러는 프로그램을 토큰으로 분해하기 위한 lexing 작업을 수행한다. 그 이후 과정은 다음과 같다.<br/>

1. 컴파일러가 변수를 만나면 스코프에게 **특정 스코프 컬렉션에 변수 a가 존재하는지** 확인하도록 요청한다.
   이 경우 컴파일러는 해당 선언을 무시하고 계속 진행하지만, 그렇지 않으면 컴파일러는 스코프에게 해당 스코프 컬렉션에 a라는 변수를 새로 선언하도록 요청한다.

2. 컴파일러는 `a = 2` 할당 구문을 처리하기 위해, 나중에 실행할 엔진을 위한 코드를 생성한다.
   엔진이 실행 중인 코드는 스코프에게 "현재 스코프 컬렉션에 접근 가능한 `a`라는 변수가 있는지" 물어본다. 변수가 존재하면 그 변수를 사용하고, 없다면 엔진은 다른 곳(중첩된 스코프)을 찾는다.

엔진이 변수를 찾으면 해당 변수에 2를 할당하고, 찾지 못하면 에러를 발생시킨다.

**[ Summary ]** <br/>
변수를 할당할 때 다음 두 작업이 수행된다.

1. 컴파일러가 현재 스코프에서 변수를 선언
2. 실행시에 엔진이 스코프에서 해당 변수를 찾음

### 컴파일러에 대해

엔진은 컴파일러가 생성한 코드를 실행할 때 변수가 선언되었는지 조회하는데, 조회는 스코프를 참조하는 것이다.
조회의 유형에는 LHS / RHS 두 가지가 있으며, L과 R은 각각 대입 연산의 방향인 왼쪽과 오른쪽을 나타낸다.

- LHS: 변수가 대입 연산자의 왼쪽에 있을 때 수행, 값을 대입해야 하므로 변수 컨테이너 자체를 찾음
- RHS: 변수가 대입 연산자의 오른쪽에 있을 때 수행, 단순히 특정 변수의 값을 찾는 것

예를 들어, `console.log(a);`는 구문에서 a에 아무것도 대입하지 않으므로 RHS 참조이며,
`a = 2;`는 a에 2라는 값을 대입하므로 LHS 참조이다.

### 엔진 / 스코프에 대해

엔진은 컴파일러가 생성한 코드를 실행하면서 호출된 함수, 변수, 객체 등이 존재하는지 스코프를 통해 계속 확인한다.

## 중첩된 스코프

스코프는 식별자의 이름을 통해 변수를 찾는 규칙 집합이다.
스코프는 중첩되어 있는 경우가 많으므로 변수를 범위 내에서 찾지 못한 경우 그 다음 외부 범위를 참조하는 작업을 지속하여 가장 바깥쪽 스코프(global)에 도달한다.
글로벌 스코프에 도달하면 변수를 찾았는지 여부에 관계없이 검색이 중단된다.

## 에러

LHS와 RHS를 구분하는 이유는 두 유형의 조회는 **변수가 아직 선언되지 않은 상황에서** 다르게 동작하기 때문이다.

RHS 조회의 경우 스코프 범위에서 변수를 찾지 못하면 `ReferenceError`를 발생시킨다.
하지만 LHS 조회의 경우 strict-mode가 아니면 해당 변수를 글로벌 스코프에 생성하고 다시 엔진에 전달한다.
즉 LHS 조회에서 strict-mode는 RHS와 동일하게 동작한다.

RHS 조회시 변수는 발견되었지만 함수가 아니거나 null, 정의되지 않은 값에 대한 속성을 참조하려고 하면 엔진에서 `TypeError`를 발생시킨다.
`ReferenceError`는 범위 확인 실패 관련 에러인 반면, `TypeError`는 범위 확인은 성공했으나 결과에 대한 불가능한 작업을 실행했음을 의미하는 에러이다.
