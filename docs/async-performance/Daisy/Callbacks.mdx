---
slug: /async/daisy/callbacks
title: Callbacks
tags: [async, callbacks]
sidebar_position: 2
---

---

이번 챕터에서는 더 정교한 비동기 패턴이 필요한 이유와 필요한지에 대한 동기부여 두 가지에 대해 살펴볼 것이다.

## 지속성

```js
// A
ajax( "..", function(..){
    // C
} );
// B
```

//A와 //B는 프로그램의 전반부(현재)를 나타내고, //C는 프로그램의 후반부를 나타낸다. 전반부는 즉시 실행되고, 그 이후에는 불확실한 길이의 일시정지가 있다.
미래의 어느 시점에 ajax 호출이 완료되면 프로그램은 중단된 부분부터 다시 실행하여 후반부를 계속한다.
다시 말해, 콜백 함수는 프로그램의 연속을 감싸거나 캡슐화한다. 코드를 더 간단하게 만들어보자.

```js
// A
setTimeout(function () {
  // C
}, 1000);
// B
```

위의 코드는 A를 실행하고 1,000ms 동안 시간 초과를 설정하고, B를 수행한 다음 시간 초과가 발생한 후 C를 수행한다.
콜백 함수의 형태로 단일 연속(또는 수십 개의 프로그램)을 도입하는 즉시, 우리의 뇌가 작동하는 방식과 코드가 작동하는 방식 사이에 차이가 형성된다.

---

## 순차적인 뇌

우리의 뇌는 병렬 멀티스레딩이 가능할 것 같지만 실제로 그렇지 않다. 주어진 순간에 한 가지만 생각할 수 있다.
여러 개의 작업을 빠르게 연속적으로 앞뒤로 전환하면서 동시에 각 작업을 작고 빠른 덩어리로 진행한다,
다만 그 작업이 너무 빨라서 병렬로 일을 처리하는 것처럼 느끼며, 이는 js 작동 방식과 꽤 유사하다.

### 실행 vs 계획

```js
// swap 'x' and 'y'
z = x;
x = y;
y = z;
```

위의 세 할당문은 동기식이므로 서로 전의 작업이 완료되기를 기다린다. 즉, 세 명령문이 시간적으로 일정한 순서로 진행되어야 함을 의미한다.
개발자가 비동기적인 코드를 작성하기 어려운 이유는 우리가 사고하는 의식의 흐름에 대해 부자연스럽기 때문이다.
우리는 단계적인 관점에서 생각하지만 코드에서 사용하는 콜백은 동기식에서 비동기식으로 표현될 때 단계적으로 표현되지 않는다.

### 중첩된 / 연결된 콜백

```js
listen("click", function handler(evt) {
  setTimeout(function request() {
    ajax("http://some.url.1", function response(text) {
      if (text == "hello") {
        handler();
      } else if (text == "world") {
        request();
      }
    });
  }, 500);
});
```

위 코드는 중첩된 세 개의 함수 체인이 있고, 각각은 비동기 프로세스의 단계를 나타낸다.
이러한 코드를 "콜백 지옥"이라고 한다. 그러나 사실 콜백 지옥은 실제로 중첩 또는 들여쓰기와는 거의 관련이 없다.

먼저 클릭 이벤트를 기다리고 타이머가 실행될 때까지 기다린 다음, ajax 응답이 올 때까지 또 기다린 뒤에야 모든 작업을 다시 수행할 수 있다.
언뜻 보면 이 코드는 비동기식을 순차적으로 자연스럽게 매핑하는 것처럼 보일 수 있으나, 여기에는 몇가지 문제가 있다.

첫번째로 우리가 하나의 기능에서 다른 기능으로 이동할 때 생각보다 많은 비동기 관련 작업들이 발생한다.
콜백이 많은 코드에서 비동기 흐름을 이해하는 것이 불가능하지는 않지만 자연스럽거나 쉽지는 않다.

```js
doA(function () {
  doB();
  doC(function () {
    doD();
  });
  doE();
});
doF();

// A -> F -> B -> C -> E -> D
```

처음 코드를 봤을 때 위에서 아래 순차적으로 알파벳 이름을 지었기 때문에 어떤 순서로 진행되는지 알 수 있었을 것이다.
하지만 만약 순서를 고려하지 않고 함수의 이름을 짓는다면 더 파악하기 어려울 것이다.
그리고 만약 함수 A나 D가 실제로 비동기적으로 작동하지 않는다면 실행 순서가 바뀌게 된다.

```js
listen("click", handler);

function handler() {
  setTimeout(request, 500);
}

function request() {
  ajax("http://some.url.1", response);
}

function response(text) {
  if (text == "hello") {
    handler();
  } else if (text == "world") {
    request();
  }
}
```

위 코드는 중첩 문제가 심하진 않지만 여전히 콜백 지옥이다.
코드 실행 순서에 대해 순차적으로 설명할 때 한 함수에서 다음 함수로 건너뛰고, 전체 흐름을 보기 위해 코드 전체를 파악해야 한다.
예제는 간단한 코드이지만 훨씬 방대한 코드인 경우에는 더욱 파악하기 힘들 것이다.

그리고 여러 코드 조각을 연결하여 연속적으로 작동하도록 구현하려면 하드코딩 해야한다.
하지만 하드코딩은 매우 반복적이며 다른 단계나 비동기 흐름에서 재사용 할 수 없으며 유지 보수도 어렵다.

---

## 신뢰성 문제

순차적인 두뇌의 계획과 콜백 기반 비동기 코드 간의 불일치는 콜백 지옥 문제의 일부일 뿐이며, 더 깊이 우려해야할 것이 있다.

```js
// A
ajax("..", funtion(..) {
    // C
});
// B
```

//A와 //B는 메인 js 프로그램의 직접 제어 하에 발생한다. 그러나 //C는 나중에 다른 당사자의(예제의 경우 ajax()) 제어 하에 작동하도록 연기된다.
이러한 제어권 인계는 정기적으로 프로그램에 많은 영향을 미치지는 않지만, 콜백 중심 설계에서 가장 심각한 문제이다.
콜백을 계속 넘겨주는 것이 직접 작성한 함수가 아닌 타사 유틸리티라는 것을 중심으로 생각은 전개된다.

프로그램 실행에 대한 제어권을 제3자에게 넘겨주는 것을 "제어 역전"이라고 한다. 코드와 타사 유틸리티 사이에는 무언의 규칙이 있다.
비동기식 콜백은 반복되는 보일러 플레이트를 만들어내며, 모든 신뢰 라인이 완전한 고장으로 이어지는 제어 역전이다.
콜백을 사용하는 코드가 있고, 타사 유틸리티에서만 사용하는 것도 아니며 이러한 모든 제어 신뢰 문제에 대한 일종의 완화 논리를 적용하지 않은 경우 잠재적인 버그가 존재한다.

---

## 콜백 저장 시도

살펴본 신뢰성 문제 중 일부를 해결하기 위한 콜백 설계는 여러 종류가 있다.
예를 들어, 정상적인 오류 처리와 관련하여 일부 API 설계는 분할 콜백을 제공한다(하나는 성공, 하나는 에러 알림을 위한 것).

```js
function success(data) {
  console.log(data);
}

function failure(err) {
  console.error(err);
}

ajax("http://some.url.1", success, failure);
```

이러한 API 설계에서는 `failure()`가 선택사항인 경우가 많으며, 제공되지 않을 경우 오류를 핸들링 할 수 없다.

또 다른 콜백 패턴은 "오류 우선 스타일(노드 스타일)"이다. 단일 콜백의 첫번째 인자로 오류 객체가 들어간다. 성공하면 이 인자는 비어있거나 false가 되지만, 오류가 발생한 경우 첫번째 인자로 true를 세팅한다.

```js
function response(err, data) {
  // error?
  if (err) {
    console.error(err);
  }
  // otherwise, assume success
  else {
    console.log(data);
  }
}
ajax("http://some.url.1", response);
```

이 두 경우 모두 몇몇 사항을 준수해야한다.
첫째, 대부분의 신뢰성 문제를 실제로 해결하지 못했다. 원치 않는 반복 호출을 방지하거나 필터링 하는 콜백은 없다.
또한 표준 패턴으로 사용할 수 있지만 재사용할 필요 없이 더 장황한 코드로 보이기 때문에 모든 콜백에 대해 타이핑하는데 실증이 날 것이다.
콜백을 받지 않는 경우에는 이벤트를 취소하는 시간 초과를 설정해야 한다. 다음과 같은 유틸리티르르 만들 수 있다.

```js
function timeoutify(fn, delay) {
  var intv = setTimeout(function () {
    intv = null;
    fn(new Error("Timeout!"));
  }, delay);

  return function () {
    // timeout hasn't happened yet?
    if (intv) {
      clearTimeout(intv);
      fn.apply(this, arguments);
    }
  };
}
```

또 다른 신뢰 문제는 너무 빠르다는 것이다. 어떠한 작업이 완료되기 전에 호출되는 것도 포함이다.
하지만 더 일반적인 문제는 지금(동기적) 또는 나중에(비동기적) 제공하는 콜백을 호출할 수 있는 유틸리티에서 분명하게 나타난다.

동기화 또는 비동기화에 대한 비결정론은 항상 버그를 추적하기 어렵게 만든다.
특히 Zalgo는 이벤트 루프의 다음 차례에 "즉시"인 경우에도 항상 콜백을 비동기식으로 호출하여 모든 콜백이 예측 가능하도록 한다.
이러한 예측 불가능성은 모든 자바스크립트 프로그램을 위협한다.
