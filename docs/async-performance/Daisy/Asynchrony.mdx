---
slug: /async/daisy/asynchrony
title: Asynchrony _ Now & Later
tags: [async]
sidebar_position: 1
---

---

프로그램에서 현재 작동하는 부분과 그 이후에 일어날 부분에 대한 관계는 비동기 프로그래밍의 핵심이다.
비동기 프로그래밍은 자바스크립트 초창기부터 존재했고, 개발자들은 왜 발생하는지에 대한 깊은 탐구 없이 이를 처리하는 방법에 대해서만 집중했다.
좋은 방법으로 콜백이 등장했지만 브라우저와 서버의 성장과 다양한 장치에서 실행되는 프로그램에서 비동기를 관리하기에는 콜백으로 부족하게 되었다.
따라서 자바스크립트에서 비동기가 무엇인지와 어떻게 작동하는지 깊게 이해할 필요가 있다.

## A Program in Chunks

자바스크립트 프로그램은 `.js` 파일에 한번에 작성할 수 있지만 대부분은 여러개의 덩어리(함수)로 구성되며, 그 중 하나만 당장 실행되고 나머지는 이후에 실행된다.
자바스크립트를 처음 접하는 개발자들이 겪는 문제는 나중에 작동할 코드가 엄격하게 즉시 지금 작업 바로 후에 작동하지 않는다는 것이다.
즉, 지금 완료할 수 없는 작업은 정의에 따라 비동기식으로 완료되므로 직관적으로 원하는대로 작동하지 않는다는 것이다.

```js
var data = ajax("http://some.url.1");
console.log(data);
// 'data' generally won't have the Ajax results
```

ajax 요청이 동기적으로 완료되지 않았음을 확인할 수 있다. `ajax()`는 `data` 변수에 할당할 반환값이 아직 없는 상태이다.
따라서 반환값이 올 때까지 기다리기 위한 가장 간단한 방법이 콜백 함수이다.

```js
ajax("http://some.url.1", function myCallbackFunction(data) {
  console.log(data);
});
```

**Warning**: Ajax 요청을 기술적으로 동기적으로 만들 수는 있지만, 브라우저 UI(버튼, 메뉴, 스크롤 등)의 상호작용을 막기 때문에 절대 사용하면 안된다.

```js
function now() {
  return 21;
}

function later() {
  answer = answer * 2;
  console.log("Meaning of life: ", answer);
}

var answer = now();

setTimeout(later, 1000); // Meaning of life: 42
```

위 프로그램에는 두 개의 함수가 있으며, 하나는 당장 실행되어야 하고 하나는 나중에 실행되어야 한다.
두 가지를 확실하게 나누어 보면 다음과 같다.

Now:

```js
function now() {
  return 21;
}

function later() {...}

var answer = now();

setTimeout(later, 1000);
```

Later:

```js
answer = answer * 2;
console.log("Meaning of life: ", answer);
```

Now에 있는 코드들은 프로그램을 실행시키자마자 실행되지만, `setTimeout(..)`은 프로그램이 나중에 실행되도록 하기때문에 `later()` 안에 있는 코드들은 1000ms 뒤에 실행될 것이다.
코드의 일부를 함수로 감싸고 어떠한 이벤트에 대한 response로 실행되어야 한다고 지정할 때마다 나중에 실행될 코드 덩어리를 생성하고 비동기를 도입한다.

### Async Console

`console` 메서드가 동작하기 위해 필요한 사항이나 요구 조건은 없다. 공식적으로 자바스크립트의 일부는 아니지만, 호스팅 환경에서 자바스크립트에 추가된다.
따라서 다른 브라우저와 js 환경은 원하는 대로 작동하기 때문에 가끔 혼란스럽게 작동할 수 있다.
특히, `console.log(..)`가 주어진 것을 즉시 출력하지 않는 일부 브라우저와 조건이 있다. 이러한 동작이 발생하는 주된 이유는 I/O가 매우 느리고, 많은 프로그램의 일부를 차단하기 때문이다.
따라서 브라우저가 console의 I/O를 백그라운드에서 비동기로 처리하는 것이 페이지 U/I 관점에서 더 나은 성능을 보일 수 있다.

```js
var a = {
  index: 1,
};

// later
console.log(a); // 2

// even later
a.index++;
```

우리는 `index: 1`을 출력하고, 이후에 `a.index++` 구문이 실행될 것으로 예상한다.
그러나 동일한 코드일지라도 브라우저가 콘솔 I/O를 백그라운드로 연기할 필요가 있다고 느끼는 상황에서 실행되면
증감구문이 먼저 작동하여 `index: 2`를 출력하게 된다.

콘솔의 I/O가 지연되는 조건이나 관찰 여부에 따라 다르게 작동한다. 예기치 못한 수정 사항이 나타나는 경우 I/O에서 이러한 비동기 상황이 발생할 수 있다.

**Note**: 이러한 상황이 발생할 경우 콘솔 출력에 의존하는 것 보다는 js 디버거에서 중단점을 사용하는 것이 가장 좋다.
그 다음 좋은 방법은 해당 개체를 문자열로 직렬화하여(`JSON.stringify()`) 스냅샷을 강제로 생성하는 것이다.

---

## Event Loop

위에서 봤듯이 timeout 처럼 비동기 코드를 작성할 수 있는 상황이 많음에도 불구하고, ES6까지 자바스크립트 자체에서 비동기화에 대한 직접적인 개념을 내장한 적이 없다. <br />
"Asked to." By whom? 이 중요한 포인트이다.

Js 엔진은 단독으로 작동하지 않고, 일반적인 웹브라우저인 호스팅 환경 내에서 실행된다. 지난 몇 년 동안 자바스크립트는 브라우저를 넘어 Node.js와 같은 다른 환경(서버)으로 확장되었다.
그러나 이러한 다양한 환경에서 공통적인 "스레드" 중 하나는 "이벤트 루프"라고 불리는 js 엔진을 호출할 때마다 시간 지남에 따른 여러 프로그램 조각을 실행하는 매커니즘을 가지고 있다.

예를 들어, 자바스크립트 프로그램이 서버에서 일부 데이터를 가져오기 위해 ajax 요청을 할 때, 함수에 response 코드(일반적으로 콜백)를 설정하고 js가 호스팅 환경에 다음과 같이 알려준다: <br />
"지금은 실행을 중지할거지만 네트워크 요청이 완료되서 데이터가 생기면 이 함수를 다시 호출해" <br/>
그 다음 브라우저는 네트워크의 response를 수신하도록 설정되고 사용자에게 제공할 항목이 있으면 이벤트 루프에 삽입하여 콜백 함수가 실행되도록 예약한다.

그렇다면 이벤트 루프가 무엇인지 살펴보자.

```js
// 'eventLoop'는 큐처럼 FIFO로 작동하는 배열이다.
var eventLoop = [];
var event;

while (true) {
  if (eventLoop.length > 0) {
    // 큐에서 다음 이벤트를 가져옴
    event = eventLoop.shift();

    // 다음 이벤트 실행
    try {
      event();
    } catch (err) {
      reportError(err);
    }
  }
}
```

루프의 각 반복이 발생할 때마다, 대기중인 해당 이벤트가 제거되어 실행된다. 이러한 이벤트는 함수 콜백이다.
중요한 점은 `setTimeout(..)`이 이벤트 루프 대기열에 콜백을 넣지 않는다는 점이다.
`setTimeout(...)`은 타이머를 설정하는 일을 하며, 타이머가 만료되면 콜백을 이벤트 루프에 배치하여 미래의 반복이 콜백을 선택하고 실행할 수 있도록 한다.

이 때 이벤트 루프에 이미 20개의 항목이 있다면 어떻게 될까? 콜백이 기다린다. 대기열을 선점해서 앞으로 건너뛰는 경로가 없다. 이는 곧 `setTimeout(..)`이 완벽하게 시간적으로 정확하게 작동할 수 없다는 것을 보여준다.
콜백은 지정한 시간 전에는 실행되지 않을거지만, 이벤트 대기열 상태에 따라 그 시간 또는 그 시간 이후에 발생할 수도 있다.
기술적으로 프로그램과 직접적으로 관련이 없는 다른 이벤트들도 대기열에 삽입될 수 있다.

**Note**: ES6는 이제 이벤트 루프가 작동하는 방식을 지정한다. 즉, 기술적으로 호스팅 환경이 아니라 자바스크립트 범위 내부에 있다.
이 변경의 주된 이유는 promise의 도입인데, 그 이유는 이벤트 루프 대기열에서 스케줄링 작업을 직접적이고 세밀하게 제어할 수 있는 능력을 필요로 하기 때문이다.

---

## 병렬 스레딩

"비동기"와 "병렬" 두 단어를 혼동하는 경우가 많지만 이 둘은 상당히 다르다. 비동기는 현재와 나중 사이의 간격에 관한 것이고, 병렬은 동시에 발생할 수 있는 일에 관한 것이다.
병렬 컴퓨팅을 위한 가장 일반적인 도구는 프로세스와 스레드이다. 프로세스와 스레드는 독립적 / 동시에 실행될 수 있다. 별도의 프로세서 또는 컴퓨터에서 실행되지만 여러 스레드가 단일 프로세스의 메모리를 공유할 수 있다.

이와 반대로 이벤트 루프는 자신이 할 일을 작업으로 나누고 직렬로 실행하여 병렬 액세스 및 메모리 공유를 허용하지 않는다. 병렬과 직렬은 별도의 스레드에서 이벤트 루프를 돕는 형태로 공존할 수 있다.
병렬 실행 스레드의 인터리빙과 비동기 이벤트의 인터리빙은 상당히 다른 레벨의 세분화를 가지고 있다.

```js
function later() {
  answer = answer * 2;
  console.log("Meaning of life: ", answer);
}
```

`later()`의 전체 내용은 이벤트 루프 대기열 항목으로 간주되지만, 이 코드가 실행될 스레드에는 여러개의 다른 저수준 작업이 존재할 수 있다.
단일 스레드 환경에서는 스레드를 인터럽트 할 수 없기 때문에 스레드 대기열 항목이 저수준이라는 것이 중요하지 않다.
그러나 두 개의 다른 스레드가 동일한 프로그램에서 작동하는 병렬 시스템인 경우, 예측할 수 없는 동작이 발생할 확률이 높다.

```js
var a = 20;

function foo() {
  a = a + 1;
}

function bar() {
  a = a * 2;
}

ajax("http://some.url.1", foo);
ajax("http://some/url.2", bar);
```

자바스크립트의 단일 스레드에서 `foo()`가 `bar()` 전에 실행되면 a가 42라는 결과가 나오지만,
`bar()`가 `foo()`보다 이전에 실행되면 a는 41이 된다.
그러나 동일한 데이터를 공유하는 js 이벤트가 병렬로 실행되면 더 큰 문제가 발생한다.
두 코드의 작업을 각각 실행할 수 있는 스레드로 간주하고 정확히 동시에 실행된다면 어떤 일이 발생하는지 고려해야 한다.
X와 Y는 일시적인 메모리 저장 공간이다. <br />

**Thread 1**

```js
foo():
    a. load value of 'a' in 'X'
    b. store '1' in 'Y'
    c. add 'X' and 'Y', store result in 'X'
    d. store value of 'X' in 'a'
```

**Thread 2**

```js
bar():
    a. load value of 'a' in 'X'
    b. store '2' in 'Y'
    c. multiply 'X' and 'Y', store result in 'X'
    d. store value of 'X' in 'a'
```

이 둘이 병렬로 진행된다면 공유 메모리인 X와 Y를 사용하게 되는데, 문제를 발견할 수 있을 것이다.

```js
1a (load value of `a` in `X` ==> `20`)
2a (load value of `a` in `X` ==> `20`)
1b (store `1` in `Y` ==> `1`)
2b (store `2` in `Y` ==> `2`)
1c (add `X` and `Y`, store result in `X`
1d (store value of `X` in `a` ==> `22`)
2c (multiply `X` and `Y`, store result in `X` ==> `44`) 2d (store value of `X` in `a` ==> `44`)
```

a는 44일 것이다. 그러나 이러한 순서라면 어떻게 될까?

```js
1a (load value of `a` in `X` ==> `20`)
2a (load value of `a` in `X` ==> `20`)
2b (store `2` in `Y` ==> `2`)
1b (store `1` in `Y` ==> `1`)
2c (multiply `X` and `Y`, store result in `X` ==> `20`)
1c (add `X` and `Y`, store result in `X` ==> `21`)
1d (store value of `X` in `a` ==> `21`)
2d (store value of `X` in `a` ==> `21`)
```

a는 21이다. 스레드 프로그래밍은 굉장히 까다롭다. 이러한 종류의 인터럽트가 발생하는 것을 막기 위한 특별한 조치를 취하지 않는다면, 예상치 못한 결과가 나오기 때문이다.
자바스크립트는 스레드 간에 데이터를 공유하지 않으며, 이는 비결정성 수준은 문제가 되지 않는다. 하지만 그렇다고 해서 자바스크립트가 항상 결정적이라는 것을 의미하지는 않는다.

### Run-to-Completion

자바스크립트의 싱글 스레딩 때문에 각 함수 내부의 코드는 원자적이다. 즉, 하나의 함수가 실행되기 시작하면 다음 함수가 실행되기 전에 해당 함수의 코드를 완료한다. 이것을 run-to-completion(완료까지 실행)이라고 한다.
사실 완료까지 실행의 의미는 다음과 같은 경우에 더 분명하다.

```js
var a = 1;
var b = 2;

function foo() {
  a++;
  b = b * a;
  a = b + 3;
}

function bar() {
  b--;
  a = 8 + b;
  b = a * 2;
}

ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

`foo()`는 `bar()`에 의해 중단될 수 없고, 반대의 경우도 마찬가지이기 때문에 이 프로그램은 어떤 함수가 먼저 실행되기 시작하느냐에 따른 두 가지 결과를 가지는 것만 가능하다.
Chunk1은 동기식(지금 발생)이지만, Chunk2와 3은 시간 간격으로 분리되어 비동기식(나중에 발생)으로 실행된다.

**Chunk1**

```js
var a = 1;
var b = 2;
```

**Chunk2** `foo()` :

```js
a++;
b = b * a;
a = b + 3;
```

**Chunk3** `bar()` :

```js
b--;
a = 8 + b;
b = a * 2;
```

Chunk2와 3은 둘 중 하나가 먼저 발생할 수 있으므로, 다음 두가지 결과가 있을 수 있다.

**Outcome1**

```js
var a = 1;
var b = 2;

// foo()
a++;
b = b * a;
a = b + 3;

// bar()
b--;
a = 8 + b;
b = a * 2;

a; // 11
b; // 22
```

**Outcome2**

```js
var a = 1;
var b = 2;

// bar()
b--;
a = 8 + b;
b = a * 2;

// foo()
a++;
b = b * a;
a = b + 3;

a; // 183
b; // 180
```

같은 코드에서 두 결과가 나왔고, 여전히 비결정성이 있다.
그러나 쓰레드와 같이 명령문 순서 수준이 아니라 함수(이벤트) 수준이다. 즉, 스레드 보다 더 결정적이다.

자바스크립트 동작에 적용되었듯이, 어떤 함수가 먼저 실행되는지 보기 위해 서로 경쟁하기 때문에 함수 순서 비결정론은 일반적인 용어로 "경쟁 조건"이다.
특히 a와 b가 어떻게 나올지 확실하게 예측할 수 없기 때문이다.

---

## 동시성

동시성은 개별 구성 작업이 병렬로(별도의 프로세서에서 동일한 순간에) 발생하는지 여부에 관계 없이, 두 개 이상의 프로세스가 동일한 기간동안 동시에 실행되는 경우이다.
동시성은 작업 수준 병렬처리(별도 프로세서 스레드)와 반대되는 "프로세스" 수준 병렬 처리로 생각할 수 있다.

프로세스1와 프로세스2는 동시에 실행되지만, 개별 이벤트는 이벤트 루프 대기열에서 순차적으로 실행된다.  
단일 스레드 이벤트 루프는 동시성의 한 표현이다.

### 비상호작용

둘 이상의 프로세스가 동일한 프로그램 내에서 동시에 이벤트를 인터리브 하므로 작업이 관련되지 않은 경우 서로 상호작용 할 필요가 없다.
상호작용하지 않는다면 비결정론은 완벽하게 받아들여질 수 있다.

```js
var res = {};

function foo(results) {
  res.foo = results;
}

function bar(results) {
  res.bar = results;
}

ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

두 함수는 두 개의 동시 프로세스이며, 실행될 순서는 결정되지 않았다. 그러나 실행 순서가 중요하지 않도록 프로그램을 구성했다.
상호작용 할 필요가 없다. 코드는 순서에 관계없이 항상 올바르게 작동하므로 "경쟁 조건" 버그가 아니다.

### 상호작용

더 일반적으로 동시 프로세스는 스코프 또는 DOM을 통해 간접적으로 필요에 따라 상호작용한다. 이러한 상호작용이 발생하면 "경쟁 조건"을 방지하기 위해 상호작용을 조정해야 한다.
다음은 암시적 순서로 인해 상호작용하는 두 개의 프로세스에 대한 예제이다.

```js
var res = [];

function response(data) {
  res.push(data);
}

ajax("http://some.url.1", response);
ajax("http://some.url.2", response);
```

동시 프로세스는 ajax 응답을 처리하기 위해 두 개의 `response()`를 호출한다. 둘 중 어느 쪽이던 우선 순위에 따라 먼저 일어날 수 있다.

예상되는 동작이 res[0]에 url.1 호출 결과가 있고, res[1]에 url.2 호출 결과가 있다고 가정해보자.
어떤 호출이 먼저 끝나느냐에 따라 바뀔 수도 있다. 이 비결정성은 "경쟁 조건" 버그일 가능성이 높다.

두 요청이 동일한 서버로 가고 의도적으로 특정 순서로 응답하더라도 응답이 브라우저에 다시 도착하는 순서에 대한 확실한 보장은 없다.
이러한 경쟁 조건을 해결하기 위해 순서대로 상호 작용을 조정할 수 있다.

```js
var res = [];

function response(data) {
  if (data.url == "http://some.url.1") {
    res[0] = data;
  } else if (data.url == "http://some.url.2") {
    res[1] = data;
  }
}

ajax("http://some.url.1", response);
ajax("http://some.url.2", response);
```

여러 동시 함수 호출이 공유 DOM을 통해 서로 상호작용 하는 경우, 이 시나리오에 동일한 추론이 적용된다.
예를 들어 콘텐츠가 존재하기 전에 DOM 요소를 표시하고 싶지 않을 수 있으므로, 조정은 적절한 순서로 상호작용을 보장해야 한다.
일부 동시성 시나리오는 조정된 상호작용 없이 항상 중단된다.

**Note**:
이 모든 경우에서 단순한 설명을 위해 전역 변수를 사용했지만 여기에 필요한 추론은 없다.
해당 함수가 스코프를 통해 변수에 액세스 할 수 있는 한, 의도한 대로 작동한다. Lexical scope 변수와 같이 전역 변수에 의존하는 것은 동시성 조정의 명백한 단점 중 하나이다.

### Cooperation

동시성 조정의 또다른 표현은 "협동적 동시성"이다. 장기간 실행되는 프로세스를 단계 또는 배치로 분할하여 다른 동시 프로세스가 해당 작업을 이벤트 루프 대기열에 삽입할 기회를 갖도록 하는 것이다.
예를 들어, 값을 변환하기 위해 긴 결과 목록을 실행해야 하는 ajax 응답 핸들러를 생각해보자. 코드를 더 짧게 유지하기 위해 map을 사용할 것이다.
프로세스가 실행되는 동안 다른 `response(..)` 호출, UI 업데이트, 스크롤, 입력, 버튼 클릭과 같은 사용자 이벤트를 포함하여 페이지에서 다른 어떤 일도 발생할 수 없다.
따라서 이벤트 루프 대기열을 차지하지 않는 보다 협력적인 동시 시스템을 만들기 위해 이러한 결과를 비동기식 일괄 처리로 처리할 수 있다.

```js
var res = [];
// `response(..)` receives array of results from the Ajax call

function response(data) {
  var chunk = data.splice(0, 1000);
  res = res.concat(
    chunk.map(function (val) {
      return val * 2;
    })
  );

  if (data.length > 0) {
    setTimeout(function () {
      response(data);
    }, 0);
  }
}

ajax("http://some.url.1", response);
ajax("http://some.url.2", response);
```

1000개 항목의 최대 크기로 데이터 세트를 처리한다. 그렇게 함으로써 이벤트 루프 대기열에 인터리빙이 훨씬 더 성능 좋은 사이트를 제공하므로 더 많은 후속 프로세스를 의미하더라도 단기 실행되는 프로세스를 보장한다.
물론, 프로세스의 순서를 상호작용 조정 하지는 않으므로 결과의 순서는 예측할 수 없다.
순서 지정이 필요한 경우 상호작용 기술이나 책 뒷부분에서 다룰 기술을 사용해야 한다.
우리는 비동기 스케줄링을 위해 `setTimeout(..)`을 사용하는데, 이는 기본적으로 현재 이벤트 루프 큐의 끝에 이 함수를 고정시킨다.

---

## Jobs

ES6부터 이벤트 큐 루프 위에 "작업 큐"라는 새로운 개념이 도입되었다.
가장 많이 쓰이는 것은 promise의 비동기 동작이다. 따라서 이러한 작업이 어떻게 예약되고 처리되는지 이해할 수 있어야 한다.

이벤트 루프 대기열은 줄 뒤로 돌아가서 순서가 될 때 까지 기다려야 하지만, 작업 대기열은 기다리지 않고 바로 다시 실행되는 개념이다.
Jobs는 일종의 `setTimeout(..)`과 비슷하지만 훨씬 잘 정의되어있고 보장된 순서를 갖는 방식으로 구현된다.

---

## 구문 순서

코드에서 명령문을 표현하는 순서는 js 엔진이 실행하는 순서와 반드시 같을 필요는 없다.
언어의 규칙과 문법은 프로그램 관점에서 명령문 순서에 대해 예측 가능하게 하고, 신뢰할 수 있는 동작을 지시한다.

```js
var a, b;

a = 10;
b = 30;

a = a + 1;
b = b + 1;

console.log(a + b); // 42
```

이 코드에는 비동기식으로 표현된 것이 없다. 그러나 js 엔진이 코드를 컴파일 한 후에 이러한 명령문의 순서를 재배열하여 코드를 더 빠르게 실행할 수도 있다.
자바스크립트 엔진이 최종적으로 관찰 가능한 결과가 동일하면 컴파일 중에 안전한 최적화를 수행하는 것이지만, 허용될 수 없는 경우도 있다.

컴파일러의 재정렬이 관찰 가능한 부작용을 생성하는 다른 예는 부작용이 있는 함수 호출 또는 프록시 객체가 있다.
