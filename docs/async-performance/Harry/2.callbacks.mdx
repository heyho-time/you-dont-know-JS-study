---
title: 2. Callbacks
tags: [Callbacks]
sidebar_position: 2
---

<br />

## 들어가며

1장에서는 JavaScript의 비동기 프로그래밍에 대한 용어와 개념을 살펴보았습니다.

우리의 초점은 모든 **"이벤트"(비동기 함수 호출)**를 구동하는 단일 스레드(한 번에 하나씩) 이벤트 루프 대기열을 이해하는 것입니다.

또한 동시성 패턴이 동시에 실행되는 이벤트 체인 또는 "프로세스"(작업, 함수 호출 등) 간의 관계(있는 경우!)를 설명하는

다양한 방법을 탐구했습니다.

1장의 모든 예제에서는 함수를 개별적이고 나눌 수 없는 작업 단위로 사용하여 함수 내에서 명령문이

예측 가능한 순서로(컴파일러 수준 이상!) 실행되지만 함수 순서 수준에서는 **이벤트(일명 비동기 함수 호출)**가 실행됩니다.

다양한 순서로 발생할 수 있습니다.

이 모든 경우에 함수는 대기열의 해당 항목이 처리될 때마다 프로그램으로 **"콜백"**하는 이벤트 루프의 대상 역할을 하기 때문에

**"콜백"**으로 작동합니다. 의심할 여지 없이 관찰한 바와 같이 콜백은 JS 프로그램에서 비동기가

표현되고 관리되는 가장 일반적인 방법입니다. 실제로 콜백은 언어에서 가장 기본적인 비동기 패턴입니다.

셀 수 없이 많은 JS 프로그램, 심지어 매우 정교하고 복잡한 프로그램도

콜백(1장에서 살펴본 동시성 상호 작용 패턴 포함) 외에 다른 비동기 기반으로 작성되지 않았습니다.

콜백 함수는 JavaScript의 비동기 작업 말이며 적절하게 작업을 수행합니다.

다만... 콜백에 단점이 없는 것은 아닙니다. 많은 개발자들이 더 나은 비동기 패턴에 대한

약속(말장난!)에 흥분합니다. 그러나 추상화가 무엇인지, 왜 추상화하는지 이해하지 못한다면

어떤 추상화도 효과적으로 사용하는 것은 불가능합니다.

이 장에서 우리는 더 정교한 비동기 패턴(이 책의 다음 장에서 탐구)이 왜 필요하고

바람직한지에 대한 동기로서 그 중 몇 가지를 심층적으로 탐색할 것입니다.

---

## Continuations

1장에서 시작한 비동기 콜백 예제로 돌아가 보겠습니다.

하지만 요점을 설명하기 위해 약간 수정하겠습니다.

```jsx

// A
ajax( "..", function(..){
    // C
} );
// B
```

// A와 // B는 프로그램의 전반부(현재)를 나타내고 // C는 프로그램의 후반부(나중)를 나타냅니다.

전반부는 즉시 실행되고 그 다음에는 **불확실한 길이의 "일시 중지"**가 있습니다.

미래의 어느 시점에 Ajax 호출이 완료되면 프로그램은 중단된 부분부터 다시 시작하여 후반부를 계속할 것입니다.

다시 말해, 콜백 함수는 프로그램의 연속을 감싸거나 캡슐화합니다. 코드를 더 간단하게 만들어 보겠습니다.

```jsx
// A
setTimeout(function () {
  // C
}, 1000); // B
```

잠시 멈추고 프로그램이 작동하는 방식을 (JS 작동 방식에 대해 잘 모르는 다른 사람에게) 어떻게 설명할 것인지

자문해 보십시오. 큰 소리로 시도해 보세요. 다음 요점을 더 이해하는 데 도움이 되는 좋은 연습입니다.

대부분의 독자는 이제 "A를 수행한 다음 1,000밀리초를 기다리도록 타임아웃을 설정하고 실행되면 C를 수행하십시오."와 같은

효과에 대해 생각하거나 말했을 것입니다.

"A를 수행하고 1,000밀리초 동안 시간 제한을 설정한 다음 B를 수행하고 시간 초과가 발생한 후 C를 수행하십시오."라고 스스로 편집했을 수 있습니다.

첫 번째 버전보다 더 정확합니다. 차이점을 알 수 있습니까?

두 번째 버전이 더 정확하기는 하지만 두 버전 모두 우리의 두뇌를 코드와 일치시키고 코드를 JS 엔진과 일치시키는

방식으로 이 코드를 설명하는 데 부족합니다. 연결 해제는 미묘하고 기념비적이며 비동기식 및

관리로서의 콜백의 단점을 이해하는 데 핵심입니다.

콜백 함수의 형태로 단일 연속(또는 많은 프로그램이 수행하는 수십 개!)을 도입하자마자

우리는 두뇌가 작동하는 방식과 코드가 작동하는 방식 사이에 분기가 형성되도록 허용했습니다.

이 두 가지가 갈라질 때마다(그리고 이것이 일어나는 유일한 장소는 아닙니다! 제가 확신하는 것처럼!)

우리는 우리 코드가 이해하고 추론하고 디버그하고 유지하기가 더 어려워진다는 피할 수 없는 사실에 직면합니다.

## Sequential Brain 순차적인 뇌

독자 여러분 중 대부분은 누군가가 "나는 멀티태스커입니다."라고 말하는 것을 들었을 것이라고 확신합니다.

멀티태스킹의 효과는 유머러스한 것(예: 머리를 쓰다듬고 위를 문지르는 어린이용 게임)에서

평범한 것(걸으면서 껌을 씹는 것)에서 완전히 위험한 것(운전 중 문자 메시지 보내기)에 이르기까지 다양합니다.

그러나 우리는 멀티 태스킹입니까? 한 번에 두 가지 의식적이고 의도적인 행동을 하고

정확히 같은 순간에 두 가지 모두에 대해 생각/추론할 수 있습니까?

우리의 최고 수준의 두뇌 기능에 병렬 멀티스레딩이 있습니까?

대답은 당신을 놀라게 할 것입니다. 아마도 아닐 것입니다.

그것은 우리의 두뇌가 실제로 어떻게 설정되어 있는 것처럼 보이는 것이 아닙니다.

우리는 우리 중 많은 사람들보다 훨씬 더 많은 단일 작업을 수행합니다(특히 A-유형 성격!)

인정하고 싶습니다. 우리는 주어진 순간에 한 가지만 생각할 수 있습니다.

나는 심장 박동, 호흡 및 눈꺼풀 깜박임과 같은 비자발적, 무의식적, 자동 뇌 기능에 대해 말하는 것이 아닙니다.

그것들은 모두 우리의 지속적인 삶에 필수적인 작업이지만 우리는 의도적으로 두뇌 능력을 할당하지 않습니다.

고맙게도 3분 만에 15번째 소셜 네트워크 피드를 확인하는 데 집착하는 동안 우리의 두뇌는

모든 중요한 작업을 백그라운드(스레드!)에서 계속합니다.

대신 현재 우리 마음의 최전선에 있는 작업에 대해 이야기하고 있습니다. 정확히 같은 순간에 다른 더 높은 수준의 뇌 기능을 수행하고 있습니까?

우리는 빠르고 쉽게 주의가 산만해집니다.

친구나 가족과 전화 통화를 하면서 동시에 무언가를 입력하려고 하는 것처럼 가짜 멀티태스킹을 할 때 실제로

가장 많이 하는 일은 빠른 **컨텍스트 전환기** 역할을 하는 것입니다. 다시 말해서, 우리는

두 개 이상의 작업을 빠르게 연속적으로 앞뒤로 전환하면서 동시에 각 작업을 작고 빠른 작은 덩어리로 진행합니다.

우리는 그것을 너무 빨리 해서 외부 세계에 우리가 이 일들을 병렬로 하고 있는 것처럼 보입니다.

비동기 이벤트 동시성(JS에서 발생하는 정렬과 같은)처럼 의심스러울 정도로 들리나요? 그렇지 않다면

돌아가서 1장을 다시 읽으십시오!

사실, 엄청나게 복잡한 신경학 세계를 여기에서 논의할 수 있는 것으로 단순화(즉, 남용)하는

한 가지 방법은 우리의 두뇌가 **이벤트 루프 대기열**처럼 작동한다는 것입니다.

---

## Doing vs Planning

따라서 우리의 두뇌는 JS 엔진과 마찬가지로 **단일 스레드 이벤트 루프 대기열에서 작동하는 것**으로 생각할 수 있습니다.

좋은 궁합인 것 같습니다. 그러나 우리는 분석에서 그보다 더 미묘한 차이가 필요합니다.

우리가 다양한 작업을 계획하는 방법과 우리의 두뇌가 실제로 이러한 작업을 작동하는 방법 사이에는

크고 관찰 가능한 차이가 있습니다.

다시, 나의 은유로서 이 텍스트의 쓰기로 돌아갑니다. 여기에서 나의 대략적인 정신적 개요 계획은

계속해서 쓰고, 생각에서 주문한 일련의 요점을 순차적으로 진행하는 것입니다.

나는 이 글을 쓰는 데 방해나 비선형 활동을 할 계획이 없습니다. 그러나 그럼에도 불구하고 내 두뇌는 항상

전환하고 있습니다. 작동 수준에서 우리의 두뇌는 비동기식 이벤트가 발생하지만 우리는 순차적이고 동기적인

방식으로 작업을 계획하는 것 같습니다. "가게에 가서 우유를 사서 드라이클리닝을 맡겨야 해요."

이 더 높은 수준의 사고(계획)가 공식화에서 매우 비동기적으로 발생하는 것처럼 보이지 않는다는 것을 알 수 있습니다.

사실, 우리가 의도적으로 사건의 관점에서만 생각하는 것은 드뭅니다. 대신, 우리는 순차적으로(A, B, C) 신중하게

계획을 세우고 B가 A를, C가 B를 기다리도록 하는 일종의 일시적 차단을 가정합니다.

개발자는 코드를 작성할 때 발생할 일련의 작업을 계획하고 있습니다.

개발자가 되는 데 소질이 있다면 신중하게 계획하고 있습니다. "z를 x 값으로 설정한 다음 x를 y 값으로 설정해야 합니다." 등입니다.

동기 코드를 문별로 작성할 때 심부름 할 일 목록과 매우 유사하게 작동합니다.

```jsx
// swap `x` and `y` (via temp variable `z`)
z = x;
x = y;
y = z;
```

이 세 가지 할당 문은 동기식이므로 `x = y`는 `z = x`가 완료되기를 기다리고 `y = z`는 `x = y`가 완료되기를 차례로 기다립니다.

이를 다른 말로 표현하면 이 세 가지 명령문이 시간적으로 특정 순서로 실행되어야 한다는 것입니다.

고맙게도 여기에서 비동기 이벤트 세부 정보로 귀찮게 할 필요가 없습니다.

그렇게 하면 코드가 훨씬 더 복잡해지고 빨라집니다!

따라서 동기식 두뇌 계획이 동기식 코드 문에 잘 매핑된다면 우리 두뇌는 비동기식 코드를 계획하는 데

얼마나 잘 할 수 있을까요?

코드에서 **비동기식(콜백 포함)을 표현하는 방법**은 동기식 두뇌 계획 동작에 전혀 잘 매핑되지 않는 것으로 나타났습니다.

이런 식으로 할 일을 계획하는 생각을 하는 것을 실제로 상상할 수 있습니까?

```jsx
가게에 가야 하는데 가는 길에 전화가 올 것 같아서 '안녕, 엄마'라고 하고 그녀가 말을 시작하는 동안
GPS로 가게 주소를 찾아보고, 하지만 로드하는 데 몇 초가 걸릴 것이므로 엄마가 더 잘 들을 수 있도록
라디오를 끌 것입니다. 그러면 재킷을 입는 것을 잊었고 밖이 춥다는 것을 알게 될 것입니다.
하지만 상관없이 계속 운전하고 이야기하십시오. 엄마에게 말을 하고 안전벨트를 맟추라고 해서
 '예, 엄마, 저는 항상 안전벨트를 매고 있어요!'라고 했습니다. 아, 드디어 GPS가 길을 알려줬습니다.
 이제..."
```

그것이 우리가 하루를 어떻게 계획하고 무엇을 해야 하는지, 어떤 순서로 생각하는지에 대한 공식처럼

들리겠지만, 그럼에도 불구하고 그것은 우리의 두뇌가 기능적 수준에서 작동하는 방식입니다.

멀티태스킹이 아니라 빠른 컨텍스트 전환이라는 것을 기억하십시오.

개발자가 비동기 이벤트 코드를 작성하는 것이 어려운 이유는, 특히 우리가 이를 수행하기 위한 콜백만 있는 경우에는

대부분의 사람들에게 의식의 흐름 사고/계획이 부자연스럽기 때문입니다.

<br />

우리는 단계별 용어로 생각하지만 코드에서 사용할 수 있는 도구 **(콜백)**는

동기식에서 비동기식으로 이동하면 단계별 방식으로 표현되지 않습니다.

이것이 바로 비동기 JS 코드를 콜백으로 정확하게 작성하고 추론하는 것이 어려운 이유입니다.

이는 두뇌 계획이 작동하는 방식이 아니기 때문입니다.

참고: 일부 코드가 깨지는 이유를 모르는 것보다 더 나쁜 것은 처음부터 작동한 이유를 모르는 것입니다!

이것은 고전적인 "카드의 집" 사고 방식입니다. "작동하지만 이유를 모르니 아무도 만지지 마세요!"

"지옥은 다른 사람이다"(Sartre)라는 말을 들었을 수도 있습니다.

하지만 사실은, "지옥은 내 코드를 이해하지 못하는 것입니다." 그리고 콜백이 주요 원인 중 하나입니다.

---

## Nested/Chained Callbacks

```jsx
listen("click", function handler(evt) {
  setTimeout(function request() {
    ajax("http://some.url.1", function response(text) {
      if (text == "hello") {
        handler();
      } else if (text == "world") {
        request();
      }
    });
  }, 500);
});
```

당신이 알아볼 수 있는 좋은 기회 코드가 있습니다.

함께 중첩된 세 개의 함수 체인이 있으며 각각은 비동기 시리즈(작업, "프로세스")의 단계를 나타냅니다.

이러한 종류의 코드는 종종 **"콜백 지옥"**이라고 하며, 때로는 **"파멸의 피라미드"**(중첩 들여쓰기로 인해 옆으로 향하는 삼각형 모양 때문에)

라고도 합니다.

그러나 **"콜백 지옥"**은 실제로 중첩/들여쓰기와 거의 관련이 없습니다.

그것은 그것보다 훨씬 더 깊은 문제입니다. 이 장의 나머지 부분을 계속 진행하면서 방법과 이유를 살펴보겠습니다.

먼저 "클릭" 이벤트를 기다린 다음 타이머가 실행될 때까지 기다린 다음 Ajax 응답이 다시 올 때까지 기다리며

이 시점에서 모든 작업을 다시 수행할 수 있습니다.

언뜻 보기에 이 코드는 비동기식을 순차적인 두뇌 계획에 자연스럽게 매핑하는 것처럼 보일 수 있습니다. 먼저 (현재), 우리는:

First, we:

```jsx
listen( "..", function handler(..){
    // ..
} );
```

Then later, we:

```jsx
setTimeout( function request(..){
    // ..
}, 500);
```

Then still later, we:

```jsx

ajax( "..", function response(..){
    // ..
});
```

and finally (most later), we:

```jsx
 if ( .. ) {
     // ..
}
else ..
```

그러나 이러한 방식으로 이 코드를 선형적으로 추론하는 데는 몇 가지 문제가 있습니다.

첫째, 우리의 단계가 후속 라인(1, 2, 3, 4...)에 있다는 것은 예제의 우연입니다.

실제 비동기 JS 프로그램에는 종종 훨씬 더 많은 잡음이 복잡하게 얽혀 있습니다.

우리가 한 기능에서 다음 기능으로 이동할 때 우리의 두뇌에서 솜씨 좋게 과거를 조종해야 하는

소음이 있습니다. 이러한 콜백이 포함된 코드에서 비동기 흐름을 이해하는 것이

불가능한 것은 아니지만 많은 연습을 해도 자연스럽거나 쉽지는 않습니다.

그러나 또한 그 코드 예제에서만 분명하지 않은 더 깊은 잘못이 있습니다.

설명하기 위해 다른 시나리오(의사 코드-ish)를 만들어 보겠습니다.

```jsx
doA(function () {
  doB();

  doC(function () {
    doD();
  });

  doE();
});

doF();
```

경험이 많은 사람이 여기에서 실제 작업 순서를 정확하게 식별할 수 있지만,

언뜻 보기에는 약간 혼란스럽고 도달하려면 몇 가지 일치된 정신 주기가 필요합니다.

작업은 다음 순서로 수행됩니다.

```jsx
doA() doF() doB() doC() doE() doD()

```

코드를 처음 봤을 때 정확히 이해하셨나요?

좋아요, 당신 중 일부는 내가 의도적으로 당신을 잘못된 길로 이끌기 위해 함수 이름을 지정하는 것이라고

부당하다고 생각합니다. 나는 위에서 아래로 보이는 순서대로 이름을 지었다고 맹세합니다.

하지만 다시 시도하겠습니다.

```jsx
doA(function () {
  doC();

  doD(function () {
    doF();
  });

  doE();
});

doB();
```

이제 실제 실행 순서대로 알파벳순으로 이름을 지정했습니다.

그러나 나는 여전히 이 시나리오에 대한 경험이 있음에도 불구하고 `A -> B -> C -> D -> E -> F`순서를 추적하는 것이

독자 중 많은 사람들에게 자연스럽지 않을 것이라고 확신합니다.

확실히 당신의 눈은 코드 조각을 위아래로 점프하는 것을 엄청나게 많이 하지 않습니까?

그러나 그것이 모두 당신에게 자연스럽더라도, 혼란을 일으킬 수 있는 또 하나의 위험이 있습니다.

그것이 무엇인지 알 수 있습니까?

**doA(..)** 또는 **doD(..)**가 실제로 비동기가 아닌 경우에는 어떻게 될까요?

지금은 순서가 다릅니다. 둘 다 동기화된 경우(당시 프로그램 조건에 따라 가끔만 가능) 순서는

이제 `A -> C -> D -> F -> E -> B`입니다.

중첩이 문제입니까? 이것이 비동기 흐름을 추적하는 것을 어렵게 만드는 이유입니까?

그것은 확실히 그것의 일부입니다.

하지만 중첩을 사용하지 않고 이전 중첩 이벤트/시간 초과/Ajax 예제를 다시 작성하겠습니다.

```jsx
listen("click", handler);

function handler() {
  setTimeout(request, 500);
}

function request() {
  ajax("http://some.url.1", response);
}

function response(text) {
  if (text == "hello") {
    handler();
  } else if (text == "world") {
    request();
  }
}
```

이 코드 공식은 이전 형식의 중첩/들여쓰기 문제만큼 인식할 수 없지만 **"콜백 지옥"**에 취약합니다.

이 코드에 대해 선형적으로(순차적으로) 이유를 설명할 때 한 함수에서 다음 함수로 건너뛰고 코드 기반 전체를 바운스하여

시퀀스 흐름을 "확인"해야 합니다. 그리고 이것은 최상의 케이스 방식으로 단순화된 코드라는 것을 기억하십시오.

우리 모두는 실제 비동기 JS 프로그램 코드 기반이 종종 환상적으로 더 뒤죽박죽이 되어 그러한 추론을

훨씬 더 어렵게 만든다는 것을 알고 있습니다.

주의해야 할 또 다른 사항: 2, 3, 4단계를 함께 연결하여 연속적으로 발생하도록 하려면

2단계를 1단계로, 3단계를 2단계로, 4단계를 3단계로, 4단계를 3단계로 하드코딩하는 것뿐입니다.

2단계가 항상 3단계로 이어져야 하는 고정된 조건이라면 하드코딩이 반드시 나쁜 것은 아닙니다.

그러나 하드코딩은 단계 진행에서 편차를 유발할 수 있는 잘못되는 것을 설명하지 않기 때문에

확실히 코드를 좀 더 취약하게 만듭니다. 예를 들어, 2단계가 실패하면 3단계에 도달하지 않으며

2단계를 다시 시도하거나 대체 오류 처리 흐름으로 이동하는 식입니다.

이러한 모든 문제는 수동으로 각 단계에 하드코딩할 수 있는 문제이지만 해당 코드는 종종 매우 반복적이며

다른 단계나 프로그램의 다른 비동기 흐름에서 재사용할 수 없습니다.

우리의 두뇌가 일련의 작업을 순차적 유형(이것, 다음, 이)으로 계획할 수 있지만 두뇌 작동의 이벤트 특성으로 인해

흐름 제어의 복구/재시도/포킹이 거의 수월하게 이루어집니다.

심부름을 하러 나가서 집에 쇼핑 목록을 남겨두었다는 것을 알게 되더라도 미리 계획하지 않았기 때문에

하루가 끝나지 않습니다. 당신의 두뇌는 이 딸꾹질을 쉽게 우회합니다. 집에 가서 목록을 받은 다음 곧바로 상점으로 돌아갑니다.

그러나 수동으로 하드코딩된 콜백의 취약한 특성(하드코딩된 오류 처리 포함)은 종종 훨씬 덜 우아합니다.

다양한 상황/경로를 모두 지정(사전 계획이라고도 함)하게 되면 코드가 너무 복잡해져서 유지 관리하거나 업데이트하기가 어렵습니다.

그것이 바로 **"콜백 지옥"**에 관한 것입니다! 중첩 / 들여 쓰기는 기본적으로 사이드 쇼, 청어입니다.

그리고 그것만으로는 충분하지 않은 것처럼 두 개 이상의 콜백 연속 체인이 동시에 발생하거나

세 번째 단계가 게이트 또는 래치가 있는 **"병렬"** 콜백으로 분기할 때 어떤 일이 발생하는지 다루지 않았습니다.

여기서 우리의 순차적 차단 두뇌 계획 동작이 콜백 지향 비동기 코드에 잘 매핑되지 않는다는 개념을 이해하고 계십니까?

이것이 콜백에 대해 명확히 설명할 수 있는 첫 번째 주요 결함입니다.

---

## Trust Issues

순차적 두뇌 계획과 콜백 기반 비동기 JS 코드 간의 불일치는 콜백 문제의 일부일 뿐입니다.

훨씬 더 깊이 우려해야 할 것이 있습니다.

콜백 함수의 개념을 **프로그램의 연속(후반부라고도 함)**으로 다시 한 번 살펴보겠습니다.

```jsx
// A
ajax( "..", function(..){ // C
} );
// B
```

`// A` 와 `// B` 는 이제 메인 JS 프로그램의 직접 제어 하에 발생합니다.

그러나 `// C` 는 나중에 다른 당사자의 제어 하에 발생하도록 연기됩니다.

이 경우에는 **ajax(..) 함수**입니다. 기본적인 의미에서, 이러한 종류의 제어 핸드오프는

정기적으로 프로그램에 많은 문제를 일으키지 않습니다.

그러나 이 제어 스위치가 큰 문제가 아니라는 빈도에 속지 마십시오.

사실, 이것은 콜백 기반 디자인에 대한 최악의(그러나 가장 미묘한) 문제 중 하나입니다.

때때로 ajax(..)(즉, 콜백 연속을 전달하는 "당사자")가 사용자가 작성했거나 직접 제어하는 ​​함수가 아니라는

아이디어를 중심으로 전개됩니다. 많은 경우 일부 타사에서 제공하는 유틸리티입니다.

귀하가 프로그램에 참여하고 프로그램 실행에 대한 제어권을 다른 제3자에게 넘길 때 이를 **"제어 역전"**이라고 합니다.

코드와 타사 유틸리티 사이에 존재하는 무언의 **"계약"**이 있습니다.

---

## Tale of Five Callbacks

이것이 왜 그렇게 큰 문제인지는 그다지 분명하지 않을 수 있습니다.

신뢰의 위험을 설명하기 위해 과장된 시나리오를 구성하겠습니다.

당신이 값비싼 TV를 판매하는 사이트를 위한 전자상거래 체크아웃 시스템을 구축하는 일을 맡은 개발자라고 상상해 보십시오.

당신은 이미 체크아웃 시스템의 모든 다양한 페이지가 잘 구축되어 있습니다.

마지막 페이지에서 사용자가 TV를 구매하기 위해 "확인"을 클릭하면 판매를 추적할 수 있도록

타사 기능(일부 분석 추적 회사에서 제공)을 호출해야 합니다.

아마도 성능 모범 사례를 위해 비동기 추적 유틸리티처럼 보이는 것을 제공했음을 알 수 있습니다.

즉, 콜백 함수를 전달해야 함을 의미합니다. 계속해서 전달하면 고객의 신용 카드에 요금을 청구하고

감사 페이지를 표시하는 최종 코드가 표시됩니다.

이 코드는 다음과 같습니다.

```jsx
analytics.trackPurchase(purchaseData, function () {
  chargeCreditCard();
  displayThankyouPage();
});
```

충분히 쉽죠? 코드를 작성하고 테스트하고 모든 것이 작동하고 프로덕션에 배포합니다.

6개월이 지나고 문제가 없습니다. 당신은 심지어 당신이 그 코드를 작성했다는 것을 거의 잊었습니다.

어느 날 아침, 당신은 출근 전 커피숍에서 여유롭게 라떼를 즐기고 있는데, 상사로부터 커피를 내려놓고

바로 일하러 가라고 하는 당황스런 전화를 받습니다.

당신이 도착했을 때, 당신은 유명한 고객이 같은 TV에 대해 신용 카드로 다섯 번이나 요금을 청구했다는

사실을 알게 되었고 그는 당연히 화를 냈습니다. 고객 서비스에서 이미 사과를 하고 환불을 처리했습니다.

그러나 상사는 어떻게 이런 일이 일어날 수 있었는지 알고 싶어 합니다. "검사는 안했나요!?"

당신은 당신이 작성한 코드조차 기억하지 못합니다. 그러나 당신은 다시 파고들어 무엇이 잘못되었을 수 있는지

알아보기 시작합니다. 일부 로그를 조사한 후 분석 유틸리티가 어떤 이유로든 콜백을 한 번이 아닌 다섯 번 호출했다는

유일한 설명이라는 결론에 도달했습니다. 그들의 문서에는 이것에 대한 언급이 없습니다.

실망한 고객 지원팀에 연락하면 고객 지원팀도 당연히 당신만큼 놀라워합니다.

그들은 개발자에게 이를 에스컬레이션하고 귀하에게 다시 연락할 것을 약속합니다. 다음 날, 발견한 내용을 설명하는

긴 이메일을 받고 즉시 상사에게 전달합니다.

분명히 분석 회사의 개발자는 특정 조건에서 제공된 콜백을 초당 한 번, 5초 동안 재시도한 후 시간 초과로 실패하는 몇 가지

실험적인 코드를 작업하고 있었습니다. 그들은 그것을 프로덕션으로 밀어 넣을 의도가 없었지만 어떻게 든 그렇게했고

완전히 당황스럽고 사과했습니다. 그들은 고장을 식별한 방법과 다시는 이러한 일이 발생하지 않도록 하기 위해

할 일에 대해 자세히 설명합니다.

what's next?

당신은 당신의 상사와 그것에 대해 이야기하지만 그는 상황에 대해 특별히 편안함을 느끼지 못합니다.

그는 당신이 그들을 더 이상 신뢰할 수 없으며, 그러한 취약점으로부터 체크아웃 코드를 다시 보호하는

방법을 알아내야 할 필요가 있을 것이라고 주장하고 당신은 마지못해 동의합니다.

약간의 수정 후에 다음과 같은 몇 가지 간단한 임시 코드를 구현합니다. 팀은 만족스러워 보입니다.

```jsx
var tracked = false;

analytics.trackPurchase(purchaseData, function () {
  if (!tracked) {
    tracked = true;
    chargeCreditCard();
    displayThankyouPage();
  }
});
```

참고: 이것은 콜백의 동시 호출이 여러 번 발생하는 경우 처리할 래치를 기본적으로 생성하기 때문에

1장에서 여러분에게 친숙하게 보일 것입니다.

그러나 QA 엔지니어 중 한 명이 "콜백을 호출하지 않으면 어떻게 되나요?"라고 묻습니다.

죄송합니다. 둘 다 그것에 대해 생각하지 않았습니다.

당신은 토끼굴을 추적하기 시작하고 그들이 당신의 콜백을 호출하는 데 잘못될 수 있는 모든 가능성을 생각합니다.

다음은 분석 유틸리티가 오작동할 수 있는 방법에 대한 대략적인 목록입니다.

- 콜백을 너무 일찍 호출.
- 콜백을 너무 늦게 호출.
- 콜백을 너무 적게 또는 너무 많이 호출.
- 필요한 환경/매개변수를 콜백에 전달하지 못함.
- ...

그것은 문제가 되는 목록처럼 느껴져야 합니다.

당신은 아마도 당신이 해야 한다는 것을 서서히 깨닫기 시작하고 있을 것입니다.

신뢰할 수 없는 유틸리티에 전달되는 모든 단일 콜백에서 엄청나게 많은 임시 로직을 만들어내십시오.

이제 "콜백 지옥"이 얼마나 지옥 같은지 조금 더 완전히 깨닫게 됩니다.

## Not Just Others' Code

여러분 중 일부는 이 시점에서 이것이 제가 말하는 것만큼 큰 문제인지 회의적일 수 있습니다.

아마도 당신은 진정으로 타사 유틸리티와 상호 작용하지 않을 것입니다.

아마도 버전이 지정된 API를 사용하거나 그러한 라이브러리를 자체 호스팅하여 해당 동작이

사용자 아래에서 변경될 수 없도록 할 수 있습니다.

따라서 다음 사항을 고려하십시오. 이론적으로 제어하는 ​​유틸리티(자신의 코드 기반에서)를 정말 신뢰할 수 있습니까?

이런 식으로 생각하십시오. 우리 대부분은 적어도 어느 정도는 일부를 사용하여 자체 내부 기능을 구축해야 한다는 데 동의합니다.

```jsx
function addNumbers(x, y) {
  // + is overloaded with coercion
  // string concatenation, so this
  // isn't strictly safe depending
  // passed in.
  return x + y;
}
addNumbers(21, 21); // 42
addNumbers(21, "21"); // "2121"
```

신뢰할 수 없는 입력에 대한 방어를 해보겠습니다.

```jsx
function addNumbers(x, y) {
  // ensure numerical input
  if (typeof x != "number" || typeof y != "number") {
    throw Error("Bad parameters");
  }
  // if we get here, + will safely do numeric addition
  return x + y;
}
addNumbers(21, 21); // 42
addNumbers(21, "21"); // Error: "Bad parameters"
```

또는 여전히 안전하지만 더 친근합니다.

```jsx
function addNumbers(x, y) {
  // ensure numerical input
  x = Number(x);
  y = Number(y);
  // + will safely do numeric addition
  return x + y;
}
addNumbers(21, 21); // 42
addNumbers(21, "21"); // 42
```

그러나 이러한 종류의 검사/정규화는 이론적으로 전적으로 신뢰하는 코드에서도 함수 입력에서 상당히 일반적입니다.

조잡한 방식으로 "신뢰하지만 확인"의 지정 학적 원칙에 해당하는 프로그래밍과 같습니다.

따라서 비동기 함수 콜백의 구성과 관련하여 동일한 작업을 수행해야 하는 것은 당연하지 않습니까?

진정한 외부 코드이지만 우리가 알고 있는 코드가 일반적으로 "우리 자신의 통제 하에" 있다는 것을

알고 있습니까? 물론 우리는 알아야 합니다.

그러나 콜백은 실제로 우리에게 도움이 되는 어떤 것도 제공하지 않습니다.

우리는 그 모든 기계를 스스로 건설해야 하고 종종 결국

모든 단일 비동기 콜백에 대해 반복하는 많은 상용구/오버헤드입니다.

콜백의 가장 골치 아픈 문제는 모든 신뢰 라인을 따라 완전한 고장으로 이어지는 제어 역전입니다.

콜백을 사용하는 코드가 있고 특히 타사 유틸리티에서만 사용하는 것은 아니며 이러한 모든 제어 신뢰 문제에 대한

일종의 완화 논리를 이미 적용하지 않은 경우 코드에 버그가 있습니다.

아직 물지 않았을 수 있습니다. 잠재된 버그는 여전히 버그입니다.

---

## Trying to Save Callbacks

우리가 방금 살펴본 신뢰 문제의 일부(전부는 아님)를 해결하기 위해 시도한 콜백 디자인의 여러

변형이 있습니다. 콜백 패턴이 스스로 무너지는 것을 방지하기 위한 용감하지만 운명적인 노력입니다.

예를 들어, 보다 우아한 오류 처리와 관련하여 일부 API 디자인은 분할 콜백을 제공합니다

(하나는 성공 알림용, 하나는 오류 알림용).

```jsx
function success(data) {
  console.log(data);
}

function failure(err) {
  console.error(err);
}

ajax("http://some.url.1", success, failure);
```

이 디자인의 API에서는 종종 `failure()` 오류 처리기가 선택 사항이며 제공되지 않으면 오류를 삼키기를 원한다고 가정합니다. 어.

참고: 이 분할 콜백 디자인은 `ES6 Promise API`가 사용하는 것입니다.

ES6 Promise는 다음 장에서 더 자세히 다룰 것입니다.

또 다른 일반적인 콜백 패턴은 "error-first style(오류 우선 스타일)"

(거의 모든 Node.js API에서 사용되는 규칙이기도 하므로 "노드 스타일"이라고도 함)이라고 합니다.

여기서 단일 콜백의 첫 번째 인수는 오류 개체 입니다.

성공하면 이 인수는 비어 있거나 거짓이 됩니다(그리고 모든 후속 인수는 성공 데이터가 됨).

그러나 오류 결과가 표시되면 첫 번째 인수는 설정/참이 됩니다(일반적으로 다른 것은 전달되지 않음).

```jsx
function response(err, data) {
  // error?
  if (err) {
    console.error(err);
  }
  // otherwise, assume success
  else {
    console.log(data);
  }
}
ajax("http://some.url.1", response);
```

이 두 경우 모두 몇 가지 사항을 준수해야 합니다.

첫째, 보이는 것처럼 대부분의 신뢰 문제를 실제로 해결하지 못했습니다.

원치 않는 반복 호출을 방지하거나 필터링하는 콜백에는 아무 것도 없습니다.

게다가 지금 상황은 더 나빠지고 있습니다. 왜냐하면 당신은 성공과

오류 신호를 보내거나 둘 ​​중 하나를 선택하지 않아도 여전히 이러한 조건 중 하나를 코딩해야 합니다.

또한 사용할 수 있는 표준 패턴이지만 재사용이 거의 없으면서 확실히 더 장황하고 상용구적이라는 사실을 놓치지 마십시오.

호출을 받지 않은 신뢰 문제는 어떻습니까? 이것이 우려되는 경우(그리고 아마도 그래야 할 것입니다!)

이벤트를 취소하는 시간 초과를 설정해야 할 것입니다.

다음과 같이 도움이 되는 유틸리티(개념 증명만 표시됨)를 만들 수 있습니다.

```jsx
function timeoutify(fn, delay) {
  var intv = setTimeout(function () {
    intv = null;
    fn(new Error("Timeout!"));
  }, delay);
  return function () {
    // timeout hasn't happened yet? if (intv) {
  };
}
```

사용 방법은 다음과 같습니다.

```jsx
// using "error-first style" callback design
function foo(err, data) {
  if (err) {
    console.error(err);
  } else {
    console.log(data);
  }
}
ajax("http://some.url.1", timeoutify(foo, 500));
```

또 다른 신뢰 문제는 "너무 이르다"는 것입니다.

응용 프로그램별 용어로, 이것은 실제로 일부 중요한 작업이 완료되기 전에 호출되는 것을 포함할 수 있습니다.

그러나 더 일반적으로 문제는 지금(동기적으로) 또는 나중에(비동기적으로) 제공하는 콜백을 호출할 수 있는

유틸리티에서 분명합니다.

동기화 또는 비동기 동작에 대한 이러한 비결정론은 거의 항상 버그를 추적하기 매우 어렵게 만듭니다.

일부 서클에서는 Zalgo라는 가상의 광기를 유발하는 괴물이 동기화/비동기 악몽을 설명하는 데 사용됩니다.

"잘고를 놓아주마!" 이것은 일반적인 외침이며 매우 건전한 조언으로 이어집니다.

이벤트 루프의 다음 차례에 "즉시"인 경우에도 항상 콜백을 비동기식으로 호출하여 모든 콜백이 예측 가능하게

비동기식으로 되도록 합니다.

```jsx
function result(data) {
  console.log(a);
}

var a = 0;
ajax("..pre-cached-url..", result);
a++;
```

이 코드는 0(동기화 콜백 호출) 또는 1을 인쇄합니까?

Zalgo의 예측 불가능성이 모든 JS 프로그램을 얼마나 빨리 위협할 수 있는지 알 수 있습니다.

따라서 어리석게 들리는 "절대로 Zalgo를 릴리스하지 마십시오"는 실제로 믿을 수 없을 정도로 일반적이고

확고한 조언입니다. 항상 비동기화 하십시오.

해당 API가 항상 비동기식으로 실행되는지 여부를 모르는 경우 어떻게 해야 합니까?

다음과 같은 asyncify(..) 개념 증명과 같은 유틸리티를 발명할 수 있습니다.

```jsx
function asyncify(fn) {
  var orig_fn = fn,
    intv = setTimeout(function () {
      intv = null;
      if (fn) fn();
    }, 0);

  fn = null;

  return function () {
    // firing too quickly, before `intv` timer has fired to
    // indicate async turn has passed?
    if (intv) {
      fn = orig_fn.bind.apply(
        orig_fn,
        // add the wrapper's `this` to the `bind(..)`
        // call parameters, as well as currying any
        // passed in parameters
        [this].concat([].slice.call(arguments))
      );
    }
    // already async
    else {
      // invoke original function
      orig_fn.apply(this, arguments);
    }
  };
}
```

You use
asyncify(..) like this:

```jsx
function result(data) {
  console.log(a);
}

var a = 0;

ajax("..pre-cached-url..", asyncify(result));
a++;
```

Ajax 요청이 캐시에 있고 즉시 콜백 호출을 시도하도록 확인되는지, 아니면 유선을 통해 가져와서

나중에 비동기식으로 완료해야 하는지 여부에 관계없이 이 코드는 항상 0 대신 1을 출력합니다

-- result(..)는 도움이 될 수 없습니다. 그러나 비동기적으로 호출됩니다.

이는 a++가 result(..)보다 먼저 실행할 수 있음을 의미합니다.

또 다른 신탁이 "해결됨"을 발행했습니다! 그러나 이는 비효율적이며 프로젝트에 무게를 실어주기 위해

다시 한 번 더 부풀려진 상용구입니다.

콜백과 함께 반복되는 이야기일 뿐입니다. 그들은 당신이 원하는 거의 모든 것을 할 수 있지만,

당신은 그것을 얻기 위해 기꺼이 열심히 노력해야 하며, 종종 이러한 노력은 그러한 코드 추론에 소비할 수 있거나

사용해야 하는 것보다 훨씬 더 많습니다.

이러한 문제를 해결하기 위해 내장 API 또는 기타 언어 메커니즘을 원할 수도 있습니다.

마침내 ES6이 몇 가지 훌륭한 답변과 함께 현장에 도착했습니다.

---

## Review

**콜백은 JS에서 비동기의 기본 단위입니다.**

그러나 JS가 성숙함에 따라 진화하는 비동기 프로그래밍 환경에는 충분하지 않습니다.

**첫째,** 우리의 두뇌는 **순차적, 차단, 단일 스레드 의미론적 방식**으로 일을 계획하지만 콜백은

오히려 **비선형적이고 비순차적인 방식의 비동기 흐름**으로 인해 이러한 코드에 대한 적절한 추론이 훨씬 더 어려워집니다.

코드에 대한 나쁜 이유는 나쁜 버그로 이어지는 나쁜 코드입니다.

우리는 우리의 두뇌가 하는 것처럼 비동기식을 보다 동기적이고 순차적이며 차단하는 방식으로 표현할 방법이 필요합니다.

**두 번째,** 그리고 더 중요한 것은 콜백이 다른 당사자(종종 사용자가 제어하지 않는 타사 유틸리티)에게

암시적으로 제어권을 넘겨서 프로그램의 계속을 호출한다는 점에서 제어 역전 문제가 있다는 것입니다.

이 제어 전송은 콜백이 예상보다 더 많이 호출되는지 여부와 같은 문제의 신뢰 문제 목록으로 이어집니다.

이러한 신뢰 문제를 해결하기 위해 임시 논리를 발명하는 것이 가능하지만 생각보다 어렵고 유지 관리가 더 복잡하고

코드를 유지 관리하기가 더 어렵습니다.

우리는 모든 추가 상용구 오버헤드 없이 생성하는 만큼 많은 콜백에 재사용할 수 있는 모든 신뢰 문제에 대한

일반화된 솔루션이 필요합니다.

콜백보다 더 나은 것이 필요합니다. 그것들은 지금까지 우리에게 도움이 되었지만

JavaScript의 미래는 더 정교하고 유능한 비동기 패턴을 요구합니다.

이 책의 다음 장에서는 이러한 새로운 진화에 대해 자세히 알아볼 것입니다.
