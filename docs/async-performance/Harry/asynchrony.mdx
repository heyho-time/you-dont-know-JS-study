---
title: 1. Asynchrony Now & Later
tags: [event loop]
sidebar_position: 1
---

<br />

## 들어가며

JavaScript와 같은 언어로 프로그래밍할 때 가장 중요하지만 종종 오해를 받는 부분 중 하나는

일정 기간 동안 프로그램 동작을 표현하고 조작하는 방법입니다.

이것은 for 루프의 시작부터 for 루프가 끝날 때까지 일어나는 일에 관한 것이 아닙니다.

물론 완료하는 데 약간의 시간(마이크로초에서 밀리초)이 걸립니다.

**프로그램의 일부가 지금 실행되고 프로그램의 다른 부분이 나중에 실행될 때 어떤 일이 발생하는지에 대한 것입니다.**

지금과 나중 사이에는 프로그램이 활발하게 실행되지 않는 간격이 있습니다.

실질적으로 지금까지 작성된 모든 중요하지 않은 프로그램(특히 JS에서)은 사용자 입력을 기다리거나, 데이터베이스 또는 파일 시스템에서 데이터를 요청하고,

네트워크를 통해 데이터를 전송하고, 응답하거나 고정된 시간 간격(예: 애니메이션)으로 반복되는 작업을 수행합니다.

이 모든 다양한 방법으로 프로그램은 시간 간격을 가로질러 상태를 관리해야 합니다.

사실, 프로그램의 현재 부분과 이후 부분 간의 관계는 **비동기 프로그래밍의 핵심**입니다.

비동기 프로그래밍은 확실히 JS 초창기부터 있었습니다. 그러나 대부분의 JS 개발자는 프로그램에서 어떻게 그리고 왜 발생하는지 정확히 주의 깊게 고려하지 않았거나

이를 처리하는 다양한 다른 방법을 탐색했습니다.

충분히 좋은 접근 방식은 항상 겸손한 **콜백 함수**였습니다. 오늘날까지 많은 사람들이 콜백이 충분하다고 주장할 것입니다.

그러나 JS가 범위와 복잡성 면에서 계속 성장함에 따라 브라우저와 서버, 그리고 그 사이에 있는 생각할 수 있는 모든 장치에서 실행되는

일류 프로그래밍 언어에 대한 계속해서 확대되는 요구를 충족하기 위해 비동기식을 관리하는 어려움은 점점 더 심각해지고 있습니다.

그리고 그들은 더 유능하고 더 합리적인 접근 방식을 요구합니다.

지금 당장은 이 모든 것이 다소 추상적으로 보일 수 있지만 이 책을 진행하면서 더 완전하고 구체적으로 다룰 것입니다.

다음 몇 장에 걸쳐 비동기 JavaScript 프로그래밍을 위한 다양한 새로운 기술을 탐색할 것입니다.

그러나 거기에 도달하기 전에 **비동기가 무엇이며 JS에서 어떻게 작동하는지** 훨씬 더 깊이 이해해야 합니다.

---

## A Program in Chunks

JS 프로그램을 하나의 .js 파일에 작성할 수 있지만 프로그램은 거의 확실히 여러 청크로 구성되며

그 중 하나만 지금 실행되고 나머지는 나중에 실행됩니다. 청크의 가장 일반적인 단위는 함수입니다.

JS를 처음 접하는 대부분의 개발자들이 안고 있는 문제는 지금 바로 발생하지 않는다는 것입니다.

다시 말해, 지금 완료할 수 없는 작업은 정의에 따라 비동기식으로 완료되므로 직관적으로 예상하거나 원하는 대로 차단 동작이 발생하지 않습니다.

```jsx
// ajax(..) is some arbitrary Ajax function given by a library
var data = ajax("http://some.url.1");
console.log(data);
// Oops! `data` generally won't have the Ajax results
```

표준 Ajax 요청이 동기식으로 완료되지 않는다는 것을 알고 있을 것입니다.

데이터 변수에 할당하기 위해 반환할 값이 아직 없습니다.

응답이 돌아올 때까지 ajax(..)가 차단될 수 있으면 data = .. 할당이 제대로 작동합니다.

그러나 우리는 Ajax를 그렇게 하지 않습니다. 우리는 지금 비동기식 Ajax 요청을 하고 있고 나중에야 결과를 얻을 수 있을 것입니다.

지금부터 나중까지 기다리게하는 가장 간단한(그러나 확실히 뿐만 아니라, 또는 필연적으로 가장 좋은!) 방법은 함수를 사용하는 것입니다.

일반적으로 **콜백 함수**라고 합니다.

```jsx
// ajax(..) is some arbitrary Ajax function given by a library
ajax("http://some.url.1", function myCallbackFunction(data) {
  console.log(data); // Yay, I gots me some `data`!
});
```

### 경고 : 동기 Ajax 요청을 만드는 것이 가능하다는 말을 들어보셨을 것입니다.

그것이 기술적으로 사실이지만 브라우저 UI(버튼, 메뉴, 스크롤 등)를 잠그고 사용자 상호 작용을 방지하기 때문에 어떤 상황에서도 절대 해서는 안됩니다.

이것은 끔찍한 생각이며 항상 피해야 합니다.

당신이 동의하지 않는다는 이유로 항의하기 전에, 콜백의 혼란을 피하려는 당신의 욕구는 동기 Ajax에 대한 정당화가 아닙니다.

예를 들어 다음 코드를 고려하십시오.

```jsx
function now() {
  return 21;
}

function later() {
  answer = answer * 2;
  console.log("Meaning of life:", answer);
}

var answer = now();

setTimeout(later, 1000); // Meaning of life: 42
```

프로그램에는 두 개의 청크가 있습니다.

지금 실행될 항목과 나중에 실행될 항목입니다.

이 두 청크가 무엇인지는 상당히 분명하지만 매우 더욱 명시적으로 합시다.

### Now :

```jsx
function now() {
    return 21;
}

function later() { .. }

var answer = now();

setTimeout( later, 1000 );
```

### Later :

```jsx
answer = answer * 2;

console.log("Meaning of life:", answer);
```

now 청크는 프로그램을 실행하자마자 바로 실행됩니다.

하지만

setTimeout이 나중에 발생하므로 later() 함수의 내용은 나중에(지금부터 1,000밀리초 후에) 실행됩니다.

setTimeout(..) 또한 이벤트를 설정합니다(

코드의 일부를 함수로 래핑하고 어떤 이벤트(타이머, 마우스 클릭, Ajax 응답 등)에 대한 응답으로 실행되어야 한다고 지정할 때마다 코드의 나중 청크를 생성하여 비동기를 도입합니다.

---

## Async console

console.\* 메서드의 작동 방식에 대한 사양이나 요구 사항 집합은 없습니다.

**공식적으로 JavaScript의 일부가 아니지만 대신 호스팅 환경에서 JS에 추가**됩니다.

따라서 다른 브라우저와 JS 환경은 원하는 대로 작동하므로 때때로 혼란스러운 동작이 발생할 수 있습니다.

특히, console.log(..)가 실제로 주어진 것을 즉시 출력하지 않는 일부 브라우저와 일부 조건이 있습니다.

이것이 발생할 수 있는 주된 이유는 I/O가 매우 느리고 많은 프로그램(JS뿐만 아니라)의 일부를 차단하기 때문입니다.

따라서 브라우저가 콘솔 I/O를 백그라운드에서 비동기식으로 처리하는 것이 (페이지/UI 관점에서) 더 나은 성능을 보일 수 있습니다.

매우 일반적이지는 않지만 이것이 관찰 가능한 시나리오(코드 자체가 아니라 외부에서):

```jsx
var a = { index: 1 };
// later
console.log(a); // ??
// even later
a.index++;
```

대부분의 경우 앞의 코드는 개발자 도구의 콘솔에서 예상한 대로 개체 표현을 생성할 것입니다.

그러나 이 동일한 코드가 브라우저가 콘솔 I/O를 백그라운드로 연기할 필요가 있다고 느끼는 상황에서 실행될 수도 있습니다.

이 경우 개체가 브라우저 콘솔에 표시될 때 a.index++ 이미 발생했으며 { index: 2 } 를 보여줍니다.

콘솔 I/O가 정확히 어떤 조건에서 지연되는지 또는 관찰 가능한지 여부는 움직이는 대상입니다.

console.log(..) 문 이후에 개체가 수정되었지만 예기치 않은 수정 사항이 표시되는 경우 디버깅에서 문제가 발생하는 경우

I/O에서 이러한 비동기 가능성이 있음을 알고 있어야 합니다.

참고: 이 드문 시나리오가 발생하는 경우 가장 좋은 옵션은 콘솔 출력에 의존하는 대신 JS 디버거에서 중단점을 사용하는 것입니다.

다음으로 가장 좋은 옵션은 문자열로 직렬화하여 해당 개체의 "스냅샷"을 강제 실행하는 것입니다.

JSON.stringify(..) 와 같이.

---

## Event Loop

당신이 비동기 JS 코드를 확실히 작성할 수 있음에도 불구하고(방금 살펴본 타임아웃과 같은), 최근(ES6)까지 JavaScript 자체는 실제로 비동기에 대한 직접적인 개념이 내장되어 있지 않았습니다.

미친 주장 같죠? 사실, 그것은 사실입니다.

JS 엔진 자체는 요청이 있을 때 주어진 순간에 프로그램의 단일 청크를 실행하는 것 이상을 수행한 적이 없습니다.

JS 엔진은 독립적으로 실행되지 않습니다. 대부분의 개발자에게 일반적인 웹 브라우저인 호스팅 환경에서 실행됩니다.

지난 몇 년 동안 JS는 브라우저를 넘어 Node.js와 같은 것을 통해 서버와 같은 다른 환경으로 확장되었습니다.

사실 JavaScript는 이러한 모든 종류의 장치에 내장되어 있습니다.

JS 엔진은 타고난 시간 감각이 없었지만 JS의 임의의 스니펫에 대한 주문형 실행 환경이었습니다.

"이벤트"(JS 코드 실행)를 예약한 주변 환경입니다.

예를 들어, JS 프로그램이 서버에서 일부 데이터를 가져오기 위해 Ajax 요청을 할 때 함수에 "응답" 코드를 설정하고(일반적으로 "콜백"이라고 함)

JS 엔진이 호스팅 환경에 알려줍니다. "이봐, 지금은 실행을 일시 중단할 것이지만 네트워크 요청이 완료되고 데이터가 있을 때마다 이 기능을 다시 호출해줘."

그런 다음 브라우저는 네트워크의 응답을 수신하도록 설정되고 사용자에게 제공할 항목이 있으면 이벤트 루프에 삽입하여 콜백 함수가 실행되도록 예약합니다.

그렇다면 **이벤트 루프**는 무엇입니까?

먼저 코드를 통해 개념화해 보겠습니다.

```jsx
// `eventLoop` is an array that acts as a queue (first-in, first-out)
var eventLoop = [];
var event;
// keep going "forever"
while (true) {
  // perform a "tick"
  if (eventLoop.length > 0) {
    // get the next event in the queue
    event = eventLoop.shift();
    // now, execute the next event
    try {
      event();
    } catch (err) {
      reportError(err);
    }
  }
}
```

물론 이것은 개념을 설명하기 위해 매우 단순화된 코드입니다.

그러나 더 나은 이해를 얻는 데 도움이 되기에 충분해야 합니다.

보시다시피, while 루프로 표현되는 연속적으로 실행되는 루프가 있으며 이 루프의 각 반복을 "틱"이라고 합니다.

각 틱에 대해 이벤트가 대기열에서 대기 중인 경우 해당 이벤트가 제거되어 실행됩니다.

이러한 이벤트는 함수 콜백입니다. setTimeout(..)이 이벤트 루프 대기열에 콜백을 넣지 않는다는 점에 유의하는 것이 중요합니다.

그것이 하는 일은 타이머를 설정하는 것입니다. 타이머가 만료되면 환경은 콜백을 이벤트 루프에 배치하여 미래의 틱이 콜백을 선택하고 실행할 수 있도록 합니다.

그 순간에 이벤트 루프에 이미 20개의 항목이 있다면 어떻게 될까요? 콜백이 기다립니다.

다른 사람들보다 뒤에 줄을 섭니다. 일반적으로 대기열을 선점하고 줄을 앞으로 건너뛰는 경로가 없습니다.

이것은 setTimeout(..) 타이머가 완벽한 시간적 정확도로 작동하지 않을 수 있는 이유를 설명합니다.

콜백은 지정한 시간 간격 이전에 실행되지 않을 것이지만(대략적으로 말하면) 이벤트 대기열의 상태에 따라 그 시간 또는 그 이후에 발생할 수 있습니다.

즉, 프로그램은 일반적으로 이벤트 루프 대기열에서 차례로 발생하는 많은 작은 덩어리로 나뉩니다.

기술적으로 프로그램과 직접 관련되지 않은 다른 이벤트도 대기열에 삽입될 수 있습니다.

---

## Parallel Threading

**"비동기"**와 *"병렬"*이라는 용어를 혼동하는 것은 매우 일반적이지만 실제로는 상당히 다릅니다.

비동기는 **지금과 나중 사이의 간격에 관한 것임을 기억하십시오.** 그러나 **병렬은 동시에 발생할 수 있는 일**에 관한 것입니다.

병렬 컴퓨팅을 위한 가장 일반적인 도구는 **Process와 thread**입니다. 프로세스와 스레드는 독립적으로 실행되고 동시에 실행될 수 있습니다.

별도의 프로세서 또는 별도의 컴퓨터에서 실행되지만 여러 스레드가 단일 프로세스의 메모리를 공유할 수 있습니다.

이와 대조적으로 **이벤트 루프는 작업을 작업으로 나누고 직렬로 실행하여 병렬 액세스 및 공유 메모리 변경을 허용하지 않습니다.**

병렬 및 "직렬"은 별도의 스레드에서 이벤트 루프를 협력하는 형태로 공존할 수 있습니다.

병렬 실행 스레드의 인터리빙과 비동기 이벤트의 인터리빙은 매우 다른 수준의 세분성에서 발생합니다.

```jsx
function later() {
  answer = answer * 2;
  console.log("Meaning of life:", answer);
}
```

`later()`의 전체 내용은 단일 이벤트 루프 대기열 항목으로 간주되지만 이 코드가 실행될 스레드에 대해 생각할 때

실제로는 12가지 다른 저수준 작업이 있을 수 있습니다. 예를 들어, answer = answer \* 2 는 먼저

현재 값 answer 를 로드한 다음 2 를 어딘가에 넣은 다음 곱셈을 수행한 다음 결과를 가져와서 answer 에 다시 저장해야 합니다.

단일 스레드 환경에서는 스레드를 인터럽트할 수 있는 항목이 없기 때문에 스레드 대기열의 항목이 저수준 작업이라는 것은 중요하지 않습니다.

그러나 두 개의 다른 스레드가 동일한 프로그램에서 작동하는 **병렬 시스템**이 있는 경우 예측할 수 없는 동작이 발생할 가능성이 매우 높습니다.

```jsx
var a = 20;

function foo() {
  a = a + 1;
}

function bar() {
  a = a * 2;
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

JavaScript의 단일 스레드 동작에서 foo() 가 bar() 전에 실행되면 결과는 a 가 42 이지만

bar() 가 foo() 전에 실행되면 a 의 결과는 41 이 됩니다.

그러나 동일한 데이터를 공유하는 JS 이벤트가 **병렬**로 실행된다면 문제는 훨씬 더 미묘할 것입니다.

`foo()` 및 `bar()` 의 코드를 각각 실행할 수 있는 스레드로 pseudocode 작업의 이 두 목록을 고려하고 정확히 동시에 실행되는 경우 어떤 일이 발생하는지 고려하십시오.

```jsx
스레드 1(X 및 Y는 임시 메모리 위치임):

 foo():
a. load value of `a` in `X`
b. store `1` in `Y`
c. add `X` and `Y`, store result in `X`
d. store value of `X` in `a`


스레드 2(X 및 Y는 임시 메모리 위치임):

bar():
a. load value of `a` in `X`
b. store `2` in `Y`
c. multiply `X` and `Y`, store result in `X`
d. store value of `X` in `a`

```

이제 두 스레드가 실제로 병렬로 실행되고 있다고 가정해 보겠습니다.

당신은 아마 문제를 발견할 수 있습니다, 그렇죠? 그들은 임시 단계를 위해 공유 메모리 위치 X와 Y를 사용합니다.

이러한 단계가 발생하면 최종 결과는 무엇입니까?

```jsx
1a (load value of `a` in `X` ==> `20`)
2a (load value of `a` in `X` ==> `20`)
1b (store `1` in `Y` ==> `1`)
2b (store `2` in `Y` ==> `2`)
1c (add `X` and `Y`, store result in `X`
1d (store value of `X` in `a` ==> `22`)
2c (multiply `X` and `Y`, store result in `X` ==> `44`)
2d (store value of `X` in `a` ==> `44`)
```

a 의 결과는 44 입니다. 하지만 이 주문은 어떻습니까?

```jsx
1a (load value of `a` in `X` ==> `20`)
2a (load value of `a` in `X` ==> `20`)
2b (store `2` in `Y`==>`2`)
1b (store `1` in `Y`==>`1`)
2c (multiply `X` and `Y`, store result in `X` ==> `20`)
1c (add `X` and `Y`,store result in `X` ==> `21`)
1d (store value of `X` in `a` ==> `21`)
2d (store value of `X` in `a` ==> `21`)
```

a의 결과는 21 입니다.

따라서 스레드 프로그래밍은 매우 까다롭습니다.

이러한 종류의 중단/인터리빙이 발생하는 것을 방지하기 위한 특별한 조치를 취하지 않으면 종종 두통을 유발하는

매우 놀랍고 비결정적인 동작을 얻을 수 있기 때문입니다.

JavaScript는 **스레드 간에 데이터를 공유하지 않습니다.** 즉, 비결정성 수준은 문제가 되지 않습니다.

그러나 이것이 JS가 항상 결정적이라는 것을 의미하지는 않습니다.

foo() 와 bar() 의 상대적인 순서가 두 가지 다른 결과( 41 또는 42 )를 생성하는 이전을 기억하십니까?

**참고: 아직 명확하지 않을 수 있지만 모든 비결정론이 나쁜 것은 아닙니다.** 때로는 관련이 없고 때로는 의도적입니다.

우리는 이번 장과 다음 몇 장에서 이에 대한 더 많은 예를 보게 될 것입니다.

---

## Run to Completion 완료까지

JavaScript의 단일 스레딩 때문에 **foo() (및 bar())** 내부의 코드는 원자적입니다.

즉, foo()가 실행되기 시작하면 bar()에 있는 코드가 실행되기 전에 전체 코드가 완료됩니다.

실행하거나 그 반대의 경우도 마찬가지입니다. 이것을 **"run to completion"** 동작이라고 합니다.

사실, **run-to-completion** 의미론은 다음과 같은 경우에 더 분명합니다.

foo() 및 bar()에는 다음과 같은 더 많은 코드가 있습니다.

```jsx
var a = 1;
var b = 2;

function foo() {
  a++;
  b = b * a;
  a = b + 3;
}

function bar() {
  b--;
  a = 8 + b;
  b = a * 2;
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

`foo()` 는 `bar()` 에 의해 중단될 수 없고 `bar()` 는 `foo()` 에 의해 중단될 수 없기 때문에

이 프로그램은 어떤 시작이 먼저 실행되느냐에 따라 두 가지 가능한 결과만 가질 수 있습니다.

개별 진술 `foo()` 및 `bar()`가 인터리브될 수 있으면 가능한 결과의 수가 크게 증가합니다!

청크 1은 동기식(지금 발생)이지만 청크 2와 3은 비동기식(나중에 발생)으로 실행됩니다.

시간의 간격으로 분리됩니다.

```jsx
Chunk 1:
var a = 1;
var b = 2;

Chunk 2 ( foo() ):
a++;
b = b * a;
a = b + 3;

Chunk 3 ( bar() ):
b--;
a = 8 + b;
b = a * 2;

```

청크 2와 3은 어느 쪽이든 첫 번째 순서로 발생할 수 있으므로 다음과 같이

이 프로그램에 대해 두 가지 가능한 결과가 있습니다.

```jsx
Outcome 1:
var a = 1;
var b = 2;

// foo()
a++;
b = b * a;
a = b + 3;

// bar()
b--;
a = 8 + b;
b = a * 2;
a; // 11
b; //22



Outcome 2:
var a = 1;
var b = 2;

// bar()
b--;
a = 8 + b;
b = a * 2;

// foo()
a++;
b = b * a;
a = b + 3;
a; // 183
b; // 180


```

동일한 코드의 두 가지 결과는 여전히 **비결정성**이 있음을 의미합니다!

그러나 그것은 쓰레드에서와 같이 명령문 순서 레벨(또는 실제로 표현식 연산 순서 레벨)이 아니라 함수(이벤트) 순서 레벨에 있습니다.

**즉, 스레드보다 더 결정적입니다.**

JavaScript의 동작에 적용하면 `foo()`와 `bar()`가 어느 것이 먼저 실행되는지 보기 위해 서로 경쟁하기 때문에

이 **함수 순서 비결정성**은 일반적인 **"경합 조건"**입니다. 특히, a and b가 어떻게 나올지 확실하게 예측할 수 없기 때문에 **"경합 조건"**입니다.

참고: JS에 실행 후 완료 동작이 없는 함수가 있었다면 더 많은 가능한 결과를 얻을 수 있었습니다.

그렇죠? ES6이 바로 그런 것을 도입한 것으로 밝혀졌습니다(4장 "제너레이터" 참조).

그러나 지금은 걱정하지 마십시오. 다시 다루겠습니다!

---

## Concurrency 동시성

사용자가 목록을 아래로 스크롤할 때 점진적으로 로드되는 상태 업데이트 목록(예: 소셜 네트워크 뉴스 피드)을 표시하는 사이트를 상상해 봅시다.

이러한 기능이 올바르게 작동하도록 하려면 (최소한) 두 개의 개별 "프로세스"가 동시에 실행되어야 합니다.

즉, 동일한 시간 창 동안이지만 반드시 같은 순간에 실행될 필요는 없음.

참고: 여기에서 **"프로세스"**를 따옴표로 묶은 이유는 컴퓨터 과학의 의미에서 진정한 운영 체제 수준 프로세스가 아니기 때문입니다.

논리적으로 연결된 순차적인 일련의 작업을 나타내는 가상 프로세스 또는 작업입니다.

용어상으로 우리가 탐색하는 개념의 정의와 일치하기 때문에 "작업"보다 "프로세스"를 선호합니다.

첫 번째 "프로세스"는 사용자가 페이지를 더 아래로 스크롤할 때 발생하는 onscroll 이벤트(새 콘텐츠에 대한 Ajax 요청 생성)에 응답합니다.

두 번째 "프로세스"는 Ajax 응답을 다시 수신합니다(페이지에 콘텐츠를 렌더링하기 위해).

분명히 사용자가 충분히 빠르게 스크롤하면 첫 번째 응답을 다시 가져와 처리하는 데 걸리는 시간 동안 두 개 이상의 onscroll 이벤트가 실행되는 것을 볼 수 있으므로 onscroll 이벤트와 Ajax 응답 이벤트가 빠르게 실행되고 인터리브 처리됩니다.

**동시성은 개별 구성 작업이 병렬로(별도의 프로세서 또는 코어에서 동일한 순간에) 발생하는지 여부에 관계없이 두 개 이상의 "프로세스"가 동일한 기간 동안 동시에 실행되는 경우입니다.**

동시성은 **작업 수준 병렬 처리**(별도 프로세서 스레드)와 반대되는 **"프로세스"** 수준(또는 작업 수준) 병렬 처리로 생각할 수 있습니다.

참고: 동시성은 서로 상호 작용하는 이러한 "프로세스"에 대한 선택적 개념도 도입합니다. 나중에 다시 다루겠습니다.

     주어진 시간 동안(사용자가 스크롤하는 몇 초 동안), 각각의 독립적인 "프로세스"를 시리즈로 시각화해 보겠습니다.

```jsx
"Process" 1 ( onscroll events) :

onscroll, request 1
onscroll, request 2
onscroll, request 3
onscroll, request 4
onscroll, request 5
onscroll, request 6
onscroll, request 7

"Process" 2 ( Ajax response events) :

response 1
response 2
response 3
response 4
response 5
response 6
response 7
```

onscroll 이벤트와 ajax 응답 이벤트가 정확히 같은 시점에 처리될 수 있을 가능성이 있습니다.

예를 들어 타임라인에서 이러한 이벤트를 시각화해 보겠습니다.

```jsx
onscroll, request 1
onscroll, request 2  response 1
onscroll, request 3  response 2
response 3
onscroll, request 4
onscroll, request 5
onscroll, request 6  response 4
onscroll, request 7
response 6
response 5
response 7
```

그러나 이 장에서 앞서 설명한 이벤트 루프의 개념으로 돌아가서 JS는 한 번에 하나의 이벤트만 처리할 수 있으므로

onscroll, request 2가 먼저 발생하거나 response 1이 발생합니다.

첫째, 그러나 문자 그대로 같은 순간에 일어날 수는 없습니다.

학교 식당의 아이들처럼, 그들이 문 밖에 어떤 군중을 형성하든, 그들은 점심을 먹기 위해 한 줄로 합류해야 할 것입니다!

이벤트 루프 대기열에 이러한 모든 이벤트의 인터리빙을 시각화해 보겠습니다.

```jsx
Event Loop Queue:

onscroll, request 1  <--- Process 1 starts
onscroll, request 2
response 1           <--- Process 2 starts
onscroll, request 3
response 2
response 3
onscroll, request 4
onscroll, request 5
onscroll, request 6
response 4
onscroll, request 7  <--- Process 1 finishes
response 6
response 5
response 7           <--- Process 2 finishes

```

"프로세스 1" 및 "프로세스 2"는 동시에 실행되지만(작업 수준 병렬),

개별 이벤트는 이벤트 루프 대기열에서 순차적으로 실행됩니다.

그건 그렇고, 응답 6과 응답 5가 어떻게 예상 순서에서 벗어났는지 알아차리셨습니까?

단일 스레드 이벤트 루프는 동시성의 한 표현입니다.

---

## Noninteracting

둘 이상의 "프로세스"가 동일한 프로그램 내에서 동시에 단계/이벤트를 인터리브하므로 작업이 관련되지 않은 경우 서로 상호 작용할 필요가 없습니다.

그들이 상호 작용하지 않는다면 비결정론은 완벽하게 받아들여질 수 있습니다.

```jsx
var res = {};

function foo(results) {
  res.foo = results;
}

function bar(results) {
  res.bar = results;
}
// ajax(..) is some arbitrary Ajax function given by a library
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

`foo()` 및 `bar()`는 두 개의 동시 "프로세스"이며 실행될 순서는 결정되지 않습니다.

그러나 실행 순서가 중요하지 않도록 프로그램을 구성했습니다. 상호 작용할 필요가 없습니다.

코드는 순서에 관계없이 항상 올바르게 작동하므로 이것은 **"경합 조건" 버그가 아닙니다.**

---

## Interaction

더 일반적으로 동시 "프로세스"는 범위 또는 DOM을 통해 간접적으로 필요에 따라 상호 작용합니다.

이러한 상호 작용이 발생하면 앞에서 설명한 것처럼 **"경합 조건"**을 방지하기 위해 이러한 상호 작용을 조정해야 합니다.

다음은 묵시적 ​​순서로 인해 상호 작용하는 두 개의 동시 "프로세스"에 대한 간단한 예입니다.

```jsx
var res = [];

function response(data) {
  res.push(data);
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax("http://some.url.1", response);
ajax("http://some.url.2", response);
```

동시 "프로세스"는 Ajax 응답을 처리하기 위해 만들어지는 두 개의 response() 호출입니다.

그것들은 어느 쪽이든 첫 번째 순서로 발생할 수 있습니다.

예상되는 동작이 res[0]에 "http://some.url.1" 호출 결과가 있고 res[1]에 "http://some.url.2" 호출 결과가 있다고 가정해 보겠습니다.

때로는 그럴 수도 있지만 어떤 호출이 먼저 끝나는지에 따라 뒤집힐 수도 있습니다. 이 비결정성은 **"경합 조건"** 버그일 가능성이 매우 높습니다.

참고: 이러한 상황에서 하는 경향이 있을 수 있는 가정에 매우 주의하십시오. 예를 들어,

개발자가 "http://some.url.2" 가 "http://some.url.1" 보다 "항상" 훨씬 느리게 응답하는 것을 관찰하는 것은 드문 일이 아닙니다.

아마도 어떤 작업 때문일 것입니다. 그들은 (예를 들어, 하나는 데이터베이스 작업을 수행하고 다른 하나는 정적 파일을 가져오는 것)

관찰된 순서는 항상 예상대로 보입니다. 두 요청이 동일한 서버로 이동하고 의도적으로 특정 순서로 응답하더라도

응답이 브라우저에 다시 도착하는 순서에 대한 실제 보장은 없습니다.

따라서 이러한 경쟁 조건을 해결하기 위해 주문 상호 작용을 조정할 수 있습니다.

```jsx
var res = [];

function response(data) {
  if (data.url == "http://some.url.1") {
    res[0] = data;
  } else if (data.url == "http://some.url.2") {
    res[1] = data;
  }
}
// ajax(..) is some arbitrary Ajax function given by a library
ajax("http://some.url.1", response);
ajax("http://some.url.2", response);
```

간단한 조정을 통해 "경합 조건" 비결정성을 제거했습니다.

일부 동시성 시나리오는 조정된 상호 작용 없이 항상 중단됩니다(때로는 아님).

```jsx
var a, b;

function foo(x) {
  a = x * 2;
  baz();
}

function bar(y) {
  b = y * 2;
  baz();
}

function baz() {
  console.log(a + b);
}
// ajax(..) is some arbitrary Ajax function given by a library
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

이 예에서 `foo()` 또는 `bar()`가 먼저 실행되는지 여부에 관계없이 항상 `baz()`가 너무 일찍(undefined) 실행되지만

`baz()`의 두 번째 호출은 `a`와 `b`를 모두 사용할 수 있으므로 작동합니다.

이러한 상태를 해결하는 다양한 방법이 있습니다. 다음은 한 가지 간단한 방법입니다.

```jsx
var a, b;

function foo(x) {
  a = x * 2;
  if (a && b) {
    baz();
  }
}

function bar(y) {
  b = y * 2;
  if (a && b) {
    baz();
  }
}

function baz() {
  console.log(a + b);
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

baz() 호출 주변의 if(a && b) 조건은 전통적으로 "게이트"라고 부릅니다.

왜냐하면 어떤 주문과 b가 도착할지 확신할 수 없기 때문입니다. 게이트를 엽니다( baz() 호출).

마주칠 수 있는 또 다른 동시성 상호 작용 조건을 "race"라고 하지만 더 정확하게는 "latch"라고 합니다.

"첫 번째 사람만 이긴다"는 행동이 특징입니다. 여기에서 비결정론은 허용됩니다.

결승선을 향한 "경주"가 단 한 명의 승자를 갖는 것이 괜찮다고 명시적으로 말하고 있다는 점입니다.

다음 코드를 고려하십시오.

```jsx
var a;

function foo(x) {
  a = x * 2;
  baz();
}

function bar(x) {
  a = x / 2;
  baz();
}

function baz() {
  console.log(a);
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

어떤 것( `foo()` 또는 `bar()` )이 마지막으로 실행되든 다른 것에서 할당된 값을 덮어쓸 뿐만 아니라

baz()에 대한 호출도 복제합니다(바람직하지 않을 수 있음).

따라서 간단한 래치로 상호 작용을 조정하여 첫 번째 래치만 통과시킬 수 있습니다.

```jsx
var a;

function foo(x) {
  if (!a) {
    a = x * 2;
    baz();
  }
}

function bar(x) {
  if (!a) {
    a = x / 2;
    baz();
  }
}

function baz() {
  console.log(a);
}
// ajax(..) is some arbitrary Ajax function given by a library
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

`if(!a)` 조건은 `foo()` 또는 `bar()` 중 첫 번째 호출만 허용하고 두 번째(및 실제로 후속) 호출은 무시됩니다.

참고: 이 모든 시나리오에서 우리는 단순한 설명을 위해 전역 변수를 사용했지만 여기에서는 전역 변수를 필요로 하는 추론에 대해 설명하지 않습니다.

해당 함수가 범위를 통해 변수에 액세스할 수 있는 한 의도한 대로 작동합니다.

어휘 범위 변수(이 책 시리즈의 Scope & Closures 제목 참조)와 실제로 이러한 예에서와 같이

전역 변수에 의존하는 것은 이러한 형태의 동시성 조정의 명백한 단점 중 하나입니다.

다음 몇 챕터를 진행하면서 우리는 그 점에서 훨씬 더 깔끔한 다른 조정 방법을 보게 될 것입니다.

---

## Cooperation 협력

동시성 조정의 또 다른 표현은 **"협동적 동시성"**이라고 합니다.

여기에서 초점은 범위 내에서 가치 공유를 통한 상호 작용에 그다지 중점을 두지 않습니다(물론 여전히 허용됩니다!).

목표는 장기 실행 "프로세스"를 단계 또는 일괄 처리로 분할하여 다른 동시 "프로세스"가 해당 작업을 이벤트 루프 대기열에 삽입할 기회를 갖도록 하는 것입니다.
예를 들어, 값을 변환하기 위해 긴 결과 목록을 실행해야 하는 Ajax 응답 핸들러를 생각해 보십시오. Array#map(..)을 사용하여 코드를 더 짧게 유지합니다.
