---
title: 1. Asynchrony Now & Later
tags: [event loop]
sidebar_position: 1
---

<br />

## 들어가며

JavaScript와 같은 언어로 프로그래밍할 때 가장 중요하지만 종종 오해를 받는 부분 중 하나는

일정 기간 동안 프로그램 동작을 표현하고 조작하는 방법입니다.

이것은 for 루프의 시작부터 for 루프가 끝날 때까지 일어나는 일에 관한 것이 아닙니다.

물론 완료하는 데 약간의 시간(마이크로초에서 밀리초)이 걸립니다.

**프로그램의 일부가 지금 실행되고 프로그램의 다른 부분이 나중에 실행될 때 어떤 일이 발생하는지에 대한 것입니다.**

지금과 나중 사이에는 프로그램이 활발하게 실행되지 않는 간격이 있습니다.

실질적으로 지금까지 작성된 모든 중요하지 않은 프로그램(특히 JS에서)은 사용자 입력을 기다리거나, 데이터베이스 또는 파일 시스템에서 데이터를 요청하고,

네트워크를 통해 데이터를 전송하고, 응답하거나 고정된 시간 간격(예: 애니메이션)으로 반복되는 작업을 수행합니다.

이 모든 다양한 방법으로 프로그램은 시간 간격을 가로질러 상태를 관리해야 합니다.

사실, 프로그램의 현재 부분과 이후 부분 간의 관계는 **비동기 프로그래밍의 핵심**입니다.

비동기 프로그래밍은 확실히 JS 초창기부터 있었습니다. 그러나 대부분의 JS 개발자는 프로그램에서 어떻게 그리고 왜 발생하는지 정확히 주의 깊게 고려하지 않았거나

이를 처리하는 다양한 다른 방법을 탐색했습니다.

충분히 좋은 접근 방식은 항상 겸손한 **콜백 함수**였습니다. 오늘날까지 많은 사람들이 콜백이 충분하다고 주장할 것입니다.

그러나 JS가 범위와 복잡성 면에서 계속 성장함에 따라 브라우저와 서버, 그리고 그 사이에 있는 생각할 수 있는 모든 장치에서 실행되는

일류 프로그래밍 언어에 대한 계속해서 확대되는 요구를 충족하기 위해 비동기식을 관리하는 어려움은 점점 더 심각해지고 있습니다.

그리고 그들은 더 유능하고 더 합리적인 접근 방식을 요구합니다.

지금 당장은 이 모든 것이 다소 추상적으로 보일 수 있지만 이 책을 진행하면서 더 완전하고 구체적으로 다룰 것입니다.

다음 몇 장에 걸쳐 비동기 JavaScript 프로그래밍을 위한 다양한 새로운 기술을 탐색할 것입니다.

그러나 거기에 도달하기 전에 **비동기가 무엇이며 JS에서 어떻게 작동하는지** 훨씬 더 깊이 이해해야 합니다.

---

## A Program in Chunks

JS 프로그램을 하나의 .js 파일에 작성할 수 있지만 프로그램은 거의 확실히 여러 청크로 구성되며

그 중 하나만 지금 실행되고 나머지는 나중에 실행됩니다. 청크의 가장 일반적인 단위는 함수입니다.

JS를 처음 접하는 대부분의 개발자들이 안고 있는 문제는 지금 바로 발생하지 않는다는 것입니다.

다시 말해, 지금 완료할 수 없는 작업은 정의에 따라 비동기식으로 완료되므로 직관적으로 예상하거나 원하는 대로 차단 동작이 발생하지 않습니다.

```jsx
// ajax(..) is some arbitrary Ajax function given by a library
var data = ajax("http://some.url.1");
console.log(data);
// Oops! `data` generally won't have the Ajax results
```

표준 Ajax 요청이 동기식으로 완료되지 않는다는 것을 알고 있을 것입니다.

데이터 변수에 할당하기 위해 반환할 값이 아직 없습니다.

응답이 돌아올 때까지 ajax(..)가 차단될 수 있으면 data = .. 할당이 제대로 작동합니다.

그러나 우리는 Ajax를 그렇게 하지 않습니다. 우리는 지금 비동기식 Ajax 요청을 하고 있고 나중에야 결과를 얻을 수 있을 것입니다.

지금부터 나중까지 기다리게하는 가장 간단한(그러나 확실히 뿐만 아니라, 또는 필연적으로 가장 좋은!) 방법은 함수를 사용하는 것입니다.

일반적으로 **콜백 함수**라고 합니다.

```jsx
// ajax(..) is some arbitrary Ajax function given by a library
ajax("http://some.url.1", function myCallbackFunction(data) {
  console.log(data); // Yay, I gots me some `data`!
});
```

### 경고 : 동기 Ajax 요청을 만드는 것이 가능하다는 말을 들어보셨을 것입니다.

그것이 기술적으로 사실이지만 브라우저 UI(버튼, 메뉴, 스크롤 등)를 잠그고 사용자 상호 작용을 방지하기 때문에 어떤 상황에서도 절대 해서는 안됩니다.

이것은 끔찍한 생각이며 항상 피해야 합니다.

당신이 동의하지 않는다는 이유로 항의하기 전에, 콜백의 혼란을 피하려는 당신의 욕구는 동기 Ajax에 대한 정당화가 아닙니다.

예를 들어 다음 코드를 고려하십시오.

```jsx
function now() {
  return 21;
}

function later() {
  answer = answer * 2;
  console.log("Meaning of life:", answer);
}

var answer = now();

setTimeout(later, 1000); // Meaning of life: 42
```

프로그램에는 두 개의 청크가 있습니다.

지금 실행될 항목과 나중에 실행될 항목입니다.

이 두 청크가 무엇인지는 상당히 분명하지만 매우 더욱 명시적으로 합시다.

### Now :

```jsx
function now() {
    return 21;
}

function later() { .. }

var answer = now();

setTimeout( later, 1000 );
```

### Later :

```jsx
answer = answer * 2;

console.log("Meaning of life:", answer);
```

now 청크는 프로그램을 실행하자마자 바로 실행됩니다.

하지만

setTimeout이 나중에 발생하므로 later() 함수의 내용은 나중에(지금부터 1,000밀리초 후에) 실행됩니다.

setTimeout(..) 또한 이벤트를 설정합니다(

코드의 일부를 함수로 래핑하고 어떤 이벤트(타이머, 마우스 클릭, Ajax 응답 등)에 대한 응답으로 실행되어야 한다고 지정할 때마다 코드의 나중 청크를 생성하여 비동기를 도입합니다.

---

## Async console

console.\* 메서드의 작동 방식에 대한 사양이나 요구 사항 집합은 없습니다.

**공식적으로 JavaScript의 일부가 아니지만 대신 호스팅 환경에서 JS에 추가**됩니다.

따라서 다른 브라우저와 JS 환경은 원하는 대로 작동하므로 때때로 혼란스러운 동작이 발생할 수 있습니다.

특히, console.log(..)가 실제로 주어진 것을 즉시 출력하지 않는 일부 브라우저와 일부 조건이 있습니다.

이것이 발생할 수 있는 주된 이유는 I/O가 매우 느리고 많은 프로그램(JS뿐만 아니라)의 일부를 차단하기 때문입니다.

따라서 브라우저가 콘솔 I/O를 백그라운드에서 비동기식으로 처리하는 것이 (페이지/UI 관점에서) 더 나은 성능을 보일 수 있습니다.

매우 일반적이지는 않지만 이것이 관찰 가능한 시나리오(코드 자체가 아니라 외부에서):

```jsx
var a = { index: 1 };
// later
console.log(a); // ??
// even later
a.index++;
```

대부분의 경우 앞의 코드는 개발자 도구의 콘솔에서 예상한 대로 개체 표현을 생성할 것입니다.

그러나 이 동일한 코드가 브라우저가 콘솔 I/O를 백그라운드로 연기할 필요가 있다고 느끼는 상황에서 실행될 수도 있습니다.

이 경우 개체가 브라우저 콘솔에 표시될 때 a.index++ 이미 발생했으며 { index: 2 } 를 보여줍니다.

콘솔 I/O가 정확히 어떤 조건에서 지연되는지 또는 관찰 가능한지 여부는 움직이는 대상입니다.

console.log(..) 문 이후에 개체가 수정되었지만 예기치 않은 수정 사항이 표시되는 경우 디버깅에서 문제가 발생하는 경우

I/O에서 이러한 비동기 가능성이 있음을 알고 있어야 합니다.

참고: 이 드문 시나리오가 발생하는 경우 가장 좋은 옵션은 콘솔 출력에 의존하는 대신 JS 디버거에서 중단점을 사용하는 것입니다.

다음으로 가장 좋은 옵션은 문자열로 직렬화하여 해당 개체의 "스냅샷"을 강제 실행하는 것입니다.

JSON.stringify(..) 와 같이.

---

## Event Loop

당신이 비동기 JS 코드를 확실히 작성할 수 있음에도 불구하고(방금 살펴본 타임아웃과 같은), 최근(ES6)까지 JavaScript 자체는 실제로 비동기에 대한 직접적인 개념이 내장되어 있지 않았습니다.

미친 주장 같죠? 사실, 그것은 사실입니다.

JS 엔진 자체는 요청이 있을 때 주어진 순간에 프로그램의 단일 청크를 실행하는 것 이상을 수행한 적이 없습니다.

JS 엔진은 독립적으로 실행되지 않습니다. 대부분의 개발자에게 일반적인 웹 브라우저인 호스팅 환경에서 실행됩니다.

지난 몇 년 동안 JS는 브라우저를 넘어 Node.js와 같은 것을 통해 서버와 같은 다른 환경으로 확장되었습니다.

사실 JavaScript는 이러한 모든 종류의 장치에 내장되어 있습니다.

JS 엔진은 타고난 시간 감각이 없었지만 JS의 임의의 스니펫에 대한 주문형 실행 환경이었습니다.

"이벤트"(JS 코드 실행)를 예약한 주변 환경입니다.

예를 들어, JS 프로그램이 서버에서 일부 데이터를 가져오기 위해 Ajax 요청을 할 때 함수에 "응답" 코드를 설정하고(일반적으로 "콜백"이라고 함)

JS 엔진이 호스팅 환경에 알려줍니다. "이봐, 지금은 실행을 일시 중단할 것이지만 네트워크 요청이 완료되고 데이터가 있을 때마다 이 기능을 다시 호출해줘."

그런 다음 브라우저는 네트워크의 응답을 수신하도록 설정되고 사용자에게 제공할 항목이 있으면 이벤트 루프에 삽입하여 콜백 함수가 실행되도록 예약합니다.

그렇다면 **이벤트 루프**는 무엇입니까?

먼저 코드를 통해 개념화해 보겠습니다.

```jsx
// `eventLoop` is an array that acts as a queue (first-in, first-out)
var eventLoop = [];
var event;
// keep going "forever"
while (true) {
  // perform a "tick"
  if (eventLoop.length > 0) {
    // get the next event in the queue
    event = eventLoop.shift();
    // now, execute the next event
    try {
      event();
    } catch (err) {
      reportError(err);
    }
  }
}
```

물론 이것은 개념을 설명하기 위해 매우 단순화된 코드입니다.

그러나 더 나은 이해를 얻는 데 도움이 되기에 충분해야 합니다.

보시다시피, while 루프로 표현되는 연속적으로 실행되는 루프가 있으며 이 루프의 각 반복을 "틱"이라고 합니다.

각 틱에 대해 이벤트가 대기열에서 대기 중인 경우 해당 이벤트가 제거되어 실행됩니다.

이러한 이벤트는 함수 콜백입니다. setTimeout(..)이 이벤트 루프 대기열에 콜백을 넣지 않는다는 점에 유의하는 것이 중요합니다.

그것이 하는 일은 타이머를 설정하는 것입니다. 타이머가 만료되면 환경은 콜백을 이벤트 루프에 배치하여 미래의 틱이 콜백을 선택하고 실행할 수 있도록 합니다.

그 순간에 이벤트 루프에 이미 20개의 항목이 있다면 어떻게 될까요? 콜백이 기다립니다.

다른 사람들보다 뒤에 줄을 섭니다. 일반적으로 대기열을 선점하고 줄을 앞으로 건너뛰는 경로가 없습니다.

이것은 setTimeout(..) 타이머가 완벽한 시간적 정확도로 작동하지 않을 수 있는 이유를 설명합니다.

콜백은 지정한 시간 간격 이전에 실행되지 않을 것이지만(대략적으로 말하면) 이벤트 대기열의 상태에 따라 그 시간 또는 그 이후에 발생할 수 있습니다.

즉, 프로그램은 일반적으로 이벤트 루프 대기열에서 차례로 발생하는 많은 작은 덩어리로 나뉩니다.

기술적으로 프로그램과 직접 관련되지 않은 다른 이벤트도 대기열에 삽입될 수 있습니다.

---

## Parallel Threading

**"비동기"**와 *"병렬"*이라는 용어를 혼동하는 것은 매우 일반적이지만 실제로는 상당히 다릅니다.

비동기는 **지금과 나중 사이의 간격에 관한 것임을 기억하십시오.** 그러나 **병렬은 동시에 발생할 수 있는 일**에 관한 것입니다.

병렬 컴퓨팅을 위한 가장 일반적인 도구는 **프로세스와 스레드**입니다. 프로세스와 스레드는 독립적으로 실행되고 동시에 실행될 수 있습니다.

별도의 프로세서 또는 별도의 컴퓨터에서 실행되지만 여러 스레드가 단일 프로세스의 메모리를 공유할 수 있습니다.

이와 대조적으로 **이벤트 루프는 작업을 작업으로 나누고 직렬로 실행하여 병렬 액세스 및 공유 메모리 변경을 허용하지 않습니다.**

병렬 및 "직렬"은 별도의 스레드에서 이벤트 루프를 협력하는 형태로 공존할 수 있습니다.

병렬 실행 스레드의 인터리빙과 비동기 이벤트의 인터리빙은 매우 다른 수준의 세분성에서 발생합니다.
