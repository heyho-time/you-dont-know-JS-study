---
slug: /chapter_1
title: Into Programming
tags: [javascript]
sidebar_position: 1
---

---

## Code

프로그램은 컴퓨터가 어떤 일을 수행할지 명시해놓은 명령어의 집합이다.<br/>
유효한 형식으로된 명령어의 집합을 **컴퓨터 언어**라고 부른다.

---

## Statements

프로그래밍에서 statement는 실행 가능한(executable) 최소의 독립적인 코드 조각이다. <br/>
프로그램은 이러한 statement 모음이고, statement가 함께 작동하여 프로그램을 의도대로 작동시킨다.

```js
a = b * 2;
```

- a, b: 어떠한 값을 넣고 저장할 수 있는 변수
- 2: 변수에 저장되지 않은 value(값)
- =, \*: 변수와 값들이 연산되어 동작할 수 있도록하는 연산자

---

## Expressions

Expression은 '수식'이라는 뜻으로, 하나 이상의 값으로 표현될 수 있는 코드를 말한다.
Statement는 하나 이상의 expression으로 구성되어 있다.<br/>
위 식에서 expression은 다음과 같다.

- 2는 리터럴 값 expression
- b는 변수 expression
- b \* 2는 산술 expression
- a = b \* 2는 할당 expression

자주 사용하는 expression 중 하나인 호출식은, statement 자체가 함수를 호출하는 수식이다. <br/>
(ex) `alert(a);`

---

## Statement vs Expression

<img
  style={{ width: "40%", padding: "1rem" }}
  src="https://shoark7.github.io/assets/img/knowledge/expression_statement.png"
/>

Expression은 값으로 평가된다. 즉, 특정한 결과값으로 **계산**이 가능하다.
Statements는 실행 가능한 코드이다.

`100 * 4`라는 코드는 400이라는 값이 나오도록 계산이 가능하므로 expression이면서, 실행 가능한 코드이므로 statement도 된다.
하지만 `return 1`과 같은 코드는 실행 가능한 statement는 맞으나, 계산을 통해 어떠한 값이 나오는 것은 아니라서 expression은 아니다.

따라서 expression은 statement의 부분집합이고, statement가 더 큰 범위를 갖는다고 이해하면 된다.

---

## Executing a Program

자바스크립트로 작성한 코드를 컴퓨터가 바로 이해할 수 없으므로, 인터프리터나 컴파일러를 통해 기계어로 컴파일된다.<br/>
이러한 번역 과정은 언어마다 다르다.

### 인터프리터

각 행마다 번역을 실행하므로 실행 시간이 상대적으로 느리나, 그만큼 번역 속도는 빠르다.

### 컴파일러

소스 코드 전체를 한번에 기계어로 변환하므로 컴파일 시간은 오래 걸리지만, 실행은 빠르다.

컴파일러 언어의 경우, 실행 파일을 생성하는 하드웨어의 환경(OS)에 종속되어 컴파일된다.
따라서 해당 실행 파일을 다른 하드웨어에서 실행하려고 하면 작동하지 않는다.
하지만 인터프리터는 OS나 플랫폼에 종속되지 않기 때문에, 어떤 환경에서도 잘 작동한다.

---

## Output

`console.log()`, `alert()` ...

## Input

```js
age = prompt("Please tell me your age");
```

---

## Operators

`=` 연산자는 할당에 사용된다. `=`를 기준으로 오른쪽에 있는 값을 먼저 계산하고, 왼쪽에 있는 선언된 변수에 할당한다.<br/>
객체에서 프로퍼티를 호출할 때 사용하는 `.`도 property access 연산자이다.

## Values & Types

자바스크립트는 각 원시값들에 대해 `number`,`string`, `boolean`과 같은 내장된 타입을 가지고 있다.

## Converting Between Types

자바스크립트는 타입을 강제로 변환할 수 있다.
string으로 입력한 값이라도, `Number()`를 통해 number로 변환시킬 수 있다.

만약, 타입이 다른 두 값을 비교하려고 하면 암시적인 변환이 일어난다.<br/>
"99.99" === 99.99의 경우, 타입이 다름에도 불구하고 자바스크립트는
왼쪽의 값을 오른쪽 값에 맞추어 타입을 암시적으로 바꾸고, 해당식의 값은 true가 나오게 된다.

---

## Code Comments

주석은 해당 코드에 대한 부연 설명이며, 인터프리터나 컴파일러가 무시하고 넘어간다.

- 주석을 적지 않은 코드는 최적화되지 않은 것이다.
- 너무 많은 주석은 그만큼 코드가 좋지 않다는 것이다.
- 주석은 '무엇인가'에 대한 내용이 아닌 '왜인가'에 대한 설명이어야 한다.

자바스크립트에서 주석을 표시하는 방법은 두가지이다.<br/>
`//` 방식은 한 줄에, `/**/` 방식은 여러줄에 사용하면 좋다.

---

## Variables

변수를 선언하는 이유는 해당 값을 범위 내에서 여러번 사용할 수 있기 때문이다.

Weak typing, 즉 dynamic typing은 변수에 어떠한 타입의 값이 들어와도 유연하게 수용한다.
하지만 몇몇 언어는 변수가 특정한 타입을 가지고 있도록 명시한다.
그 이유는 타입을 강제함으로써 의도치 않은 값의 변경을 방지하여 정확한 코드를 작성할 수 있기 때문이다.

자바스크립트는 dynamic typing 방식을 이용하여, 변수에 모든 타입의 값이 할당될 수 있다.

또한, 하나의 값만 관라하는 상수를 만들기 위해서도 쓰인다. 상수는 선언할 때 값을 할당하면, 그 이후로는 값을 변경할 수 없다.
따라서 바뀌지 않는 값이나, 실수로 바뀌어서는 안되는 값을 관리할 때 유용하게 사용된다.

---

## Blocks

Statement들을 하나의 그룹으로 묶을 때 `{...}`을 사용한다.
JS에서는 전형적으로 if문이나 loop문에 자주 사용된다.

```js
if (amount > 10) {
  amount = amount * 2;
  console.log(amount);
}
```

---

## Conditionals

Statement에 조건을 걸어 `true`일 때와 `false`일 때의 상황을 구분하고 이에 따른 분기처리를 진행할 수 있다.

if문은 boolean 값을 반환하는 조건문을 필요로 한다.
하지만 boolean이 아닌 다른 타입의 값이 넘어왔을 때는, 강제 타입 변환이 일어난다.

자바스크립트가 정의하는 `falsy` 값(ex: `0`)은 타입 변환이 일어났을 때 `false`가 된다.
반대로 `truthy` 값은 타입 변환시 `true`가 된다.

|          |                                                 |
| -------- | ----------------------------------------------- |
| falsy 값 | `false`, `null`, `undefined`, `0`, `NaN`, `''`) |

## ,

## Loops

조건이 false일 때까지 특정한 액션을 반복할 때, 즉 조건이 성립하는 동안 같은 작업을 반복할 때 반복문을 사용한다.
반복문 블록이 실행될 때마다 이를 iteration 이라고 한다.

```js
while (numOfCustomers > 0) {
  console.log("How may I help you?");
  numOfCustomers -= 1;
}
```

while문은 첫번째 반복문을 실행하기 전에 조건문을 실행하는 반면, do~while문은 첫번째 iteration이 실행되고 난 후에 조건문을 실행한다.
따라서 while문은 조건이 맞지 않으면 단 한 번도 실행되지 않을수 있고, do~while문은 조건에 상관없이 무조건 최초 한 번은 실행한다.

반복을 멈출때는 `break`를 사용한다.

---

## Functions

같은 로직을 실행하는 코드를 여러번 작성하면 비효율적일 것이다.
이러한 경우, 해당 로직을 실행하는 **함수**를 만들어 정의하고 해당 함수를 가져다 쓰면 된다.

함수는 본인의 이름을 통해 호출되며, 호출되면 내부에 있는 코드를 실행한다.
원하는 인자값(parameter)를 받아오고, 로직을 실행한 뒤 값을 return 한다.

꼭 여러번 쓰여야만 함수를 정의하는 것은 아니다.
한 번만 호출될지라도, 연관된 기능을 하는 코드들끼리 묶어서 정의하고 싶을 때 함수를 사용하기도 한다.

---

## Scope

Scope는 변수들을 어디까지 사용가능한지 그 **유효범위**를 지정하는 역할을 한다.
함수 내부에서 선언된 변수는 그 함수 내부에서만 사용 가능하다.
동일한 scope 내에서는 중복된 변수명을 사용할 수 없다. 반대로 서로 다른 스코프에서는 동일한 변수명으로 선언 가능하다.

중첩이 가능하다. 따라서 가장 내부에 있는 스코프는 자신을 감싸고 있는 부모 스코프에 있는 변수를 사용할 수 있다.

```js
function outer() {
  const a = 1;

  function inner() {
    const b = 2;

    // we can access both 'a' and 'b' here
    console.log(a + b);
  }
  inner();

  // we can only access 'a' here
  console.log(a);
}
```

전역 변수는 스코프 상관없이 모든 곳에서 사용할 수 있다.
