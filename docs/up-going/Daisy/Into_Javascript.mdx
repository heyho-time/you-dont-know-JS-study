---
slug: /up-going/daisy/into_js
title: Into JavaScript
tags: [javascript]
sidebar_position: 2
---

---

## Values & Types

자바스크립트 내장 타입은 다음과 같다.

- string, number, boolean, null & undefined, object, symbol(ES6)

`typeof` 키워드를 이용하여 해당 변수의 타입을 알 수 있으며, 위 내장 타입 6가지 중 하나를 `string` 형태로 반환한다.

```js
a = { b: "c" };
typeof a;
```

위 식에서 typeof는 a 변수 자체에 대한 타입이 아닌, a 변수가 가지고 있는 값에 대한 타입을 나타내는 것이다.
자바스크립트는 value만 type이 있으며, 변수는 value를 담는 역할을 할 뿐이다.
typeof null은 null이라는 값을 리턴하지 않고, object라는 값을 리턴한다.

또한 undefined를 할당한 변수는 그 변수에 아무 값도 할당 하지 않은 것과 같다.

---

## Objects

객체의 프로퍼티는 `.`과 `[]` 두 가지 방법으로 접근할 수 있다. `.`이 더 간략하고 가독성이 좋아 많이 사용하는 편이다.
`[]`는 프로퍼티의 이름에 특수문자가 들어가 있거나 띄워쓰기가 되어있는 경우, 또는 key값이 변수인 경우에 사용한다.

```js
var obj = {
  a: "hello world",
  b: 42,
};

var b = "a";

obj[b]; // "hello world"
obj["b"]; // 42
```

6가지 내장 타입 이외에도 array와 function이라는 두 타입이 더 있다. 하지만 이 타입들은 내장 타입이라기 보다는, `object` 타입에서 더 구체적으로 들어간 서브타입이라고 할 수 있다.

### Arrays

배열은 값을 자신의 프로퍼티 또는 키에 저장하는 것은 아니지만, index 위치에 저장하는 object이다.
배열 인덱스는 0부터 시작하며, 각 인덱스의 value는 다른 타입의 값을 가질 수 있다.

```js
var arr = ["hello world", 42, true];
```

가장 자연스러운 사용법은 순차적인 위치에 값을 할당할 때는 배열을, 이름을 가지고 있는 프로퍼티에 값을 할당할 때는 객체를 사용하는 것이다.

### Functions

함수는 object의 서브타입이며, `typeof`가 "function"을 리턴한다.
속성을 가질 수 있으나 함수 프로퍼티는 제한된 경우에만 사용한다.

```js
function foo() {
  return 42;
}

foo.bar = "Hello, World";
```

---

## Built-In Type Methods

내장 타입과 서브 타입은 다양한 속성 메서드들이 존재하여 이를 유용하게 활용할 수 있다.
Object의 메서드를 호출하는 방법은 value의 메서드를 호출하는 방법보다 복잡하다.

네이티브라고 불리는 `String()`은 객체 래퍼 형태로 원시 문자열 타입과 한 쌍이다.
이 객체 래퍼로 프로토타입에서 toUpperCase()를 정의한다.

속성 또는 메서드를 참조하여 "hello world"와 같은 원시 값을 객체로 사용하는 경우,
자바스크립트는 자동으로 해당 값을 관련된 객체 래퍼 박스에 넣는다.

즉 string 값은 String 객체로, number 값은 Number 객체로 감싸질 수 있다.

---

## Comparing Values

자바스크립트에서 두 값을 비교할 때의 결과값으로 일치함 / 불일치함 두 가지가 있다.
이 비교 결과는 값의 유형과 상관없이 무조건 true / false로 나뉜다.

### Coercion

Coercion은 명시적과 암시적 두 가지 형태로 나뉜다.
명시적 강제는 하나의 타입을 다른 타입으로 강제로 변환시키는 코드를 넣는 것이고,
암시적 강제는 다른 연산을 진행하다가 그로 의한 부작용으로 타입 변환이 일어나는 것이다.

강제 타입 변환이 좋지 않다는 이야기도 있지만 타입을 강제로 변환시켜준 부분들은 대부분 합리적인 고민을 거쳐
작성된 경우가 많으며, 오히려 가독성을 높힐 때도 있으므로 무조건 나쁜 것은 아니다.

```js
// 명시적 타입 변환
var a = "42"; // "42"
var b = Number(a); // 42
```

```js
// 암시적 타입 변환
var a = "42"; // "42"
var b = a * 1; // 42
```

### Truthy & Falsy

Non-boolean 값을 boolean 타입으로 강제 변환했을 때 false를 반환하는 값을 "falsy", true를 반환하는 값을 "truthy"라고 한다.

- falsy: `""`, `0`, `-0`, `NaN`, `null`, `undefined`, `false`
- truthy: `"hello"`, `42`, `true`, `[]`, `[1, "2", 3]`, `{}`, `{a: 42}`, `function foo(){...}`

### Equality

비교 연산자는 `==`, `===`, `!=`, `!==` 네 종류가 있다.
`==` 연산자는 값이 일치하는지를 비교하고, `===` 연산자는 값과 타입 둘 다 일치하는지를 비교하지만, 이도 완전 정확한 설명은 아니다.
더 확실하게는 `==`는 값의 강제 변환을 허용하면서 비교하고, `===`는 값의 강제 변환을 허용하지 않으면서 비교한다는 것이다.
따라서 `===`는 엄격한(strict) 체크라고 불린다.

```js
var a = "42";
var b = 42;

a == b; // 느슨한 체크, true
a === b; // 엄격한 체크, false
```

위의 코드로 예시를 들어보자.
느스한 체크의 경우, 자바스크립트는 a와 b의 타입이 맞지 않음을 인지하여 두 변수의 타입이 일치할 때까지 암시적 변환의 과정을 거친다.
그럼 `42 == 42`를 비교하는 것일까 아니면 `"42" == "42"`를 비교하는 것일까?
답은 `42 == 42`, 즉 "42"를 42로 변환하여 비교하는 것이다.
하지만 과정이 어찌 되었든, 결국 true를 반환하므로 **느슨한 체크는 암시적 타입 변환을 통해 타입을 맞춘다는 사실**을 기억하자.
엄격한 체크는 강제 타입 변환을 허용하지 않으므로 false를 반환한다.

- 두 값 중 하나가 true 또는 false 값이 되는 경우라면 `===` 사용
- 두 값 중 하나가 0, "", [] 중 하나라면 `===` 사용
- 그 외 다른 모든 경우에는 `==`를 사용해도 무방

함수나 객체를 `==`나 `===`로 비교하게 되면 해당 객체가 가지고 있는 값을 비교하는 것이 아니라, 참조하고 있는
주소값이 일치하는가를 기준으로 비교하므로 주의해야 한다.

```js
var a = [1, 2, 3];
var b = [1, 2, 3];
var c = "1, 2, 3";

a == c; // true
b == c; // true
a == b; // false, 참조하는 주소가 다름
```

### Inequality

<, >, <=, >= 연산자는 관계를 비교하는 부등식이다.
부등식은 숫자값들을 비교할 수 있지만, 문자열 값은 비교할 수 없다.

```js
var a = 41;
var b = "42";
var c = "43";

a < b; // true
b < c; // true
```

하지만 위 예제를 보면 알 수 있듯이 비교하는 두 값이 모두 문자열인 경우 사전순으로 비교가 이루어지며,
둘 중 하나가 문자열인 경우에는 문자열인 값을 숫자로 강제 변환하여 비교한다.
하지만, 문자열인 값을 숫자로 강제 변환할 수 없는 경우 (ex. "foo")에는 항상 false를 반환한다.

---

## Variables

변수 및 함수명은 항상 **유효한 식별자**여야한다.
`a-z, A-Z, $, or _`로 시작해야하며, `0-9` 중 아무 숫자를 포함할 수 있다.
속성명도 변수명과 똑같은 규칙을 따르는데, 예약어 같은 경우에는 변수명에는 사용할 수 없지만 속성명에는 사용 가능한 경우가 있다.

- 예약어: null, true, false, for, in, if 등 자바스크립트에서 이미 사용하고 있는 단어

---

## Function Scopes

### Hoisting

호이스팅이란 var로 선언한 변수가 본인이 속한 스코프 범위 내에서 맨 위로 이동되는 것을 뜻한다.

```js
var a = 2;

foo(); // hoisted

function foo() {
  a = 3; // hoisted
  console.log(a);
  var a;
}

console.log(a);
```

하지만 호이스팅에 의존하여 변수를 선언하기 전에 사용하는 것은 좋지 않은 방법이므로,
**선언 먼저 하고 그 뒤에 사용하자**.

### Nested Scopes

변수를 선언하면 해당 스코프 + 해당 스코프의 하위 스코프에서 사용할 수 있다.
따라서 자신이 선언된 스코프보다 더 상위의 스코프에서 변수를 호출하면 `ReferenceError`를 띄운다.
그리고 선언되지 않은 변수에 값을 할당하려고 하면, strict mode 여부에 따라서 최상위 스코프인 global scope에 변수를 생성하거나 에러가 발생한다.

ES6부터는 `let`을 사용할 수 있는데, `let`은 `{...}`, 즉 하나의 개별적인 블록과 같다.
let은 본인이 선언된 스코프에만 속하기 때문에, var를 사용함으로써 발생했던 hoisting 문제가 없어 코드의 유지보수와 범위 관리에 유용하다.

---

## Conditionals

if문 외에, `if...else`, `switch-case`문 등의 조건문이 존재한다.

switch-case 문은 특정 case 또는 case 묶음을 거치면 그 외 case들은 무시하고 해당 switch문을 빠져나간다.
하지만 `fall through`라는 예약어를 사용하면 하나의 case를 거치고, 그 다음 case를 이어서 실행시키는 것이 가능하다.

if문을 나타낼 수 있는 또 다른 형식에는 삼항연산자가 있다. `const b = (a > 41) ? true : false`

---

## Strict mode

ES5부터는 언어의 규칙을 좀 더 강화하기 위해 strict mode를 추가하였으며, 이로 인해 코드를 더 안전하고 적절한 방법으로 유지할 수 있다.

Strict mode를 어디에 선언했느냐에 따라 개별 함수, 파일 전체 등 위치에 따라 적용할 수 있다.

```js
function foo() {
  "use strict"

  function bar() {...}
}
```

가장 중요한 점은 엄격 모드에서 선언문 전에 사용된 변수에 대한 암묵적인 자동 전역 변수 선언이 허용되지 않는다는 것이다.

---

## Functions as Values

함수는 외부 주소값으로부터 참조된 범위에 있는 변수일 뿐이다.

```js
var foo = function () {};

var x = function bar() {};
```

첫번째 함수는 이름이 없는 익명함수이며, 두번째 함수는 x라는 변수에 bar라는 이름을 가진 함수가 할당된 형태이다.

### 즉시 호출 함수식(IIFE)

위의 식에서 함수는 호출되지 않았음으로 실행되지 않는다. `foo()`나 `x()` 구문을 호출해야만 실행 가능하다.
그런데 즉시 함수를 호출할 수 있는 IIFE 표현식이 있다.

```js
(function IIFE() {
  console.log("Hello");
})();
// Hello
```

식 마지막 끝에 있는 `()`는 함수를 실제로 작동시키는 부분이다.
해당 함수를 사용하면 변수의 범위를 생성하므로, 외부 스코프에 영향을 미치지 않도록 변수를 선언하고 사용하는데에 도움이된다.

### Closure

클로저는 함수의 실행이 끝난 뒤에도 이를 기억하고 있다가 함수의 스코프 내에 있는 값에 접근하는 것을 의미한다.

```js
function makeAdder(x) {
  function add(y) {
    return y + x;
  }

  return add;
}

var plusOne = makeAdder(1);
var plusTen = makeAdder(10);

plusOne(3); // 4 = 1 + 3
plusOne(41); // 42 = 1 + 41
plusTen(13); // 23 = 10 + 13
```

makeAdder()를 호출할 때마다 반환되는 add()는, x값을 makeAdder()를 통해 받아옴으로써 참조가 가능하다.

1. makeAdder(1)을 호출하면, x를 1로 기억하는 내부의 add() 함수에 대한 참조가 반환된다(plusOne).
2. makeAdder(10)을 호출하면, x를 10d으로 기억하는 내부의 add() 함수에 대한 참조가 반환된다(plusTen).
3. plusOne(3)을 호출하면, 기억하고 있던 x = 1의 값에 3을 더하고 4라는 결과가 나온다.
4. plusTen(13)을 호출하면, 기억하고 있던 x = 10의 값에 13을 더하고 23이라는 결과가 나온다.

#### Modules

자바스크립트에서 클로저가 자주 사용되는 곳은 모듈 패턴이다.
모듈을 사용하면 외부에서 접근 가능한 API나, 외부로부터 숨겨진 private 변수를 정의할 수 있다.

```js
function User() {
  var username, password;

  function doLogin(user, pw) {
    username = user;
    password = pw;
  }

  var publicAPI = {
    login: doLogin,
  };

  return publicAPI;
}

var fred = User();
fred.login("fred", "12312123");
```

User()는 변수 및 사용자 이름, 암호 내부 doLogin() 함수를 유지하는 스코프 역할을 한다.
그리고 이 함수는 외부에서 접근할 수 없는 private 모듈이다.

User()를 실행하면 새로운 곳에 함수가 생성되어 함수가 가지고 있는 변수/함수의 복사본이 생성하고 Fred 변수에 할당한다.
즉, User()를 다시 실행하게 되면 Fred와는 별도의 장소에서 또 실행이 되는 것이다.

내부에 있는 doLogin()은 사용자명 및 패스워드를 닫힌 상태로 관리하며, 이는 User()의 실행이 끝난 뒤에도 해당 함수에 대한 접근을 유지함을 의미한다.
따라서 User() 함수의 호출이 끝났더라도, Fred 인스턴스의 login()에 클로저가 존재하여
내부 변수들이 그대로 남아있는 것이다.

---

## this 식별자

this가 객체 지향 패턴과 관련 있는 것으로 많이 착각하지만, 자바스크립트에서는 작동 방식이 다르다.

함수 내부에 this 참조가 있는 경우 이 참조는 보통 객체를 가리킨다.
그러나 어떤 객체를 가리키는지는 **함수가 어떻게 호출되었는가**에 따라 다르다.
즉, 함수 자체를 가리키는 것이 아니다.

```js
  function foo() {
    console.log(this.bar)
  }

  var bar = "global"

  var obj1 = {
    bar: "obj1"
    foo: foo
  }

  var obj2 = {
    bar: "obj2"
  }

  foo();    // "global"
  obj1.foo()  // "obj1"
  foo.call(obj2)  // "obj2"
  new foo();  // undefined
```

1. strict mode가 아닐때, foo()는 글로벌 객체로 this를 세팅한다.
   strict mode에서는 bar에 액세스 할 수 없게 되어 undefined가 된다.
2. obj1.foo()는 this를 obj1 객체로 세팅한다.
3. foo.call(obj2)는 obj2로 this를 세팅한다.
4. new foo()는 새로운 빈 객체로 this를 세팅한다.

즉, this가 무엇을 가리키는지 알기 위해서는 함수가 어떻게 호출되었는지를 판단해야한다.

---

## Prototypes

객체의 속성을 참조할 때 해당 속성이 객체에 없으면, 자바스크립트는 자동으로 해당 객체의 내부 프로토타입 참조를 실행하여 다른 객체를 찾는다.
한 객체에서 fallback으로 내부 프로토타입을 참조하여 연결하는 과정은 객체가 생성될 때 발생한다.

```js
  var foo = [a: 42]

  // create "bar" and link it to "foo"
  var bar = Object.create(foo)

  bar.b = "hello world"

  bar.b;  // "hello world"
  bar.a;  // 42
```

a 값이 실제 bar 객체에 존재하지 않지만, bar는 foo 프로토타입에 연결되어 있으므로
a를 찾았다가 없으니까 자동으로 foo 객체에 가서 a를 찾는다.

---

## Old & New

이때까지 다룬 자바스크립트의 기능 중에는 새롭게 추가된 것이 많아 구버전 브라우저에서 사용할 수 없는 경우도 있다.
최신 js를 구버전 브라우저에서 가져오는데 사용할 수 있는 두 가지 기술이 있다. 다형성과 트랜스파일링이다.

### 다형성

다형성은 새로운 기능에 대한 정의를 가져오거나, 같은 동작을 하지만 오래된 js에서 동작할 수 있는 코드를 생성할 때 사용한다.

예를 들어, ES6는 `isNaN()`을 사용하지 않고, 더 정확한 검사를 위해 `Number.isNaN()`을 사용한다.
그러나 ES6 브라우저 사용 유무에 관계없이 `isNaN()`을 사용할 수 있는 방법이 있다.

```js
if (!Number.isNaN) {
  Number.isNaN = function isNaN(x) {
    return x !== x;
  };
}
```

위 예제에서 if문은 ES6 버전에서는 해당 함수를 사용하지 않도록 하는 역할이다.
따라서 `Number.isNaN()`이 존재하지 않는 버전의 브라우저에서는 해당 함수를 실행한다.

다형성을 구현할 때는 신중해야하며, ES5-Shim 또는 ES6-Shim에서 제공하는 신뢰할 수 있는 다형성을 사용하는 것이 좋다.

### Transpiling

언어에 새로 추가된 구문은 새 구문은 이전 js 엔진에서는 인식하지 못하기 때문에 다형성을 구현할 방법이 없다.
이럴 때에는 해당 구문을 이전 버전 코드와 동등한 것으로 변환시키는 트랜스파일을 사용해야한다.

트랜스파일하면 소스 코드는 새 구문으로 작성되지만, 브라우저에 배포되는 것은 이전 구문의 형식으로 변환된 코드이다.
트랜스파일러는 빌드 과정에 추가된다.

트랜스파일을 해야하는 이유는 다음과 같다.

- 새로운 구문이 더 깔끔하고 명시적이므로 협업할 때나 코드 관리할 때 편하다.
- 오래된 브라우저에 대한 트랜스파일을 지원하면서, 새로운 브라우저에 대해서는 새로운 구문을 지원하면, 브라우저 성능 최적화라는 이점이 생긴다.
- 새로운 구문을 사용하면 더 다양하나 테스트를 경험해 볼 수 있으며, 자바스크립트위원회에 피드백을 제공한다.

가장 중요한 점은 js에 새로운 문법이 지속해서 추가되면서 발전할 것이므로, 트랜스파일이 js 개발 프로세스에서 표준으로 자리잡아야 한다는 것이다.

- 트랜스파일러 추천: Babel(ES6+ -> ES5), Traceur

---

## Non-javascript

DOM API와 같은 코드들은 브라우저에서 동작하지만 자바스크립트로 제어하는 것은 아니다.

브라우저에서 코드가 실행될 때 문서 변수는 js 엔진에 의해서 제공되는 것도 아니고, js로 제어되는 것도 아니다.
`document.getElementById()`도 js 함수처럼 보이지만, 브라우저의 DOM에서 제공하는 내장 메서드이며, 이는 js가 아닌 다른 영역의 동작으로 구분한다.
`alert()`나 `console.log()`로 마찬가지로, 브라우저가 제공하는 메서드이다.

이러한 non-javascript에 대한 범위가 명시적으로 보이지 않아, 이에 대한 인식을 가지고 있을 필요가 있다.
