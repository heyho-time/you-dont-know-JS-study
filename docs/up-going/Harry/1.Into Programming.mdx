---
slug: /up-going/harry/programming
title: Into Programming
tags: []
sidebar_position: 1
---

---

## Code

**소스 코드** 또는 그냥 **코드**라고도 하는 **프로그램**은 컴퓨터에 수행할 작업을 알려주는 일련의 **특수 명령**입니다.

유효한 형식과 명령어 조합에 대한 규칙을 컴퓨터 언어라고 하며,

영어에서처럼 철자법과 구두점을 사용하여 유효한 문장을 만듭니다.

---

## Statements

단어(변수), 숫자, 연산자를 이용해 **명령문(statement)**를 만듭니다.

```jsx
a = b * 2;
```

1. `a`, `b`는 **변수(variables)**입니다.

   무언가를 담는 box로 생각합시다.

   변수에는 숫자 42, 문자 'stuff' 등 이 담길 수 있습니다.

2. `2`는 변수에 저장되지 않고 단독으로 존재하는 리터럴 값이라고 합니다.

3. `=` 및 `*` 문자는 연산자입니다.

4. JavaScript의 대부분의 문장은 끝에 `세미콜론(;)`으로 끝납니다.
   <br />
   <br />
   <span style={{ color: "#ff841f", fontSize: 18, fontWeight: "bold" }}>
     "프로그램은 목적을 수행하는데 필요한 명령문들의 모음입니다 !"
   </span>

---

## Expressions

명령문은 하나 이상의 **표현식(expression)**으로 구성됩니다. 표현식은 변수나 값, 또는 연산자와 결합된 변수 및 값 집합에 대한 참조입니다.

```jsx
a = b * 2;
```

이 명령문은 4개의 표현식으로 이루어졌습니다.

- 2는 리터럴 값 표현식 입니다.
- b는 현재 자신에 담긴 값을 검색한다는 의미를 가진 표현식으로 볼 수 있습니다.
- b \* 2는 곱하기를 의미하는 산술식입니다.
- a = b \* 2는 할당 표현식으로, b \* 2 표현식의 결과를 변수 a에 할당하는 것을 의미합니다.

<br />
<br />

다음과 같이 단독으로 사용되는 식을 표현식 명령문이라고도 합니다.

```jsx
b * 2;
```

이 식의 표현문은 일반적으로 프로그램 실행에 영향을 미치지 않으므로 그다지 일반적이거나 유용하지 않습니다.

b의 값을 검색하고 2를 곱하지만 그 다음에는 아무 것도 하지 않습니다.

일반적인 호출식 문으로 아래와 같이 쓰입니다.

```jsx
alert(b * 2);
```

---

## Executing a Program

`a = b * 2` 와 같은 문장은 개발자가 읽고 쓸 때 도움이 되지만

실제로는 컴퓨터가 직접 이해할 수 있는 형태는 아닙니다. 특수 유틸리티가 작성한 코드를 컴퓨터가 이해할 수 있는 명령으로 번역합니다.

일부 컴퓨터 언어의 경우, 일반적으로 프로그램이 실행될 때마다 위에서 아래로 한 줄씩 코드 해석이 수행됩니다.

코드 컴파일이라고 하는 번역이 미리 수행되고 프로그램이 실행될 때 컴파일 된 명령이 실행되는 방식의 언어도 있습니다.

JavaScript 엔진은 프로그램을 즉석에서 컴파일한 다음 컴파일된 코드를 실행합니다.

<!-- 이해 덜 됨. 내용추가예정 -->

<br />
<br />

---

## Try it Yourself

브라우저에서 fn + F12 로 개발자 도구를 열어 사용할 수 있습니다.

<img src="/img/harry/console.png" alt="banner" style={{ width: 600 }} />

<br />
<br />
<br />

---

## Output

```
console.log() 는 개발자 콘솔에서 텍스트를 인쇄하는 방법입니다.
```

1. `log(b)` 부분을 함수 호출이라고 합니다. b 값을 가져와 콘솔에 출력하도록 요청합니다.

2. `console` 부분은 log(..) 함수가 위치한 객체입니다.
   객체와 그 속성은 2장에서 더 자세히 다룹니다.

볼 수 있는 출력을 만드는 또 다른 방법은 `alert(..) `문을 실행하는 것입니다.

```jsx
alert(b);
```

실행하면 콘솔에 출력을 인쇄하는 대신 b 변수의 내용이 포함된 팝업상자가 표시되는 것을 알 수 있습니다.

<br />
<br />

---

## Input

간단한 학습 및 시연 목적으로 입력을 받는 쉬운 방법이 있습니다. `prompt(..)` 함수 입니다.

```jsx
age = prompt("Please, tell me your age:");

console.log(age);
```

<img src="/img/harry/prompt.png" alt="banner" style={{ width: 600 }} />

## <img src="/img/harry/prompt2.png" alt="banner" style={{ width: 600 }} />

<br />

---

## Operators

**연산자(operator)**는 변수와 값에 대한 작업을 수행하는 방법입니다.

우리는 이미 두 개의 JavaScript 연산자 `=`와 `*`를 보았습니다.

```jsx
var a = 20;
a = a + 1;
a = a * 2;

console.log(a); // 42
```

### 연산자 종류

할당 : `=`

연산 : `+`, `-`, `*`, `/`

복합 할당 : `+=`, `-=`, `*=`, `/=`

```
a += 2는 a = a + 2 와 같다.
```

증가/감소 : `++`, `--`,

```
a++은 a = a + 1 과 같다.
```

비교 : `<`, `>`, `<=`, `>=`

동등 : `==(loose-equals)`, `===(strict-equals, 타입까지 비교한다.)`, `!= (loose not-equals)`, `!== (strict not-equals)`

논리 : `&&(and)`, `||(or)`

```
a || b 는 a or b를 의미.
```

<br />

---

## Values & Types

```
Q. 커피 얼마에요?
A. 3000원. -> 3000은 숫자 타입.

Q. 커피 얼마에요?
A. 오늘 무료. -> 무료는 문자 타입.

Q. 커피 절반 마셨는데 환불 되나요?
A. 아니. -> 예, 아니오 (boolean type).
```

### JavaScript에는 이러한 각각의 **원시 값**에 대한 기본 제공 유형이 있습니다.

• 수학을 해야 할 때 **숫자**가 필요합니다.

• 화면에 값을 인쇄해야 하는 경우, **문자열**(하나 이상의 문자, 단어 또는 문장).

• 프로그램에서 결정을 내려야 할 때, **부울**(참 또는 거짓).

<br />

소스 코드에 직접 포함된 값을 리터럴이라고 합니다.

문자열 리터럴은 큰따옴표("...") 또는 작은따옴표('...')로 둘러싸여 있습니다. 큰따옴표와 작은따옴표 표기의 차이점은 없습니다.

숫자 및 부울 리터럴은 있는 그대로 표시됩니다(예: 42, true 등).

`문자열/숫자/부울` 값 유형 외에도 프로그래밍 언어에는 `배열, 개체, 함수` 등을 제공하는 것이 일반적입니다.

<br />

---

## Converting Between Types

JavaScript는 유형(type) 간 강제 변환을 위한 여러 가지 기능을 제공합니다.

```jsx
var a = "42";
var b = Number(a);
console.log(a); // "42"
console.log(b); // 42
```

논쟁의 여지가 있는 주제는 동일한 유형이 아닌 두 값을 비교하려고 할 때 발생하며,

이를 위해서는 암시적 강제가 필요합니다.

문자열 "99.99"를 숫자 99.99와 비교할 때 대부분의 사람들은 그들이 동등하다는 데 동의할 것입니다. 그러나 그것들은 완전히 똑같지 않습니다. 두 가지 다른 표현은 값이 동일하지만 각자 유형(Type)이 다릅니다.
**"느슨하게 평등하다"**고 표현하겠습니다.

"99.99" == 99.99를 비교하면 JavaScript는 왼쪽 "99.99"를 99.99에 해당하는 숫자로 변환합니다. 그러면 비교는 99.99 == 99.99가 되며 이는 물론 사실입니다.
당신을 돕기 위해 고안되었지만, 행동을 지배하는 규칙을 배우는 데 시간을 들이지 않으면 암묵적인 강제가 혼란을 일으킬 수 있습니다. 암시적 강제는 혼란스럽고 예상치 못한 버그로 프로그램에 해를 끼치므로 피해야 한다는 의견이 있습니다. 때로는 언어 디자인의 결함이라고도 합니다.
그러나 암시적 강제는 학습할 수 있는 메커니즘이며 JavaScript 프로그래밍을 진지하게 받아들이고자 하는 사람이라면 누구나 배워야 합니다. 규칙을 배우면 혼란스럽지 않을 뿐만 아니라 실제로 프로그램을 더 좋게 만들 수 있습니다.

<br />

---

## Code Comments

다른 팀원들과 미래의 내가 코드를 이해하기 쉽도록 하는 몇가지 방법이 있습니다.

1. 변수, 함수의 이름을 잘 짓는다.
2. 주석을 단다.

주석은 순전히 사람에게 설명하기 위해 삽입된 프로그램의 텍스트 비트입니다.

주석이 너무 많은 코드는 설명이 너무 많이 필요한 잘못된 코드라는 의견이 있습니다.

JavaScript에는 **한 줄 주석**과 **여러 줄 주석**의 두 가지 유형이 있습니다.

```jsx
var a = 3000; //  I love you, 3000.

/* The following value is used because
       it has been shown that it answers
       every question in the universe. */
var b = 42;
```

줄의 중간, 심지어 줄의 어느 곳에서나 나타날 수 있습니다.

```jsx
var a = /* arbitrary value */ 42;
console.log(a); // 42
```

<br />

---

## Variables

```jsx
var amount = 99.99;
amount = amount * 2;
console.log(amount); //199.98 숫자형

amount = "$" + String(amount); //String()으로 문자열로 변환하지 않아도 밑에 콘솔찍히는 amount는 문자형이 되어있다.
console.log(amount);
```

변수의 또 다른 일반적인 용도는 값 설정을 중앙 집중화하는 것입니다.

필요한 경우 값을 변경하기 위해 한 곳으로 이동하는 것이 편리하도록 종종 프로그램의 맨 위에 이러한 상수를 선언합니다.

```jsx
var TAX_RATE = 0.08; // 8% sales tax
var amount = 99.99;
amount = amount * 2;
amount = amount + amount * TAX_RATE;
console.log(amount); // 215.9784
console.log(amount.toFixed(2)); // "215.98"
```

판매세율을 9%로 올리면 프로그램 전체에 흩어져 있는 값 0.08을 많이 찾아 모두 업데이트하는 대신 TAX_RATE 할당 값을 한 곳에서 0.09로 설정하여 프로그램을 쉽게 업데이트할 수 있습니다. .

```jsx
const TAX_RATE = 0.08;

TAX_RATE = 0.3;
console.log(TAX_RATE); // TypeError: Assignment to constant variable.
```

변수는 var, let, const로 선언하는데, const로 변수 선언할 경우

첫 번째 선언 이후에 TAX_RATE에 다른 값을 할당하려고 하면 프로그램이 변경을 거부합니다.

<br />

---

## Blocks

JavaScript에서 블록은 중괄호 쌍 { .. } 안에 하나 이상의 명령문을 래핑하여 정의됩니다.

```jsx
var amount = 99.99;
// a general block
{
  amount = amount * 2;
  console.log(amount); // 199.98
}
```

이러한 종류의 `독립형 { .. } 일반 블록`은 유효하지만,

일반적으로는 if 문 또는 루프와 같은 다른 제어 문에 연결되어 사용합니다.

```jsx
var amount = 99.99;
// is amount big enough?
if (amount > 10) {
  // <-- block attached to `if`
  amount = amount * 2;
  console.log(amount); // 199.98
}
```

블록 내부의 명령문은 조건이 통과하는 경우에만 처리됩니다.

console.log(amount);와 같은 대부분의 다른 명령문과 달리

블록 명령문은 세미콜론(;)이 필요하지 않습니다.

<br />

---

## Conditionals

가장 일반적인 것은 `if문` 입니다. 기본적으로 "이 조건이 참이면 다음을 수행하십시오..."라고 말합니다.

```jsx
var bank_balance = 302.13;
var amount = 99.99;

if (amount < bank_balance) {
  console.log("I want to buy this phone!");
}
```

else 문으로 대안을 제공할 수도 있습니다.

```jsx
const ACCESSORY_PRICE = 9.99;
var bank_balance = 302.13;
var amount = 99.99;

amount = amount * 2;

if (amount < bank_balance) {
  console.log("I'll take the accessory!");
  amount = amount + ACCESSORY_PRICE;
}
// otherwise:
else {
  console.log("No, thanks.");
}
```

<br />

---

## Loops

특정 조건이 실패할 때까지 일련의 동작을 반복하는 것,

즉 조건이 유지되는 동안에만 반복하는 것은 루프를 프로그래밍하는 작업입니다.

루프에는 테스트 조건과 블록(일반적으로 { .. })이 포함됩니다.

### 1. while 루프와 do..while 루프

조건이 더 이상 true로 평가되지 않을 때까지 명령문 블록을 반복하는 개념입니다.

```jsx
while (numOfCustomers > 0) {
  console.log("How may I help you?");
  // help the customer...
  numOfCustomers = numOfCustomecrs - 1;
}
// versus:
do {
  console.log("How may I help you?");
  // help the customer...
  numOfCustomers = numOfCustomers - 1;
} while (numOfCustomers > 0);
```

조건이 처음에 거짓이면 while 루프는 실행되지 않지만 do..while 루프는 처음에만 실행됩니다.

```jsx
var i = 0;
// a `while..true` loop would run forever, right?
while (true) {
  // keep the loop going?
  if (i <= 9) {
    console.log(i);
    i = i + 1;
  }
  // time to stop the loop!
  else {
    break;
  }
}
// 0 1 2 3 4 5 6 7 8 9
```

조건문은 루프 내부에 암시된 if 문이 있는 것처럼 각 반복에서 테스트 됩니다.

JavaScript의 `break문`을 사용하여 루프를 중지할 수 있습니다.

또한, 중단 메커니즘 없이 영원히 실행될 루프를 만들수도 있습니다.

### 2. for 루프라고 하는 또 다른 구문 형식이 있습니다.

```jsx
for (vari = 0; i <= 9; i = i + 1) {
  console.log(i);
}
// 0 1 2 3 4 5 6 7 8 9
```

<br />

---

## Functions

**함수**는 일반적으로 이름으로 "호출"될 수 있는 명명된 코드 섹션이며

함수 호출시, 그 안의 코드가 실행됩니다.

```jsx
function printAmount() {
  console.log(amount.toFixed(2));
}

var amount = 99.994324;
printAmount(); // "99.99"
```

함수는 선택적으로 **인수(매개변수라고도 함)**, 즉 전달한 값을 사용할 수 있습니다.

```jsx
function printAmount(amt) {
  console.log(amt.toFixed(2));
}
```

또한 선택적으로 값을 다시 반환할 수도 있습니다.

```jsx
function formatAmount() {
  return "$" + amount.toFixed(2);
}

var amount = 99.99;

printAmount(amount * 2); // "199.98"

amount = formatAmount();
console.log(amount); // "$99.99"
```

함수는 여러 번 호출할 계획인 코드에 자주 사용되지만

한번만 호출하는 경우에도 관련 코드 비트를 명명된 컬렉션으로 구성하는게 유용할 수도 있습니다.

```jsx
const TAX_RATE = 0.08;
function calculateFinalPurchaseAmount(amt) {
  // calculate the new amount with the tax
  amt = amt + amt * TAX_RATE;
  // return the new amount
  return amt;
}

var amount = 99.99;

let taxedAmount = calculateFinalPurchaseAmount(amount);
console.log(taxedAmount.toFixed(2)); // "107.99"
```

CalculateFinalPurchaseAmount(..)는 한 번만 호출되지만 해당 논리(taxedAmount = calculateFinal... 문)를 사용하는 코드가 더 깔끔해집니다. 함수에 더 많은 명령문이 포함되어 있으면 이점이 훨씬 더 분명해집니다.

<br />

---

## Scope

JavaScript에서 각 함수는 고유한 범위를 갖습니다.

범위는 기본적으로 변수의 모음과 이러한 변수에 이름으로 액세스하는 범위에 대한 규칙입니다.

해당 함수 내부의 코드만 해당 함수의 범위 변수에 액세스할 수 있습니다.

변수 이름은 동일한 범위 내에서 고유해야 합니다. 그러나 동일한 변수 이름이 다른 범위에 나타날 수 있습니다.

```jsx
function one() {
  // this `a` only belongs to the `one()` function
  var a = 1;
  console.log(a);
}

function two() {
  // this `a` only belongs to the `two()` function
  var a = 2;
  console.log(a);
}

one(); // 1
two(); // 2
```

한 범위가 다른 범위 안에 중첩된 경우 가장 안쪽 범위 내의 코드는 두 범위의 변수에 액세스할 수 있습니다.

```jsx
function outer() {
  var a = 1;

  function inner() {
    var b = 2;
    // we can access both `a` and `b` here
    console.log(a + b); // 3
  }
  inner();
  // we can only access `a` here
  console.log(a); // 1
  console.log(b); //ReferenceError: b is not defined
}
outer();
```

<br />

---

## Practice

가진 잔고로 최대한 핸드폰을 사려고한다. 함수를 만들어보자.

```jsx
const SPENDING_THRESHOLD = 200; //정신적 최대 소비가능금액
const TAX_RATE = 0.08;
const PHONE_PRICE = 99.99;
const ACCESSORY_PRICE = 9.99;
var bank_balance = 303.91;

var amount = 0;

function calculateTax(amount) {
  // 택스를 계산하는 동작을 한 함수로 만들었다.
  return amount * TAX_RATE;
}

function formatAmount(amount) {
  return "$" + amount.toFixed(2); // $을 붙인 문자열로 반환하기위한 함수를 만들었다.
}
// keep buying phones while you still have money
while (amount < bank_balance) {
  // buy a new phone!
  amount = amount + PHONE_PRICE;
  // can we afford the accessory?
  if (amount < SPENDING_THRESHOLD) {
    amount = amount + ACCESSORY_PRICE;
  }
}

// 폰 + 액세서리 +두번째 폰 까지 사게 되고.. 209.96999...금액이 된다.
// 정신적 최대 소비가능금액을 넘는다.
// 그러고도 while문이 또 한번 돌면서
// 폰을 하나 더사게되고 결국 amount는 309.96 이 된다.

// don't forget to pay the government, too
amount = amount + calculateTax(amount);
//거기에 택스까지 붙는다...
//그러면 334.7568가 되버린다..
console.log("Your purchase: " + formatAmount(amount));
// Your purchase: $334.76
// can you actually afford this purchase?
if (amount > bank_balance) {
  console.log("You can't afford this purchase. :(");
}
```
