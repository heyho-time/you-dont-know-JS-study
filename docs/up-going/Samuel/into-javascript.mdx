---
slug: /up-going/samuel/into-javascript
title: Into Javascript
tags: [basics, programming, javascript]
sidebar_position: 2
---

<br />

## 들어가며 🏃

---

이전 파트에서 프로그래밍에 대한 기본적인 내용을 배웠다면, 이번 내용은 **자바스크립트 개발자로 일어서기 위한 내용**에 중점을 둡니다.

정확히 말하자면 **해당 시리즈의 나머지 부분에서 다루는 주제의 개요**라고 보는 것이 편합니다.

<br />

## Values & Types ❕

---

> **TL;DR 🔖**
>
> - 자바스크립트에는 **타입이 지정된 값**이 있으며 **자체적으로 제공하는 타입들**이 있습니다.
> - 타입을 확인하기 위한 **`typeof` 연산자**가 있으며, **7가지의 문자열 중 하나**를 반환합니다.
> - **객체**는 키와 값을 갖는 프로퍼티로 구성된 값 타입이며, **배열과 함수**라는 특수한 객체가 있습니다.
> - **내장 및 하위 타입**은 유용한 프로퍼티 및 메서드를 가지며, 기본값을 객체로 사용할 때 그 값에 해당하는 **객체 래퍼에 Box**합니다.
> - **값 비교**를 위해 **등식과 부등식**이 있고, 등식의 염격한 비교를 제외한 나머지(느슨한 등식과 부등식 전부)는 **강제 변환**을 허용합니다.

<br />

1장에서 말했듯이, 자바스크립트에는 타입이 지정된 변수가 아닌 **타입이 지정된 값**이 있습니다.

다음의 기본 제공 타입을 사용할 수 있습니다.

- `string`
- `number`
- `boolean`
- `null` and `undefined` • `object`
- `symbol` (new to ES6)

자바스크립트에선 이러한 **타입을 `typeof` 연산자를 통해 확인할 수 있습니다.**

```js
var a;
typeof a; // "undefined"

a = "hello world";
typeof a; // "string"

a = 42;
typeof a; // "number"

a = true;
typeof a; // "boolean"

a = null;
typeof a; // "object"--weird, bug

a = undefined;
typeof a; // "undefined"

a = { b: "c" };
typeof a; // "object"
```

- `typeof` 연산자의 반환값은 **항상 7가지 문자열 중 하나**입니다.
  - 즉, 값 `"abc"` 는 `string` 이 아닌 `"string"` 을 반환합니다.
- `typeof` 는 변수의 타입이 아닌 **변수 안의 값에 대한 타입**을 반환하는 것을 알아야합니다.
  - 변수는 단순한 컨테이너입니다.
- **`typeof null`**은 `"null"` 을 반환할 것 같지만 **`"object"` 를 반환합니다.**
  - 이는 자바스크립트가 갖는 오래된 오류지만 이를 수정하면 발생하는 오류가 많기에 수정하지 않을 것입니다.
- `undefined` 를 할당한다고 **명시적으로 정의되지 않은 값**을 설정하지만, 이는 `var a` 와 같이 아직 할당하지 않은 값과 같은 경우에 해당합니다.
  - 그렇기에 **명시적으로 이를 표현하기 위해 변수에 `null` 혹은 함수 반환값에 `void` 를 할당**하여 해결할 수 있습니다.

<br />

### Object ❓

---

**객체(Object)** 타입은 **모든 타입의 고유한 값을 각각 보유한 프로퍼티를 갖는 복합적인 값**을 나타냅니다.

```ts
var obj = {
  a: "hello world",
  b: 42,
  c: true,
};

obj.a; // "hello world"
obj.b; // 42
obj.c; // true

obj["a"]; // "hello world"
obj["b"]; // 42
obj["c"]; // true
```

위 코드의 객체 `obj` 를 시각화하면 다음과 같이 표현할 수 있습니다.

<img src="/img/samuel/into-javascript/object.png" width="550" />

프로퍼티에 접근하는 방법은 **점 표기법(Dot notation : `.`)과 대괄호 표기법(Bracket notation : `[]`)**이 있습니다.

- 점 표기법은 **더 짧고 읽기 쉽기에** 주로 자주 사용합니다.
- 대괄호 표기법은 **동적 참조**가 가능합니다.
  - **변수 혹은 연산을 통한 결과**를 프로퍼티의 키 값으로 할당할 수 있습니다.

```js
var obj = {
  a: "hello world",
  b: 42,
};

var b = "a";

obj[b]; // "hello world"
obj["b"]; // 42
```

또한, 객체 타입이 특수화 된 **배열과 함수**라는 타입도 존재합니다.

<br />

#### Array

---

배열(Array)은 **프로퍼티의 키 값으로 숫자로 인덱싱 된 위치 값을 보유하는 객체**입니다.

```js
var arr = ["hello world", 42, true];

arr[0]; // "hello world"
arr[1]; // 42
arr[2]; // true
arr.length; // 3

typeof arr; // "object"
```

> 배열의 인덱싱은 0부터 시작합니다.

이를 시각화하면 다음과 같습니다.

<img src="/img/samuel/into-javascript/array.png" width="600" />

- 배열은 자동으로 업데이트 되는 **`length` 프로퍼티**도 가질 수 있습니다.
  - 배열도 객체와 같이 **명명된 프로퍼티**를 사용할 수 있지만, 이는 부적절한 사용으로 간주되며 이를 지양하고 **각 역할에 따라 구분지어 사용해야합니다.**

<br/>

#### Function

---

또 다른 객체 하위 유형으로 **함수(Function)**가 있습니다.

```js
function foo() {
  return 42;
}

foo.bar = "hello world";

typeof foo; // "function"
typeof foo(); // "number"
typeof foo.bar; // "string"
```

배열과 같이 함수 또한 **프로퍼티**를 가질 수 있지만, 이는 역시 부적절한 사용입니다.

- 그렇기에 위 `foo.bar` 와 같은 경우는 지양합니다.

<br/>

### Built-In Type Methods ❓

---

**내장 타입 및 하위 타입(Built-In Type Methods)**에는 유용한 **프로퍼티 및 메서드**가 있습니다.

```js
var a = "hello world";
var b = 3.14159;

a.length; // 11
a.toUpperCase(); // "HELLO WORLD"
b.toFixed(4); // "3.1416"
```

`a.toUpperCase()` 를 호출하는 것은 값에 존재하는 메서드보다 더 복잡합니다.

- 간단히 말해 기본 문자열 타입과 쌍을 이루는 `String` 객체 래퍼 형식(네이티브)이 해당 메서드(`toUpperCase`)를 정의합니다.
  - 프로퍼티나 메서드를 참조하여 **기본 값을 객체로 사용할 때** 해당 기본 값에 해당하는 **객체 래퍼에 이를 Box합니다.**
  - 문자열은 `String` 객체로 숫자는 `Number` 객체로 그리고 불리언은 `Boolean` 객체로 래핑될 수 있습니다.

<br/>

### Comparing Values ❓

---

자바스크립트에선 **등식(equality)과 부등식(inequality)**이라는 **값 비교를 위한 방법**이 있습니다.

- 이러한 값 비교의 **모든 결과는 불리언(`true` 혹은 `false`)으로 반환**됩니다.

이를 위해 이전 개념인 **강제 변환(Coercion)**에 대한 내용을 다시 짚어보겠습니다.

- 명시적 강제 변환의 경우 코드 상에서 타입의 변환을 확인할 수 있지만, 암시적 강제 변환의 경우 **이를 확인할 수 없어 오류로 이어질 수 있습니다.**
- 이러한 암시적 강제 변환은 자바스크립트 사용자로 하여금 혼란을 야기할 수 있습니다.

```js
// 명시적 강제 변환

var a = "42";
var b = Number(a);

a; // "42"
b; // 42--the number!
```

```js
// 암시적 강제 변환

var a = "42";
var b = a * 1; // "42" implicitly coerced to 42 here

a; // "42"
b; // 42--the number!
```

<br/>

#### Truthy & Falsy

---

**불리언이 아닌 값이 불리언으로 강제 변환될 때** 해당 값은 유형에 따라 **Truthy 혹은 Falsy** 값으로 구분됩니다.

자바스크립트에서 **Falsy로 여겨지는 값**은 다음과 같습니다.

- `""` (빈 문자열)
- `0`, `-0`, `NaN`(숫자에 부적합한 형태) • `null`, `undefined`
- `false`

이외에는 모두 **Truthy**로 간주됩니다.

- 다시 한 번 되짚을 부분은 이러한 현상이 **강제 변환이라는 것**입니다.

<br/>

#### Equality

---

등호 연산자는 **총 네 가지(`==`, `===`, `!=`, `!==`)**이고 이를 부등호와 헷갈리면 안됩니다.

- `==` 와 `===` 의 차이점은 **강제 변환의 괸점에서 이를 허용하는지의 여부**입니다.
  - `===` 은 강제 변환을 허용하지 않으며, **타입이 다르다면 이를 같지 않다고 판단합니다.**

```js
var a = "42";
var b = 42;

a == b; // true
a === b; // false
```

- `==` 비교의 경우 문자열 `"42"` 의 값이 숫자 `42` 로 강제 변환되어 `true` 를 반환합니다.
- 반대로 `===` 의 경우 두 값의 타입이 다르기 때문에, `false` 를 반환합니다.

일반적으로 `===` 가 보다 예측 가능한 부분이 있기에 이를 지향해야 한다고 합니다.

- 해당 도서에서는 이에 대해 근시안적이라고 평가하며, **프로젝트가 어떻게 동작하는지 알기 위한 것**에 목적을 둔다면 이는 효율적인 도구로서 사용 가능하다고 합니다.

그렇기에 해당 도서에선 **`==` 와 `===` 를 구분지어 사용할 규칙**을 정의합니다.

- 비교할 값이 **`true` 혹은 `false` 값일 수 있을 경우** `==` 를 피하고 `===` 를 사용합니다.
- 비교할 값이 **특정 값(`0`, `""`, `[]` 등)일 경우**, `==` 를 피하고 `===` 를 사용합니다.
- 다른 모든 경우에선 `==` 를 사용하는 것이 **안전하고 가독성을 높이는 방식으로 코드를 단순화**합니다.

객체 비교의 경우 기본값에 대한 것이 아니라 **참조의 일치 여부를 비교**합니다.

- 그렇기에 아래 `b` 와 `c` 는 일치할 것이라고 판단되지만 그렇지 않습니다.

```js
var a = [1, 2, 3];
var b = [1, 2, 3];
var c = "1,2,3";

a == c; // true
b == c; // true
a == b; // false
```

<br/>

#### Inequality

---

관계형 비교라고 불리는 **부등식**은 `<`, `>`, `<=`, `>=` 를 통해 표현할 수 있습니다.

- 일반적으로 **숫자** 타입의 값을 비교할 때 사용할 수 있습니다.
- 문자열의 경우 **일반적인 알파벳 규칙**을 통해 비교할 수도 있습니다.
  - 예를 들어, `"bar" < "foo"`
- 또한, 강제 변환이 적용됩니다.

```js
var a = 41;
var b = "42";
var c = "43";

a < b; // true
b < c; // true
```

- 비교하는 값 두 가지 모두 문자열일 경우 **사전순으로 비교가 진행**됩니다.
- 하나라도 숫자일 경우 **숫자로 강제 변환되어 숫자 비교가 발생**합니다.

```js
var a = 42;
var b = "foo";

a < b; // false
a > b; // false
a == b; // false
```

세 가지 모두가 `false` 인 이유는 다음과 같습니다.

- 변수 `b` 는 부등식에서 숫자가 아닌 값으로 분류되어 `NaN` 으로 강제 변환되고 이는 다른 값보다 크지도 작지도 않습니다.
- `==` 의 경우 `42 == NaN`, `"42" == "foo"` 로 해석되기에 `false` 에 해당합니다.

## Variables ❕

---

> **TL;DR 🔖**
>
> - 자바스크립트에서 변수는 **유효한 식별자**이어야 한다는 일련의 규칙이 있습니다.
> - **`var` 선언을 통해 선언된 변수**는 해당 선언이 코드 상 최상단으로 이동된다고 표현되며 이를 **호이스팅**이라고 합니다.
> - `let` 선언을 통한 재선언이 불가능한 변수를 선언할 수도 있습니다.

<br />

자바스크립트에서 변수의 이름은 **유효한 식별자(valid identifiers)**여야 하며, 이에 대한 규칙은 다음과 같습니다.

- 식별자는 `a`-`z`, `A`-`Z` `$` 또는 `_`로 시작해야 합니다.
- 이후에 해당 문자와 숫자 `0`-`9` 를 포함할 수 있습니다.
- 식별자로 **예약어(`null`, `true`, `false` 등)**를 사용하지 못합니다.

<br/>

### Function Scopes ❓

---

`var` 키워드를 사용하여 **현재 함수 스코프에 속할 변수를 선언**하거나 함수 외부 **최상위 수준에 있는 경우 전역 스코프를 선언**합니다.

<br/>

#### Hoisting

---

`var` 가 특정 스코프 내에 나타날 때마다 해당 선언은 **해당 스코프 내 전체에 속하는 것으로 간주되며 어디에서든 액세스가 가능합니다.**

- 비유적으로 이러한 동작은 **`var` 선언이 코드 상의 최상단으로 이동된다고 표현**하며, 이를 **호이스팅**이라고 합니다.

> 해당 프로세스는 코드가 컴파일되는 방식으로 더 정확하게 설명할 수 있지만, 이를 생략하겠습니다.

```js
var a = 2;

// declaration is "hoisted"
foo(); // works because `foo()`

function foo() {
  a = 3;

  console.log(a); // 3

  // declaration is "hoisted"
  var a; // declaration is "hoisted"
}

console.log(a); // 2
```

<br/>

#### Nested scopes

---

변수를 선언하면 **해당 스코프와 모든 하위/내부 스코프에서 사용할 수 있습니다.**

```js
function foo() {
  var a = 1;

  function bar() {
    var b = 2;

    function baz() {
      var c = 3;

      console.log(a, b, c); // 1 2 3
    }
  }
  baz();

  console.log(a, b); // 1 2
}
bar(); // 1

console.log(a);

foo();
```

- 변수 `c` 는 `baz()` 스코프에서 선언되었고 `b` 또한 `bar()` 스코프 내에서만 선언되었기에 `foo()` 에서 사용할 수 없습니다.
- **사용할 수 없는 스코프의 변수 값에 접근**하려고 하면 **Reference Error**가 발생합니다.
- 또한, **선언되지 않은 변수를 설정**하려고 하면 `"strict mode"` 유무에 따라 최상위 전역 스코프에 변수를 생성하거나 오류가 발생합니다.

```js
function foo() {
  a = 1; // `a` not formally declared
}

foo();

a; // 1--oops, auto global variable :(
```

함수 수준에서 변수에 대한 선언을 생성하는 것 외에도 **ES6에서는 `let` 키워드를 사용하여 개별 블록(`{...}`)에 속하는 변수를 선언할 수 있습니다.**

- 미묘한 세부사항 외에도 스코프 지정 규칙은 방금 함수에서 본 것과 거의 동일하게 작동합니다.

```js
function foo() {
  var a = 1;

  if (a >= 1) {
    let b = 2;

    while (b < 5) {
      let c = b * 2;

      b++;

      console.log(a + c);
    }
  }
}

foo(); // 5 7 9
```

- `var` 대신 **`let` 을 사용해서 `b` 는 `if` 문에만 속하고 전체 `foo()` 함수 범위에 속하지 않습니다.**
  - 마찬가지로 `c` 는 `while` 루프에만 속합니다.

**블록 스코프 지정**은 보다 세분화된 방식으로 변수 범위를 관리하는데 매우 유용합니다.

<br/>

## Conditionals ❕

---

> **TL;DR 🔖**
>
> - 자바스크립트에선 `if` 문 외에도 **`switch` 문** 혹은 **삼항 연산자**와 같은 조건 메커니즘이 존재합니다.
> - 특정 케이스를 정의해야 하는 경우 `switch` 문을 `if...else` 문을 요약해서 사용하고자 하면 삼항 연산자를 활용할 수 있습니다.

<br />

`if` 문 외에도 자바스크립트에선 우리가 살펴봐야 할 몇 가지 조건 메커니즘을 제공합니다.

```js
if (a == 2) {
  // do something
} else if (a == 10) {
  // do another thing
} else if (a == 42) {
  // do yet another thing
} else {
  // fallback to here
}
```

위와 같은 상황에선 **각 경우(`case`)에 대한 테스트를 지정**해야 하기 때문에 **`switch` 문**을 활용할 때 더욱 적합할 것입니다.

```js
switch (a) {
  case 2:
    // do something
    break;
  case 10:
    // do another thing
    break;
  case 42:
    // do yet another thing
    break;
  default:
  // fallback to here
}
```

**하나의 명령문만 실행**하려면 `break` 가 필요합니다.

- `break` 를 생략할 경우 `case` 일치와 관계없이 다음 케이스 명령문으로 실행이 이어집니다.
  - 이러한 흐름은 때로는 유용합니다.

```js
switch (a) {
  case 2:
  case 10:
    // some cool stuff
    break;
  case 42:
    // other stuff
    break;
  default:
  // fallback
}
```

여기서 `a` 가 `2` 또는 `10` 이면 `"some cool stuff"` 코드를 실행합니다.

자바스크립트의 조건부의 또 다른 형태로 **삼항 연산자**라 불리는 **조건부 연산자**가 있습니다.

- 이는 `if...else` 문의 간결한 형태로 보면 쉽습니다.

```js
var a = 42;

var b = a > 41 ? "hello" : "world"; // similar to:
// if (a > 41) {
//    b = "hello";
// }
// else {
//    b = "world";
// }
```

**삼항 연산자**는 **조건 표현식(여기서는 `a > 41`)**에서 `true` 로 평가되면 첫 번째 절의 내용이 반영되고, `false` 일 경우 두 번째 절의 내용이 반영됩니다.

<br/>

## Strict Mode ❕

---

> **TL;DR 🔖**
>
> - 자바스크립트에서는 `"strict mode"` 를 사용하여 특정 규칙에 대한 규칙을 강화하여 프로그램 내 오류를 파악하는데 도움이 됩니다.

<br />

ES5는 특정 구문에 대한 규칙을 강화하는 **`"strict mode"`** 를 자바스크립트에 추가했습니다.

- 일반적으로 이러한 제한은 **코드를 보다 안전하고 적절하게 유지하는 것**으로 간주됩니다.
- 또한 이러한 조치는 **엔진에서 코드를 더 최적화할 수 있습니다.**
- `"strict mode"` pragma의 **배치 위치에 따라 개별 함수 또는 전체 파일에 대해 이를 설정**할 수 있습니다.

```js
function foo() {
  "use strict";
  // this code is strict mode
  function bar() {
    // this code is strict mode
  }
}
// this code is not strict mode
```

위 코드의 경우 부분적으로 `"strict mode"` 를 적용하지만 이어지는 예시의 경우 전역으로 설정됩니다.

```js
"use strict";

function foo() {
  // this code is strict mode
  function bar() {
    // this code is strict mode
  }
}
// this code is strict mode
```

`"strict mode"` 의 주요한 개선 사항은 **암시적 자동 전역 변수 선언에서 `var` 생략을 허용하지 않는다는 것**입니다.

```js
function foo() {
  "use strict"; // turn on strict mode
  a = 1; // `var` missing, ReferenceError
}

foo();
```

- `"strict mode"` 를 발생시키고 오류가 발생하여 이를 피하고자 하는 것은 능사가 아닙니다.
  - 이를 프로그램에 문제가 있다는 신호로 받아들이고, 수정의 여지를 받아들이는 것이 옳습니다.

<br/>

## Functions as Values ❕

---

> **TL;DR 🔖**
>
> - **함수 값은 표현식으로 간주**해야 하며 익명 함수 표현식보다 명명된 함수 표현식이 선호됩니다.
> - **즉시 호출 함수 표현식**은 함수를 **선언과 동시에 실행할 수 있는 방법**입니다.
> - **클로저(Closure)**는 **함수 실행이 끝난 후에도 기억하고 함수의 스코프에 계속 접근하는 방법**이라고 생각하면 되고, **모듈 방식**으로 활용하는 것이 일반적입니다.

<br />

일반적인 함수 선언 구문은 다음과 같습니다.

```js
function foo() {
  // ..
}
```

여기서 `foo` 는 기본적으로 **선언된 함수에 대한 참조가 제공되는 변수**입니다.

- 즉 함수 자체는 `42` 혹은 `[1, 2, 3]` 과 같은 값입니다.
- 이상한 내용으로 들릴 수 있지만 **함수에 인자를 전달**할 수 있을 뿐만 아니라 함수 자체는 **변수에 할당**되거나 **다른 함수에 전달**되거나 **다른 함수에서 반환되는 값**일 수 있습니다.
- 그렇기에 함수 값은 다른 값과 마찬가지로 **표현식으로 간주해야 합니다.**

```js
var foo = function () {
  // ..
};

var x = function bar() {
  // ..
};
```

- `foo` 변수에 할당된 첫 번째 함수 표현식은 이름이 없기 때문에 **익명 함수**라고 합니다.
- 두 번째 함수 표현식의 이름은 `bar` 로 지정되며 참조가 `x` 변수에도 할당됩니다.
  - 익명 함수 표현식이 매우 일반적이지만 명명된 함수 표현식이 일반적으로 더 선호됩니다.

<br/>

### Immediately Invoked Function Expressions (IIFEs) ❓

---

이전 예시의 함수 표현식은 `foo()`, `x()` 와 같은 실행식이 없었기에 모두 실행되지 않았습니다.

일반적으로 **즉시 호출 함수 표현식(IIFE)**라고 하는 함수 표현식을 실행하는 또 다른 방법이 있습니다.

```js
(function IIFE() {
  console.log("Hello!");
})();
// "Hello!"
```

- **함수 표현식을 감싸는 외부 소괄호(`()`)**는 일반 함수 선언으로 마무리되는 것을 방지하기 위한 자바스크립트 문법의 뉘앙스입니다.
- 표현식 마지막의 소괄호가 이를 실행하는 것으로 보입니다.
- 낯설어 보이지만 `foo` 와 IIFE의 유사점을 고려해봅시다.

```js
function foo() { .. }

// `foo` function reference expression,
// then `()` executes it
foo();

// `IIFE` function expression,
// then `()` executes it
(function IIFE(){ .. })();
```

- 본질적으로 **함수를 실행하기 이전에 선언부를 나열하는 것**은 둘 다 동일합니다.
- IIFE는 단지 함수이고, **함수는 변수 스코프를 생성**하기 때문에 이러한 방식으로 IIFE를 선언하는 것은 **주변 코드에 영향을 미치지 않는 변수를 선언**하는데 사용됩니다.

```js
var a = 42;

(function IIFE() {
  var a = 10;

  console.log(a); // 10
})();

console.log(a); // 42
```

IIFE는 **반환값**을 가질 수도 있습니다.

```js
var x = (function IIFE() {
  return 42;
})();

x; // 42
```

`42` 값은 실행 중인 IIFE 함수에서 반환된 다음 `x` 에 할당됩니다.

<br/>

### Closure ❓

---

클로저는 자바스크립트에서 가장 중요하지만 가장 이해하기 어려운 개념 중 하나입니다.

> 해당 파트에선 다른 시리즈(Scope & Closures)에서 자세히 설명될 내용을 간단하게 일반적인 개념만 설명하도록 하겠습니다.

**클로저(Closure)**는 **함수 실행이 끝난 후에도 기억하고 함수의 스코프에 계속 접근하는 방법**으로 생각할 수 있습니다.

```js
function makeAdder(x) {
  // parameter `x` is an inner variable

  // inner function `add()` uses `x`, so
  // it has a "closure" over it
  function add(y) {
    return y + x;
  }

  return add;
}
```

외부의 `makeAdder()` 를 호출할 때마다 반환되는 **내부 `add()` 함수에 대한 참조**는 `makeAdder()` 에 전달된 인자 **`x` 의 값을 기억할 수 있습니다.**

```js
// `plusOne` gets a reference to the inner `add(..)` // function with closure over the `x` parameter of // the outer `makeAdder(..)`
var plusOne = makeAdder(1);

// `plusTen` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusTen = makeAdder(10);

plusOne(3); // 4  <-- 1 + 3
plusOne(41); // 42  <-- 1 + 41

plusTen(13); // 23 <-- 10 + 13
```

간단한 설명으로 코드 작동 방식에 대해 이해를 돕겠습니다.

- `makeAdder(1)` 를 호출하면 `x` 를 `1` 로 기억하는 내부 `add(..)` 에 대한 참조를 다시 얻습니다. 이 함수 참조를 `plusOne(..)`이라고 합니다.
- `makeAdder(10)`를 호출하면 `x` 를 `10` 으로 기억하는 내부 `add(..)`에 대한 또 다른 참조를 다시 얻습니다. 이 함수 참조를 `plusTen(..)`이라고 합니다.
- `plusOne(3)`을 호출하면 `1`(`x` 로 기억됨)에 `3`(내부 `y`)을 더하고 결과로 `4`를 얻습니다.
- `plusTen(13)`을 호출하면 `10`(`x` 로 기억됨)에 `13`(내부 `y`)을 더하고 결과로 `23`을 얻습니다.

이렇게 해석해도 이해하기에 많이 어렵습니다.

- 하지만 클로저는 모든 프로그래밍에서 가장 강력하고 유용한 기술 중 하나입니다.

<br/>

#### Modules

---

자바스크립트 클로저의 일반적인 사용법은 **모듈(Module) 패턴**입니다.

- 모듈을 사용하면 **외부에서 접근할 수 있는 공개 API를 정의할 수 있습니다.**

```js
function User() {
  var username, password;

  function doLogin(user, pw) {
    username = user;
    password = pw;

    // do the rest of the login work
  }
  var publicAPI = { login: doLogin };

  return publicAPI;
}
// create a `User` module instance
var fred = User();

fred.login("fred", "12Battery34!");
```

`User()` 함수는 내부 `doLogin()` 함수뿐만 아니라 변수 `username` 과 `password` 를 보유하는 외부 스코프 역할을 합니다.

- 해당 내용들은 외부에서 접근할 수 없는 해당 **`User` 모듈의 비공개 내부 정보**입니다.
- 여기서 `User()` 는 인스턴스화할 클래스가 아니기에 **`new User` 를 호출하지 않습니다.**
- `User()` 를 실행하면 **`User` 모듈의 인스턴스가 생성**됩니다.
  - 이렇게 되면 **완전히 새로운 스코프가 생성**되기에 **내부 변수/함수 각각의 완전한 복사본이 생성**됩니다.
  - 이후 해당 복사본을 `fred` 에 할당합니다.
- 내부 `doLogin()` 함수에는 **`username` 과 `password` 에 대한 클로저가 있습니다.**
  - 즉, `User()` 함수 실행이 완료된 이후에도 **해당 함수에 대한 접근이 유지됩니다.**
- `publicAPI` 는 **내부 `doLogin()` 함수에 대한 참조**인 **`login` 프로퍼티가 있는 객체**입니다.
  - `User()` 에서 `publicAPI` 을 반환하면 `fred` 라고 불리는 인스턴스가 됩니다.

여기서 외부 `User()` 함수의 실행이 완료되었기에 **`username` 과 `password` 와 같은 내부 변수가 사라졌다**고 생각됩니다.

- `login()` 함수에 클로저가 있기에 **내부 `doLogin()` 을 호출하는 것과 동일하게 `fred.login()` 을 호출할 수 있습니다.**

<br/>

## this Identifier ❕

---

> **TL;DR 🔖**
>
> - 자바스크립트에서 `this` 는 함수 내부에서 **일반적으로 객체**를 가리키지만, 어떤 객체를 가리키는지는 **함수가 어떻게 호출되었는지**에 따라 달라집니다.

<br />

자바스크립트에서 흔히 잘못 이해되는 또 다른 개념은 `this` 입니다.

> 이 시리즈의 this & Object Prototypes에서 이에 대한 몇 개의 장이 있으므로 여기서는 개념을 간단히 소개하겠습니다.

종종 `this` 를 **객체 지향 패턴**과 관련이 있는 것으로 여기지만, 자바스크립트에서는 다른 메커니즘을 갖습니다.

- **함수 내부에 `this` 참조가 있는 경우**, 이 참조는 일반적으로 **객체를 가리킵니다.**
  - 그러나 어떤 객체를 가리키는지는 **함수가 어떻게 호출되었는지**에 따라 달려있습니다.

```js
function foo() {
  console.log(this.bar);
}

var bar = "global";

var obj1 = { bar: "obj1", foo: foo };

var obj2 = { bar: "obj2" };

// --------

foo(); // "global"
obj1.foo(); // "obj1"
foo.call(obj2); // "obj2"
new foo(); // undefined
```

위 코드에 **`this` 가 설정되는 방법에 대한 네 가지 규칙**이 나타나있습니다.

- `foo()` 는 **비엄격 모드**에서 `this` 를 **전역 객체로 설정**합니다. **엄격 모드**에서 `this` 는 **정의되지 않고 `bar` 프로퍼티에 액세스할 때 오류가 발생**합니다. 따라서 `"global"` 은 변수 `bar` 에 대한 값입니다.
- `obj1.foo()` 는 `this` 를 `obj1` 객체로 설정합니다.
- `foo.call(obj2)` 은 `this` 를 `obj2` 객체로 설정합니다.
- `new foo()` 는 `this` 를 **완전히 새로운 빈 객체**로 설정합니다.

결국 `this` 가 가리키는 것을 알기 위해서는 **함수의 호출을** 알아야 합니다.

<br/>

## Prototypes ❕

---

> **TL;DR 🔖**
>
> - 자바스크립트의 **프로토타입**의 동작은 클래스의 상속을 위조하는 것으로 이해할 수 있지만, 정확히는 **작동 위임**이라는 개념을 이해해야 합니다.

<br />

자바스크립트의 **프로토타입(Prototype)** 메커니즘은 상당히 복잡합니다.

- 객체의 프로퍼티를 참조할 때, 자바스크립트는 해당 프로퍼티가 없으면 **자동으로 해당 객체의 내부 프로토타입 참조를 사용**하여 프로퍼티를 찾을 다른 객체를 찾습니다.
- 프로퍼티가 누락된 경우, 이를 거의 **Fallback**으로 생각할 수 있습니다.
  - 한 객체의 Fallback으로의 내부 프로토타입 참조 연결은 **객체가 생성될 때 발생**합니다.
  - 이를 설명하는 가장 간단한 방법은 **`Object.create()` 라는 내장 유틸리티를 사용하는 것**입니다.

> **Fallback의 의미 🔍**
>
> - fallback이라는 단어의 사전적 정의로 **"만일을 위해 대비한"**이라는 의미가 있고, Font Fallback은 윈도우 운영체제에서 DC에서 선택한 폰트가 해당 언어의 글자를 지원하지 못할 경우 **알아서 적합한 폰트를 자동으로 선택하여 출력해주는 것**을 의미합니다.
> - 이러한 맥락에서 Fallback은 **누락을 위한 대비**쯤으로 이해할 수 있을 것 같습니다.

```js
var foo = { a: 42 };
// create `bar` and link it to `foo`

var bar = Object.create(foo);

bar.b = "hello world";
bar.b; // "hello world"
bar.a; // 42 <-- delegated to `foo`
```

이를 시각화하면 다음과 같습니다.

<img src="/img/samuel/into-javascript/prototype.png" width="600" />

- 프로퍼티 `a` 는 `bar` 객체에 실제로 존재하지 않지만 `bar` 는 `foo` 에 **프로토타입 링크**가 되어 있기에 이상한 기능처럼 보일 수 있습니다.
- 이 기능이 사용되는 가장 일반적인 방법은 **상속(Inheritance)**을 사용하여 **클래스 메커니즘을 위조하는 것**입니다.
- 그러나 프로토타입을 적용하는 보다 자연스러운 방법은 **작동 위임(behavior delegation)**이라는 패턴입니다.
  - 여기서 **연결된 객체가 필요한 동작의 일부에 대해 다른 객체로 위임할 수 있도록** 의도적으로 디자인합니다.

> 위 예시를 활용하여 이를 설명하면 작동 위임이란 `bar` 객체가 링크되어 있는 `foo` 에게 **`a` 라는 프로퍼티를 참조하는 동작(작동)을 위임하는 것**이지 않을까 생각해본다.

<br/>

## Old & New ❕

---

> **TL;DR 🔖**
>
> - 구버전의 브라우저에서 자바스크립트 신기능을 사용할 수 있는 방법으로 **폴리필링과 트랜스파일링**이 있습니다.
> - 폴리필링은 **신기능을 동일하게 활용할 수 있는 코드를 생성하는 것**을 의미하고 트랜스파일링은 **신기능의 구문을 이전 버전의 구문으로 변경하는 것**을 의미합니다.

자바스크립트의 신기능이 나오면 모든 브라우저의 형태에서 다룰 수 있는 내용이 아닐 수도 있습니다.

- 이러한 부분을 해결할 수 있도록 고안한 기술이 **폴리필링(polyfilling)과 트랜스파일링(transpiling)**입니다.

<br/>

### Polyfilling ❓

---

**Polyfill(폴리필)**이라는 단어는 **신기능을 동일하게 활용할 수 있도록 자바스크립트 환경에서 실행할 수 있는 코드를 생성하는 것**을 의미합니다.

> 사전적 정의는 웹 개발에서 기능을 지원하지 않는 웹 브라우저 상의 기능을 구현하는 코드를 뜻한다고 합니다.

- 예를 들어, ES6에서는 원래 `isNaN()` 유틸리티를 사용하지 않고 **`NaN` 값에 대해 정확한 검사를 하기 위해 `Number.isNaN()` 이라는 유틸리티를 정의**합니다.
  - 이러한 부분을 사용자의 ES6 호환 브라우저의 사용 여부와 관계 없이 해당 유틸리티를 폴리필할 수 있습니다.

```js
if (!Number.isNaN) {
  Number.isNaN = function isNaN(x) {
    return x !== x;
  };
}
```

- `if` 문은 **폴리필 정의가 이미 존재하게 될 ES6 브라우저에서 폴리필 정의를 적용(재정의)하는 것을 방지**합니다.
  - 존재하지 않는다면 `Number.isNaN()` 을 정의합니다.
  - 여기서 `NaN` 값이 전체 언어에서 자체와 같지 않은 유일한 값이라는 점을 이용했습니다.

모든 신기능이 폴리필 가능한 것은 아닙니다.

- 때로는 대부분의 동작을 폴리필 할 수 있지만 여전히 작은 편차가 있습니다.
- 가능한 엄격하게 사양을 준수하는지 확인하기 위해 폴리필 구현에 심혈을 기울여야 합니다.
- 아니면 **이미 검증된 폴리필 세트(ES5-Shim, ES6-Shim)를 사용하는 것**도 좋은 방법입니다.

<br/>

### Transpiling ❓

---

언어에 새롭게 추가된 **폴리필 할 수 없는 구문**이 있을 수 있습니다.

- 이러한 경우 자바스트립트 엔진에서 인식할 수 없는 잘못된 오류를 발생시킵니다.
- 이런 상황에서는 최신 코드를 이전 코드로 변경시키는 **트랜스파일링(트랜스 + 컴파일)**이라는 방법을 사용할 수 있습니다.
- 기본적으로 **새로운 구문으로 작성**되며 브라우저에 배포될 때에는 **이전 구문 형식으로 변환된 코드가 배포**됩니다.
- 트랜스파일러는 일반적으로 코드 린터 혹은 축소기와 유사한 방식으로 **빌드 프로세스에 삽입**됩니다.

그렇다면 **왜 이전 코드를 직접 작성하지 않고, 굳이 트랜스파일러를 사용하는지**에 대해 궁금할 것입니다.

이러한 부분에서 트랜스파일러를 주목해야 할 부분은 다음과 같습니다.

- 새로운 구문은 **유지 보수에 용이하도록 설계된 결과물**일 것입니다. 이를 활용 함이 같은 구성원들로 하여금 큰 도움이 될 것 입니다.
- 이전 브라우저에 대해서만 트랜스파일를 진행하지만 최신 브라우저에 새 구문을 제공하는 경우 **새 구문으로 브라우저 최적화**를 할 수 있습니다.
- 새로운 구문을 일찍 사용하면 **TC39에 더 빠른 피드백을 제공**하고, **영구적인 디자인 오류가 발생하기 전에 이를 해결**할 수 있습니다.

간단한 트랜스파일링의 예시를 **ES6에 새롭게 추가된 매개변수 기본값**을 활용하여 들어보겠습니다.

```js
function foo(a = 2) {
  console.log(a);
}

foo(); // 2

foo(42); // 42
```

아주 간단합니다. 하지만 이 구문은 ES6를 지원하지 않는 구버전에서는 작동하지 않는 구문입니다.

해당 코드는 다음과 같이 변경될 수 있습니다.

```js
function foo() {
  var a = arguments[0] !== void 0 ? arguments[0] : 2;
  console.log(a);
}
```

- 인자의 값이 void 0 인지 확인하고, 그렇다면 인자로 2 값을 제공합니다.

이렇게 되면 구형 브라우저에서도 **더 나은 구문을 사용 함**과 동시에 **트랜스파일된 코드를 통해 의도한 동작을 더욱 명확히 확인**할 수 있습니다.

ES6 버전을 보고 undefined 가 매개변수 기본값에 대해 명시적으로 전달할 수 없는 유일한 값이라는 것을 깨닫지 못했을 수도 있지만, 트랜스파일된 코드는 더욱 명확하게 이를 표현합니다.

트랜스파일러를 통해 우리는 지원하지 않는 브라우저의 소멸을 기다리지 않고도 최신 문법을 사용할 수 있기에 이는 아주 좋은 기능입니다.

<br/>

## Non-JavaScript

---

자바스크립트는 대부분 브라우저와 같은 환경에서 동작하고 상호작용 하도록 작성되어 있고, 엄밀히 말하자면 많은 부분이 **자바스크립트에 의해 직접 제어되지 않습니다.**

가장 흔하게 접하게 될 것은 **DOM API**입니다.

```js
var el = document.getElementByID("foo");
```

- 문서 변수들은 코드가 브라우저에서 실행될 때 **전역 변수**로 존재합니다.
- 이는 자바스크립트 엔진에서 제공하지도 않고 제어하지도 않습니다.
- 자바스크립트 객체와 유사한 형태를 갖지만, 실제로는 그렇지 않습니다.
- 종종 호스트 객체라고 불리며 특수 객체입니다.
- 게다가 `document.getElementByID()` 메서드는 일반적인 자바스크립트 함수라고 생각하지만, 브라우저에서 DOM이 제공하는 내장 메서드를 통해 엷게 노출된 인터페이스일 뿐입니다.
- 일부 브라우저에선 이 레이어가 자바스크립트에 있을 수 있지만, 전통적으로 DOM과 그 동작은 C/C++과 비슷한 것으로 구현됩니다.

또 다른 예시로 **입출력**에 대한 내용이 있습니다.

- `alert()` 는 브라우저 창에 메시지 상자를 보여줍니다.
- 해당 메서드 또한 자바스크립트에서 제공하지 않고 **브라우저에 의해 자바스크립트에 제공**됩니다.
- 실제로 진행한 요청은 **메시지를 브라우저에 전달**하고 **메시지 상자 생성 및 표시를 처리**합니다.
- `console.log()` 또한 마찬가지입니다.

해당 도서는 **자바스크립트 언어**에 초점을 두기에 **자바스크립트 메커니즘의 실질적 범위**를 보지 못합니다.

그럼에도 불구하고 이러한 부분은 작성되는 자바스크립트에 있을 내용이기에 이를 알아야합니다.

<br/>

## Review

---

자바스크립트 프로그래밍을 배우는 첫 번째 단계는 **기본적인 메커니즘에 대한 이해**입니다.

그러한 부분을 이어지는 다른 시리즈에서 더욱 심도 깊게 다룰 것입니다.

이 책의 마지막 장에서는 다른 각 타이틀과 탐구한 내용 외 다른 개념을 간략히 요약할 것입니다.

<br/>
