---
slug: /up-going/samuel/into-YDKJS
title: Into YDKJS
tags: [basics, programming, javascript, YDKJS]
sidebar_position: 3
---

<br />

## 들어가며 🏃

---

해당 마지막 장에선 시리즈의 **나머지 책들에게 기대할 수 있는 내용**들과 **YDKJS를 활용하여 자바스크립트 학습의 기초를 구축하는 방법**에 대해 가장 효과적으로 요약할 것입니다.

<br />

## Scope & Closures ❕

---

> **TL;DR 🔖**
>
> - 우선적으로 **스코프의 범위 지정 동작 원리**에 대해 학습하고 이를 위해 **코드에 대한 컴파일러의 접근 방식**과 **호이스팅**에 대한 이해가 필요합니다.
> - 호이스팅에서 학습하는 **정적 스코프**에 대한 개념은 **클로저** 학습에 대한 기반이 되며 클로저의 가장 많은 응용인 **모듈 패턴**에 대해 이해해야 합니다.

<br />

아마 가장 먼저 이해해야할 개념 중 하나가 **스코프의 범위 지정 동작 원리**일 것입니다.

> 이에 대한 모호한 이해만으로는 충분하지 않습니다.

**Scope & Closures**의 제목은 **인터프리터 언어이므로 컴파일 되지 않는다는 일반적인 오해를 폭로하는 것**으로 시작합니다.

- 자바스크립트 엔진은 **실행 직전(혹은, 실행 중에) 코드를 컴파일**합니다.
- 컴파일러가 변수 및 함수의 선언을 찾고 처리하는 방법을 이해하기 위해선 **코드에 대한 컴파일러의 접근 방식**을 이해해야합니다.
- 그 과정에서 자바스크립트 변수 스코프 관리에 대한 일반적인 비유인 **호이스팅(hoisting)**을 봐야합니다.

**정적 스코프(lexical scope)에 대한 비판적 이해**는 책의 마지막 챕터인 **클로저**에 대한 탐구의 기초가 되는 것입니다.

- 클로저는 아마도 모든 자바스크립트에서 가장 중요한 단일 개념일 것입니다.
  - 그러나 먼저 스코프의 작동 방식을 확실히 이해하지 못했다면, 클로저를 이해하기 어려울 것입니다.
- 클로저의 중요한 응용 중 하나는 **모듈 패턴**입니다.
  - 모듈 패턴은 아마도 모든 자바스크립트에서 가장 널리 사용되는 코드 구성 패턴일 것입니다.

<br />

## this & Object Prototypes ❕

---

> **TL;DR 🔖**
>
> - `this` 에 대한 오해 중 하나는 **해당하는 함수를 참조한다는 것**이며, **함수 호출 방식에 따라 동적으로 바인딩된다는 사실**을 알아야 합니다.
> - `this` 와 연관있는 개념 중, **객체 프로토타입**에 대한 잘못된 생각은 **클래스와 상속을 모방한다는 것**입니다.

<br />

아마 자바스크립트에서 가장 큰 오해 중 하나는 **`this` 키워드가 해당하는 함수를 참조한다는 내용일겁니다.**

- `this` 는 해당 **함수가 실행되는 방식**에 따라 **동적으로 바인딩**되며, 이 바인딩을 이해하고 완전히 결정되기 위한 **네 가지 간단한 규칙**이 있는 것으로 이해했습니다.

`this` 키워드와 밀접하게 관련있는 것은 **정적 스코프 변수**를 찾는 방법과 유사한 프로퍼티 참조 체인인 **객체 프로토타입 메커니즘**입니다.

- 그러나 프로토타입에 포함된 또 다른 자바스크립트의 문제는 **클래스와 상속을 모방한다는 생각**입니다.
- 구문은 클래스와 같은 점이 있다고 생각할 수 있지만, 프로토타입 메커니즘은 근본적으로 반대의 내용을 갖습니다.
- 문제는 **불일치를 무시하고 구현하는 것이 상속인 척하는 것**이 더 나은지 아니면 **객체 프로토타입 시스템이 실제로 작동하는 방식을 배우고 수용하는 것**이 더 적절한지에 대한 여부입니다.
  - 후자의 경우 **작동 위임**이라는 이름이 적절합니다.

<br />

## Types & Grammar ❕

> **TL;DR 🔖**
>
> - 암묵적 강제는 절대적으로 나쁜 것이 아니며 이해 대한 명확한 이해가 필요합니다.

<br />

해당 제목에서 주로 다루는 주제는 **타입 강제**에 대한 내용입니다.

> 암시적 강제에 대한 혼란을 이야기할 때만큼 자바스크립트 개발자에게 더 많은 좌절감을 주는 주제는 없을 것입니다.

**암묵적 강제**는 자바스크립트의 나쁜 부분이며 **어떤 대가를 치르더라도 피해야한다는 것**이 일반적인 통념입니다.

> 심지어 어떤 사람들은 이를 **결함**이라고 부르기도 했습니다.

그렇다고 강제 변환을 사용한다면 처음부터 코드가 엉망이냐는 말에 필자는 반대입니다.

- **타입과 값이 실제로 작동하는 방식에 대한 이해**를 구축한 후, **강제가 작동하는 방식**을 완전히 설명할 것입니다.
- 필자는 단순히 강제가 합리적이고 학습 가능하다고 제안한다기 보다는, 놀랍게도 강제 변환은 과소평가된 도구라고 말합니다.

<br />

## Async & Performance ❕

---

> **TL;DR 🔖**
>
> - **비동기 프로그래밍을 위한 발전 과정**을 **콜백과 이에 대한 단점**, 이를 극복하기 위한 **프로미스와 제너레이터**에 대한 내용을 학습합니다.
> - 성능 최적화에 대한 내용은 **저수준 최적화 기술** 뿐만 아니라 **데이터 병렬 처리**와 같은 내용도 다루며, **적절한 벤치마킹 기술의 관점에서 성능 최적화**를 살펴봅니다.

<br />

해당 시리즈의 첫 세 단원은 **언어의 핵심 메커니즘**에 중점을 두고 있지만 네 번째 단원은 **비동기 프로그래밍을 관리하기 위한 언어 메카니즘의 상단에 있는 패턴**을 다루기 위해 약간 분기되어 있습니다.

- **비동기**는 애플리케이션 성능에 중요할 뿐만 아니라 **작성 능력 및 유지 관리 능력**에서 더 중요한 요소가 되고 있습니다.
- 해당 서적은 **`"async"`, `"parallel"`, `"concurrent"` 와 같은 용어의 개념 정의**로 시작하여, 이러한 내용들이 **자바스크립트에 어떻게 적용되는 지**에 대해 깊이 있게 설명합니다.

그리고 비동기를 활성화 하는 기본적인 방법으로 **콜백(callback)**을 탐구합니다.

- 그렇다면 **콜백의 주요 결함**인 **IoC(Inversion of Control) 신뢰 손실**과 **선형 추론 능력의 부족**을 알 수 있습니다.

이러한 두 가지 결함을 해결하기 위해 ES6애서는 **프로미스(Promise)와 제너레이터(generators)**라는 두 가지 메커니즘을 도입했습니다.

- 프로미스는 미래 값을 둘러싼 시간 독립적 래퍼로 **값의 준비 여부와 상관 없이 추론하고 구성할 수 있습니다.**
- 또한 신뢰할 수 있고 컴포저블한 프로미스 메커니즘을 통해 **콜백을 라우팅하여 IoC 신뢰 문제**를 효과적으로 해결합니다.

제너레이터는 자바스크립트 함수에 대한 **새로운 실행 모드를 도입**하여 제너레이터가 일시 중지되고 나중에 비동기식으로 재개될 수 있습니다.

- 일시 중지 및 재개 기능을 사용하면 제너레이터의 **동기식 순차 코드를 백그라운드에서 비동기식으로 처리할 수 있습니다.**
  - 그렇게 함으로써 **콜백의 비선형, 비로컬 점프 혼란**을 해결하고 **비동기 코드를 동기화 된 것처럼 보이게** 하여 보다 합리적으로 만듭니다.

5장에서는 **ASM.js와 같은 저수준 최적화 기술**뿐만 아니라 **프로그램의 병렬 처리 및 SIMD를 사용한 데이터 병렬 처리**와 같은 주제를 다룹니다.

6장에서는 **어떤 종류의 성능에 대해 신경써야 하고 무엇을 무시해야 하는 지**를 포함하여 적절한 벤치마킹 기술의 관점에서 **성능 최적화**를 살펴봅니다.

**자바스크립트를 효과적으로 작성한다는 것**은 **광범위한 브라우저 및 기타 환경에서 동적으로 실행되는 제약 장벽을 깨뜨릴 수 있는 코드를 작성하는 것**을 의미합니다.

> 작동과 잘 작동은 다른 것입니다.

<br />

## ES6 & Beyond ❕

---

> **TL;DR 🔖**
>
> - 해당 부분에선 기존에 집중했던 ES5에서 **ES6와 ES7**으로 중심을 옮겨 새로운 내용들을 접하는데 신경을 기울입니다.

<br />

여기까지 학습했다면 자바스크립트를 어느 정도 마스터 했다고 느끼겠지만, 자바스크립트는 계속 발전합니다.

- 이러한 사실은 **이 시리즈에 정신에 대한 은유**에 가깝습니다.

해당 단원은 **ES6와 같이 알려진 것**들 뿐만 아니라 **그 너머에 있을 가능성에 대한 것들, 언어가 어디로 향하고 있는지에 대한 단기 및 중기 비전** 모두에 집중합니다.

- 해당 시리즈는 ES6 채택 중반에 작업했기에 주로 ES5에 집중했지만, 이제는 ES6, ES7에 집중하려합니다.
- 해당 내용은 ES6 환경의 구체적인 내용을 **새로운 구문, 데이터 구조, 처리 기능 및 API를 포함한 여러 주요 범주로 나누는 것**으로 시작합니다.

<br />

#### ES6의 내용들

---

- 구조 분해 할당
- 매개변수 기본 값
- 심볼
- 간결한 메서드
- 계산된 프로퍼티
- 화살표 함수
- 블록 스코프 지정
- 프로미스
- 제너레이터
- 반복기
- 모듈
- 프록시
- 약한 맵 등...

여기서 가장 중요한 부분은 ES6 이후 자바스크립트가 **버전별이 아닌 기능별로 발전할 가능성이 있다는 것**입니다.

<br />

## Review

---

> YDKJS는 비판이나 모욕이 아니며, 우리 모두가 공감해야 한다는 깨달음입니다.

해당 시리즈는 모든 자바스크립트 개발자가 이 훌륭한 언어의 모든 부분을 배울 수 있고 배워야 한다는 명제에 전념합니다.
